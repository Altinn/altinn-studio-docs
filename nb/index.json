[
{
	"uri": "https://docs.altinn.studio/nb/app/design/insight/",
	"title": "Innsiktsfase",
	"tags": [],
	"description": "Først av alt bør du samle prosjektgruppen og starte med å definere problemet. Hva er det dere skal løse og hvem skal det løses for?",
	"content": "Tenk gjennom Hva er dagens utfordring? Start med å definere problemet. Hva er det dere skal løse? Med et klart avgrenset problem er det lettere å lage en klar løsning. Her kan det være en idé å samle prosjektgruppen, komme vekk fra møtebordet og bruke post-its på veggene. Hvem er brukerne og hvilke behov har de? Vi anbefaler at dere starter med å definere målgruppe og brukerbehov så tidlig som mulig i prosjektet. Lag en oversikt over hvem brukerne er. I de fleste tilfellene skal man lage løsninger som fungerer for flere brukergrupper. Er det innbyggere eller aktører i næringslivet? Hvilken bakgrunn har de? Er de digitale eller ikke så vant til å bruke digitale tjenester? I denne fasen gjøres det typisk innledende innsiktsarbeid i form av intervjuer, observasjoner eller fokusgruppe. Kontaktpunkter for brukeren Sett opp en oversikt/brukerreise over brukerens kontaktpunkt. Eksempel på hvordan en fragmentert brukerreise kan fortone seg: Skal Altinn være skjult for sluttbruker eller er det Altinns grensesnitt som skal benyttes? Stemmer dette med hvordan brukeren forventer å få løst sin oppgave? Er det mulig å tilby brukerne den relevante delen av altinn i den konteksten de er i, i stedet for å sende dem frem og tilbake? Hva er databehovet? Behovet for en digital løsning starter gjerne med at det er behov for å samle inn data. Start med å undersøke om andre har dataene du trenger og om disse er tilgjengelige for gjenbruk. Det kan du sjekke i Felles datakatalog. Hvis ikke - hvordan kan du spørre på en måte som krever minst mulig av brukerne? Noen ganger kan det være en idé å prøve noe annet enn opplagte løsninger hvor man spør i form av et skjema.  Når du har kommet deg gjennom innsiktsfasen og definert brukerbehov, anbefaler vi at du setter sammen en prototype som kan brukertestes på relevante brukere. Dersom du skal lage et skjema, kan du bruke vårt prototype-Kit for Figma.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/",
	"title": "Om Altinn 3",
	"tags": ["translate-to-norwegian"],
	"description": "Altinn 3 er tredje generasjon plattform for å utvikle og kjøre digitale tjenester.",
	"content": "The platform is owned by the Norwegian Digitalization Agency and developed as an open source platform.\nThe current development solution and hosting platform (launched 2010) is considered by Gartner as one of the five leading digital government technology platforms in the world.\nThe current platform is used by over 90% of the Norwegian population and almost 100% of the businesses. Over 62 agencies and municipalities host their solutions in the Altinn platform.\nThe current platform has almost 1000 active solutions supporting different user scenarios.\nExamples of solutions in the current platform is: Tax reporting, aircraft incident reporting, correspondence services from health department, lookup service in to the business register and many many more.\nConcept Using Altinn 3, agencies and other public entities can develop digital services as applications in Altinn Studio, they can deploy them to their isolated cloud infrastructure as containers. Altinn Platform supports the apps with core functionality like storage, authorization, authentication, register data, and more.\nThe infrastructure is highly scalable to support the different needs and all infrastructure is managed by the Altinn DevOps team.\nThe application template provided by Altinn Studio is prepared for the most common digital services scenarios making it possible to create and deploy the most simple public digital services in only hours.\nWhen an application is deployed to Altinn Apps it is available to all citizens and businesses of Norway.\nWhy Altinn 3? There are many reasons to use Altinn 3 to build and host your digital services.\n Application template are have built in functionality for the most common scenarios Easy to develop and deploy apps Reuse of data, UX, APIs and functionality A known platform for end users Highly scalable and secure infrastructure Open source Access to almost all citizens and business in Norway  When was Altinn 3 launched? The first version was launched in June 2020 and the first applications was deployed to production on june 19. 2020.\nHow to learn more about Altinn 3 Start with reading about the different solutions of Altinn 3.\n Altinn Studio let you build your digital services Altinn Apps let your host your digital services Altinn Platform will provide standard functionalit to your digital services  \rMål\rOppsummering av målene for Altinn 3.\n\r\rAltinn og åpen kildekode\rAltinn 3 er åpen kildekode, med en åpen backlog, åpen dokumentasjon og åpen dialog og diskusjoner.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/setup/",
	"title": "Oppsett for gruppering av felter",
	"tags": [],
	"description": "Generelt oppsett for gruppering av felter i skjema.",
	"content": "Felter i skjema kan settes opp til å bli del av en gruppe. Dette kan brukes til å f.eks. sette opp dynamikk på en enkelt gruppe av felter, i stedet for på hvert enkelt felt. I tillegg må felter kunnne grupperes for å støtte repeterende grupper i skjema.\nEn gruppe settes opp i FormLayout.json, sammen med de andre komponentene i skjemaet. Dette kan enten gjøres manuelt direkte i filen, eller via skjemaeditor i Atinn Studio ved å bruke Gruppe-komponenten.\nNoen punkter å notere seg ved manuelt oppsett:\n Gruppen må ligge før ev. komponenter som skal inngå i gruppen i FormLayout.json. En gruppe MÅ ha type: \u0026quot;group\u0026quot; satt for at den skal registreres som en gruppe  Eksempel på en (repeterende) gruppe definert i FormLayout.json som inneholder 4 felter som kan repetere 3 ganger: En gruppe defineres på følgende måte i FormLayout.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;\u0026lt;unik-id\u0026gt;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;group\u0026#34;,  \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;\u0026lt;gruppen i datamodellen (kun repeterende grupper)\u0026gt;\u0026#34; }, \u0026#34;maxCount\u0026#34;: \u0026#34;\u0026lt;Antall ganger gruppen kan repetere\u0026gt;\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34;, \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34;, \u0026#34;osv...\u0026#34; ],  \u0026#34;tableHeadings\u0026#34;: [ \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34; ], \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;add_button\u0026#34;: \u0026#34;tekstressurs.felt\u0026#34; } }    Parameter Påkrevd Beskrivelse     id Ja Unik ID, tilsvarer ID på andre komponenter. Må være unik i FormLayout.json-filen.   type Ja MÅ være \u0026ldquo;group\u0026rdquo;. Sier at dette er en gruppe.   dataModelBindings Nei MÅ være satt for repeterende grupper, med group-parameteren som i eksempelet over. Skal peke på den repeterende gruppen i datamodellen.   textResourceBindings Nei Kan være satt for repeterende grupper, med add_button-parameteren som i eksemepelt over. Denne bindingen til bli lagt til på knappen.   maxCount Ja Antall ganger en gruppe kan repetere. Settes til 1 om gruppen ikke er repeterende.   children Ja Liste over de feltene som skal inngå i gruppen. Her brukes felt-id fra FormLayout.json   tableHeadings Nei Liste over komponentener som skal inngå som en del av tabbel header feltene. Om ikke spesifisert så vises alle komponentene.    "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/repeating/",
	"title": "Repeterende grupper",
	"tags": [],
	"description": "Oppsett for repeterende grupper.",
	"content": "Grupper i datamodellen inneholder ett eller flere felter. Grupper er definert som repeterende dersom de har maxOccurs \u0026gt; 1 i xsd\u0026rsquo;en. En gruppe som er repeterende i datamodellen må også settes opp som repeterende i skjemaet, ellers vil lagring av data feile.\nEksempel Skjema med noen enkelt-felt, og en repeterende gruppe som:\n inneholder 3 felter kan repeteres opp til 3 ganger har lagt til egen streng på \u0026ldquo;legg til\u0026rdquo; knappen  Oppsett i FormLayout.json fra eksempelet over:\n1{ 2 \u0026#34;data\u0026#34;: { 3 \u0026#34;layout\u0026#34;: [ 4 { 5 \u0026#34;id\u0026#34;: \u0026#34;gruppe-1\u0026#34;, 6 \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, 7 \u0026#34;children\u0026#34;: [ 8 \u0026#34;ac555386-ac2b-47a0-bb1b-842f8612eddb\u0026#34;, 9 \u0026#34;5c079cd4-c80c-44ea-b8b8-18e323267a37\u0026#34; 10 ], 11 \u0026#34;maxCount\u0026#34;: 3, 12 \u0026#34;dataModelBindings\u0026#34;: { 13 \u0026#34;group\u0026#34;: \u0026#34;spesifisering-grp-5836\u0026#34; 14 }, 15 \u0026#34;textResourceBindings\u0026#34;: { 16 \u0026#34;header\u0026#34;: \u0026#34;person\u0026#34; 17 } 18 }, 19 { 20 \u0026#34;id\u0026#34;: \u0026#34;ac555386-ac2b-47a0-bb1b-842f8612eddb\u0026#34;, 21 \u0026#34;type\u0026#34;: \u0026#34;Checkboxes\u0026#34;, 22 \u0026#34;componentType\u0026#34;: 5, 23 \u0026#34;textResourceBindings\u0026#34;: { 24 \u0026#34;title\u0026#34;: \u0026#34;Avkrysningsboks\u0026#34; 25 }, 26 \u0026#34;dataModelBindings\u0026#34;: { 27 \u0026#34;simpleBinding\u0026#34;: \u0026#34;klage-grp-5805.spesifisering-grp-5836.KlageSpesifisering-datadef-25457.value\u0026#34; 28 }, 29 \u0026#34;options\u0026#34;: [ 30 { 31 \u0026#34;label\u0026#34;: \u0026#34;25795.OppgavegiverNavnPreutfyltdatadef25795.Label\u0026#34;, 32 \u0026#34;value\u0026#34;: \u0026#34;Verdi1\u0026#34; 33 }, 34 { 35 \u0026#34;label\u0026#34;: \u0026#34;25796.OppgavegiverAdressePreutfyltdatadef25796.Label\u0026#34;, 36 \u0026#34;value\u0026#34;: \u0026#34;Verdi2\u0026#34; 37 } 38 ], 39 \u0026#34;required\u0026#34;: true 40 }, 41 { 42 \u0026#34;id\u0026#34;: \u0026#34;5c079cd4-c80c-44ea-b8b8-18e323267a37\u0026#34;, 43 \u0026#34;type\u0026#34;: \u0026#34;AddressComponent\u0026#34;, 44 \u0026#34;componentType\u0026#34;: 11, 45 \u0026#34;textResourceBindings\u0026#34;: { 46 \u0026#34;title\u0026#34;: \u0026#34;Adresse\u0026#34; 47 }, 48 \u0026#34;dataModelBindings\u0026#34;: { 49 \u0026#34;address\u0026#34;: \u0026#34;klage-grp-5805.spesifisering-grp-5836.KlageSpesifiseringg-datadef-12345.value\u0026#34; 50 }, 51 \u0026#34;simplified\u0026#34;: true, 52 \u0026#34;readOnly\u0026#34;: false, 53 \u0026#34;required\u0026#34;: true 54 } 55 ] 56 } 57} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/alternatives/",
	"title": "Innstillinger",
	"tags": [],
	"description": "Innstillinger for visning.",
	"content": "Det er implementert en ny (valgfri) parameter som kan legges inn på definisjonen av en repeterende gruppe i layout-filen, som gjør at man kan styre litt rundt visningen og oppførselen til gruppen på siden. I tillegg er det lagt til støtte for flere \u0026ldquo;sider\u0026rdquo; inne i redigerings-flaten til gruppen.\nStyre visning Det er lagt til en ny parameter, edit, som kan settes på en gruppe-komponent (repeterende gruppe). Denne lar oss definere forskjellige innstillinger mtp visning av et gruppe-element under redigering/utfylling. Følgende innstillinger kan settes.\nmode Definerer om tabellen (som viser alle elementene i gruppen) skal vises når et element er åpent i redigerings-modus. Følgende verdier godtas:\n   Verdi Beskrivelse     \u0026ldquo;showTable\u0026rdquo; Standard oppførsel om ingenting er satt. Viser tabellen over flaten for redigering av gruppe-element.   \u0026ldquo;hideTable\u0026rdquo; Skjuler tabellen når et gruppe-element er åpent for redigering.   \u0026ldquo;showAll\u0026rdquo; Skjuler tabellen. Viser alle elementene i gruppen i redigerings-modus, under hverandre. Lagre-knapp skjules.    filter Støtte for å filtrere elementene i gruppen, slik at kun de elementene som matcher de definerte kriteriene vises. F.eks. i en gruppe som viser arbeidserfaring, vis kun de elementene der arbeidssted var Oslo. Liste med kriterier er basert på verdi av ett eller flere felter i gruppen, på formen\n\u0026#34;edit\u0026#34;: { \u0026#34;filter\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;felt i datamodell\u0026gt;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026lt;ønsket verdi\u0026gt;\u0026#34; } ] } Dersom det er flere kriterier, må alle matche for at elementet skal vises.\nOm det kun er ett resultat, vises dette automatsk i redigerings-modus. Om det er flere elementer i gruppen som matcher filteret, vil disse vises. Andre elementer i gruppen skjules. filter kan kombineres med mode-parameter.\nOm man kombinerer `\"mode\": \"showAll\"` med `\"filter\"`, vil det ikke fungere å legge til nye elementer i gruppen. Dette er fordi man med \"showAll\" kun viser redigerings-flaten, og så lenge filteret ikke matcher, vil ikke elementet vises.\r\rsaveButton Bestemmer om \u0026ldquo;Lagre\u0026rdquo;-knappen vises når et gruppeelement er i redigeringsmodus. Standard oppførsel om parameteren ikke er satt er at \u0026ldquo;Lagre\u0026rdquo;-knapp vises. Dersom man har satt \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot; skjules Lagre-knappen alltid, da man i denne modusen ikke har mulighet til å lukke redigerings-flaten for gruppe-elementet. Dataene lagres uansett.\ndeleteButton Bestemmer om \u0026ldquo;Slett\u0026rdquo;-knappen vises når et gruppeelement er i redigeringsmodus. Standard oppførsel om parameteren ikke er satt er at \u0026ldquo;Slett\u0026rdquo;-knapp vises.\nmultiPage Sier at redigering/utfylling av gruppe kan gjøres over flere \u0026ldquo;sider\u0026rdquo;/visninger. Krever mer oppsett for å fungere, se under for mer informasjon.\nFlere sider innad i gruppe-visning - Denne funksjonaliteten er p.t. kun tilgjengelig for repeterende grupper.\r- Visning av gruppe over flere sider inne i redigerings-flaten til gruppen støttes KUN for grupper på øverste nivå, og støttes ikke for grupper i grupper.\r\rNår man skal legge inn data i en gruppe, kan det være tilfeller der hvert element i gruppen inneholder mange felter, og at det dermed blir mye scrolling og uoversiktlig for sluttbruker. For å løse dette er det innført en mulighet til å dele opp utfyllingen over flere visninger, som bruker kan navigere frem/tilbake mellom mens de fyller ut gruppe-elementet. Navigeringen her skjer innad i en layout, og oppdaterer kun visningen inne i redigeringsflaten for gruppen.\nFor å ta i bruk denne funksjonaliteten, må man prefikse komponentene i children listen med et tall som tilsier hvilken \u0026ldquo;side\u0026rdquo; av utfyllingen komponenten skal vises på, etterfulgt av :. Vi starter tellingen på 0, dvs. at komponenter som skal vises på den første \u0026ldquo;siden\u0026rdquo; må prefikses med 0:. Komponenter som skal vises på den andre siden prefikses med 1:. Osv. I tillegg må man sette \u0026quot;multiPage\u0026quot;: true på den nye edit-parameteren (se over). Se eksempel under:\n{ \u0026#34;id\u0026#34;: \u0026#34;Some-group-id\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;0:fnr\u0026#34;, \u0026#34;1:fornavn\u0026#34;, \u0026#34;1:mellomnavn\u0026#34;, \u0026#34;1:etternavn\u0026#34;  ], \u0026#34;maxCount\u0026#34;: 10, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;familie.barn\u0026#34; }, \u0026#34;edit\u0026#34;: { \u0026#34;multiPage\u0026#34;: true, \u0026#34;mode\u0026#34;: \u0026#34;hideTable\u0026#34;,  } } Her har man også lagt inn en mode som skjuler tabellen under redigering. Resultatet blir som vist under.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/prototype/",
	"title": "Prototype",
	"tags": [],
	"description": "Ved hjelp av Altinns Prototype-kit kan du lage en klikkbar prototype for å definere flyt og innhold i din tjeneste.",
	"content": "Altinn Prototype-kit er en samling av sidemaler og komponenter du kan bruke til å lage en prototype i Figma av Altinn-skjemaet ditt.\nMed Altinns Prototype-Kit for Figma kan du:\n Se hvordan Altinn-skjemaer ser ut og oppleves for brukeren Gjør deg kjent med designelementer i Altinn 3 Definere flyt og innhold for ditt eget skjema Lage klikkbare skisser som kan brukertestes Bruke prototypen som en spesifikasjon/referanse når appen utvikles  Kom i gang med Figma Det er en fordel hvis du har en designer i prosjektet som har brukt Figma eller liknende verktøy tidligere. Dersom du ikke har tilgang på en slik ressurs anbefaler vi å gå gjennom en introduksjon til Figma først.\n Opprett en bruker på https://www.figma.com/. Figma kan installeres lokalt eller brukes i din nettleser. Åpne Altinn prototype-kit og følg stegene som er beskrevet i introduksjonen på første side i filen:  \r\rAltinn Prototype-kit\r\r\r\rNår designeren/fagpersonen har designet ferdig skjemaet, og det er brukertestet, kan det videre brukes som spesifikasjon til det utviklerne skal lage i Altinn Studio.\nNB: Skal du lage tjenester i egen løsning, der Altinn er usynlig for brukeren, bør du heller bruke etatens eget designsystem for å prototype tjenesten.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/",
	"title": "Endringslogg for app frontend",
	"tags": [],
	"description": "Oversikt over endringer introdusert i app frontend.",
	"content": "\rv3\rOversikt over endringer introdusert i v3 av app frontend.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/usertest/",
	"title": "Brukertest",
	"tags": [],
	"description": "Det er alltid lurt å brukerteste i flere faser av prosjektet. Gjennom brukertester måler du om det du lager treffer brukernes behov. Det er en god investering å gjøre dette tidlig i prosjektet, slik at du ikke bruker penger på å utvikle en løsning som ikke løser utfordringene.",
	"content": "Å brukerteste trenger ikke være veldig avansert, hverken med tanke på oppsett eller antall testpersoner. En tommelfingerregel er at hvis du har testet på fem personer har du funnet 80 % av brukervennlighetsfeilene (Jacob Nielsen).\nEtter en brukertest vil det være ting å justere på. Det kan være større ting som navigasjon og flyt, men også små justeringer som språk eller mindre endringer i interaksjonsdesignet. Hvis det er behov for å gjøre større endringer kan det være lurt å ta en ny brukertest for å sjekke om justeringene har ønsket effekt.\nEt tegn på om du har lykkes å lage en løsning som treffer brukernes behov er hvis de fleste brukerne i brukertesten klarer å gjennomføre det de skal ha gjort på nettstedet eller løsningen din uten hjelp, og innenfor en fornuftig tidsramme.\nBrukertesting i Figma Har du satt opp en prototype i Figma ved hjelp av vårt Prototype-Kit? Flott! Da kan du benytte denne til brukertesting!\nDersom du har lagt til flere steg i ditt skjema, må du huske å lenke mellom disse stegene. Dette gjør du ved å velge \u0026ldquo;Prototype\u0026rdquo; oppe til høyre i Figma. Marker en ramme eller en knapp og legg merke til den lille hvite dotten som vises til høyre på det du markerte. Denne dotten kan du ta tak i og dra til rammen du ønsker å gå til.\nDet finnes en flyt for hvert startalternativ, samt en flyt for mobilskissene. Trykk på Play-knappen på prototypen du vil starte. Etter at den er startet kan du bytte mellom de ulike flytene i venstremargen.\nFor å dele filen med testerne velger du “Share” oppe til høyre i vinduet. Du kan enten velge at filen skal være åpen for alle som har lenken, eller at kun inviterte (via epost) skal få tilgang.\nGode råd for brukertesting  Test tidlig med reelle brukere Brukervennligheten kan kun måles om den blir testet på målgruppen til løsningen. Å teste tidlige gjør det billigere å fikse eventuelle problemer som avdekkes. Ufarliggjøre testen Forklar testdeltageren at hensikten ikke er å teste hvor flinke de er, men at hovedfokuset er på å avdekke eventuelle feil med tjenesten, slik at den kan bli enda bedre. Be testpersonen om å tenke høyt. For noen vil det å «tenke høyt» komme av seg selv, mens andre trenger et par påminnelser innimellom. Ikke still ledende spørsmål, men vis at du ønsker å høre testpersonens tanker og tilbakemeldinger. Vær lyttende Husk å gi testpersonen rom for tenkepauser og ha først og fremst en lyttende posisjon. Avsett god tid, så du unngår stressende stemning. Minn deg selv på formålet med testen Tilbakemeldinger fra testdeltager kan fort oppfattes som kritikk mot eget arbeid, minn deg selv på at du ønsker jo tross alt at tjenesten skal bli så bra som mulig.  Uforme testoppgaver Bruk god tid på å formulere oppgavene til brukertesten, og gjør gjerne en pilottest i forkant for å avdekke feil med selve testen.\n Sett et klart mål for hva deltakeren skal prøve å oppnå. Velg oppgaver som er relevante og troverdige Ikke gi bort svaret eller gi for mange hint  Hos gov.uk finner du flere gode råd for å gjennomføre testen på best mulig måte.\nEtter testen Når du har vært gjennom et par brukertester har du sannsynligvis funnet ting du bør forbedre i utformingen av skjemaet eller formuleringen av innholdet. Vurder å kjøre en ekstra runde brukertesting etter du har gjort endringene.\nNå er du snart klar for utvikling! Husk også å se våre retningslinjer for design og innhold i skjemaene.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/",
	"title": "Data",
	"tags": [],
	"description": "Konfigurering av datamodell, preutfylling og andre ting relatert til data i en app.",
	"content": "\r\rDatamodell i Altinn Studio\rSlik importerer eller viser du datamodellen i Altinn Studio.\n\r\rPreutfylling av data (prefill)\rHvordan konfigurere prefill for en app.\n\r\rKodelister (options)\rHvordan konfigurere options/kodelister for en app.\n\r\rVedlegg\rI en applikasjon kan man legge til rette for opplasting av filvedlegg både via GUI og API.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/design/",
	"title": "Design",
	"tags": [],
	"description": "Altinn har som mål å gjøre det enklere for innbyggere og næringsliv å være i kontakt med det offentlige uavhengig av digital kompetanse. Felles retningslinjer for design hjelper oss å skape konsistens på tvers av tjenester som lages i Altinn Studio.",
	"content": "Designprinsipper Når vi utvikler nye eller forbedrer eksisterende produkter følger vi et sett med prinsipper for å kunne sikre oss at vi leverer brukervennlige løsninger til alle. Vi anbefaler å følge disse prinsippene når du jobber med utvikling av nye tjenester.\n Vi setter brukerbehov først Vi bruker innsikt om brukernes behov aktivt i utviklingen av produktene våre. Alle løsninger skal fokusere på å løse reelle problemer for brukerne og vi bruker undersøkelser og brukerinnsikt til å ta beslutninger. Skjule kompleksitet Vi lager fokuserte og forenklede løsninger og skreller vekk unødvendig kompleksitet for brukerne. Løsningene er ofte komplekse på baksiden, men fremstår enkle og brukervennlige for folk som bruker dem. Helhetlige brukeropplevelser Produktene våre skal henge sammen slik at folk får en helhetlig brukeropplevelse. Vi bruker konsistent språk og samme komponenter i alle digitale løsninger. Brukerne skal kjenne seg igjen uansett hvilken del av produktet man bruker. Visuelt design som motiverer Det visuelle designet skal bidra til å gjøre brukerne trygge i dialogen med det offentlige. Vi bruker en vennlig fargepalett, et enklere grensesnitt, tydelige interaksjonselementer og fargesterke illustrasjoner til å skal skape en god atmosfære. Alle visuelle beslutninger skal ha et klart formål om å skape en spesifikk effekt. Tilgjengelighet for alle Vi strekker oss langt for å lage digitale løsninger som skal være tilgjengelige for alle. Vi gjenbruker komponenter som en måte å optimalisere tilgjengelighet på - teknisk så vel som interaksjonsdesign og visuelt design.  Konsistens på tvers av tjenester Felles retningslinjer for design hjelper oss å skape konsistens på tvers av tjenester som lages i Altinn Studio.\nNår brukere møter en ny tjeneste, har de med seg forventninger fra tidligere opplevelser. Når disse forventningene møtes, kreves det mindre av brukeren for å samhandle med komponentene, og det bygges selvtillit. Ved å ikke trenge å lære nye interaksjoner, vil brukerens fokus i større grad være på innholdet.\nVi anbefaler ikke å endre CSS for individuelle tjenester som bruker Altinn-designet. Dersom vi åpner opp for designendringer og fargeendringer, vil dette skade konsistensen mellom tjenestene. Konsekvent design mellom tjenesteeiere er noe vi bør strekke oss mot. For å få det til kreves et godt samarbeid mellom fagmiljøet i Altinn og hos de ulike tjenesteeierene. Vi ønsker oss en god felles løsning som kan brukes og forbedres av alle, fremfor mange forskjellige løsninger gjennom ulike CSS-endringer. Dette vil også gjøre det lettere å kontrollere tilgjengeligheten på tvers av apper på plattformen vår. Velger du likevel å gå bort fra designet, er du selv ansvarlig for å følge alle WCAG-krav.\nHar du behov for en ny komponent?\nVi ønsker at alle er med på å videreutvikle biblioteket av komponenter med både design og kode. I praksis vil dette si at Altinn ønsker å ta imot forslag til nye komponenter etter hvert som tjenesteeierne ser behovet for det.\nOpprett en sak i github\rSkriv til oss på Slack\r\r\r\rInngang til skjema Brukertester har vist at når brukerne starter på etaten/kommunens sider for å fylle ut et skjema og så blir sendt videre til Altinn, får de ofte opplevelsen av at «plutselig var jeg i altinn». Innganger til skjema bør derfor presenteres slik at det er tydelig at man går til Altinn, men samtidig slipper å gå innom unødvendige mellomledd. \u0026ldquo;Start innsending\u0026rdquo; bør lenke direkte til skjemaet. Opplevelsen til bruker vil da også i større grad bli at man får løst oppgaven i konteksten man er i, men at Altinn er brukt som løsning for innsending og historikk.\nIntegrerte komponenter\nI tett samarbeid med sentrale tjenesteeiere planlegger vi på sikt å kunne tilby komponenter som kan benyttes på etatens nettsider, slik at brukerne kan løse oppgaven i den konteksten de er i.\nAltinns brukere ønsker både løsning der de er og en samlet oversikt. Og de bør få begge deler. Men behovene dekkes best på litt forskjellige måter.\n\r\rInnhold i skjema Brukeren skal ikke trenge å få feilmelding for å forstå hva som skal til for å fylle ut skjemaet riktig. Dette bør tydelig komme frem i informasjonstekst i begynnelsen av skjemaet og i labels som tilhører hvert enkelt skjemafelt.\nSom hovedregel bør man kun spørre om informasjon som er helt nødvendig å innhente. Du kan derfor opplyse i starten av skjemaet om at alle felt er påkrevde og må fylles ut (for å slippe å markere alle som påkrevde). Frivillige felt kan eventuelt markeres med \u0026ldquo;frivillig\u0026rdquo; i selve labelen til feltet.\nFordel innholdet i flere steg og bruk sporvalg En side med mye informasjon og flere oppgaver kan fort bli overveldende for en bruker. Prøv å del opp tjenesten slik at brukeren bare har en oppgave per side. Dette kan for eksempel være et spørsmål brukeren må svare på eller viktig informasjon som må leses. Dette kan gjøre det lettere for brukeren å fokusere på og forstå det du ber dem om.\nDesignet vi tilbyr nå er laget med utgangspunkt i dette konseptet. Et større antall komponenter kan føre til mye scrolling og en mer uoversiktlig opplevelse for brukeren. Se eksempel: Starte enkeltpersonforetak.\nBrukeren skal slippe å svare på mer enn nødvendig. Dersom brukeren har svart nei på et spørsmål og du dermed kan skjule flere av stegene for ham, kan du gjøre dette med dynamisk sporvalg.\nDisabled Ved å vise skjemafelt som disabled forventer man at brukeren skal vite hvorfor de ikke kan bruke elementet, men dette er ikke alltid tilfellet. Noen brukerer forstår heller ikke at feltet er deaktivert, som igjen kan føre til forvirring. Bruk av disabled bør derfor unngås. Dersom en handlingen av en eller annen grunn ikke er tillatt, kan dette i stedet forklares i en informasjonstekst.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/generic/",
	"title": "Generelt",
	"tags": [],
	"description": "Oversikt over logikkfiler og hvordan de kan brukes.",
	"content": "Introduksjon De forskjellige filene som brukes til å definere logikk, finner man i logikk-menyen, som er tilgjengelig i UI-editoren via f(x)-ikonet øverst til høyre.\nDe kan også redigeres direkte fra applikasjonsrepoet, under folderen App/logic (for serverside applikasjonslogikk) eller folderen App/ui (for dynamikk). Denne folderen inneholder som standard følgende filer:\n🗀 App/ 🗀 logic/ 🗀 Calculation/ 🗎 CalculationHandler.cs 🗀 Print/ 🗎 PdfHandler.cs 🗀 Validation/ 🗎 ValidationHandler.cs 🗎 App.cs 🗎 InstantiationHandler.cs Flere filer kan legges til her når det er nødvendig.\nEt komplett prosjekt med eksempler på serverside applikasjonslogikk ligger her.\nMERK: Måten man refererer til elementer i datamodellen er ulik mellom OR og SERES typer XSDer. For OR XSDer er .value et nødvendig suffiks i referansen. Eksempelkoden under bruker en blanding av de to typene datamodeller.\n\r\rAuto-complete/intellisense Ved å redigere kildekoden i appene lokalt, i f.eks. Visual Studio Code, får man intellisense og autocomplete med på kjøpet. For C#-filene er det enkleste å jobbe med disse lokalt.\nFor javascript-filene er det også intellisense/autocomplete tilgjengelig om man ønsker å redigere filene direkte i Altinn Studio. Dette kommer automatisk mens man skriver, og man kan også tvinge det frem ved å trykke CTRL + SPACE\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/intro/",
	"title": "Introduksjon til Altinn Studio",
	"tags": [],
	"description": "Altinn Studio er vårt nye verktøy for å utvikle offentlige digitale tjenester. Dette kan være alt fra helt enkle skjema til avanserte applikasjoner.",
	"content": "Prosessen for å lage skjemaer og meldinger vil være forskjellig alt etter som hvor stor eller liten målgruppen er, hvor mye data som skal behandles eller hvor mye jobb det er å legge til rette for at egne systemer kan snakke med Altinn.\nSlik går du frem:\n  Start alltid med å definere brukerbehov\nTenk nøye gjennom hele prosessen fra et brukerperspektiv. Hva er utfordringen og hvem skal den løses for? Hva er databehovet? Lag gjerne en skisse til kommunikasjon med brukeren og test skissen på folk i målgruppen.\nPlanlegg og design din app\r\r\r  Få tilgang til systemer\nHvis du ikke har utviklet tjenester i Altinn Studio før trenger du å opprette en bruker. Har du ikke allerede en ferdig datamodell/XSD så trenger du i tillegg tilgang til SERES-domeneklient.\n  Tilrettelegge egne systemer for sending og mottak av data\nDet finnes standardiserte mønstre basert på REST-API for å sende og motta data fra/til dine interne systemer. Autentisering skjer med Maskinporten og du laster ned data ved pull fra database, og laster opp data direkte mot API i den enkelte applikasjon. Vår referanseapplikasjon Altinn CLI ​viser disse mønstrene og kan brukes for å komme i gang.\n  Utvikle tjenestene\nAltinn Studio brukes til å opprette applikasjoner (apps). En app kan være alt fra enkle skjemaer til større avanserte applikasjoner som digitaliserer komplekse prosesser. Det er viktig å tenke på at brukeren skal oppleve prosessene som sammenhengende og oversiktlige. Prosessene kan startes av det offentlige eller av brukeren selv, eller automatisk som en reaksjon på en hendelse.\n  Teste tjenestene\nAltinn har et eget testmiljø hvor du kan teste om apper og opp-/nedlasting av data virker som det skal. I testmiljøet bruker du fiktive testpersoner og organisasjoner. Når du har kommet så langt i utviklingen er det også viktig å brukerteste den endelige løsningen på reelle folk i målgruppen. Dette for å sikre at det ikke er noen hinder for de som skal bruke tjenestene. Det er også mulig å teste app lokalt på egen maskin.\n  Produksjonssette tjenestene\nTjenesteeier kan selv produksjonssette sine applikasjoner og gjøre vedlikehold av kode og avhengigheter.\n  Melding av feil\nFeil meldes til Altinn fra den enkelte tjenesteeier sitt dashboard på Altinn Digitalisering (krever innlogging).\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/",
	"title": "Kom i gang",
	"tags": [],
	"description": "Kom i gang slik at du kan utvikle apper i Altinn Studio.",
	"content": "\r\rIntroduksjon til Altinn Studio\rAltinn Studio er vårt nye verktøy for å utvikle offentlige digitale tjenester. Dette kan være alt fra helt enkle skjema til avanserte applikasjoner.\n\r\rOpprette bruker i Altinn Studio\rKonfigurer brukeren din i Altinn Studio for første gang.\n\r\rKopier app i Altinn Studio\rSlik oppretter man en kopi av applikasjon i Altinn Studio.\n\r\rOpprette app i Altinn Studio\rSlik oppretter man en ny applikasjon i Altinn Studio.\n\r\rMigrere tjenester\rFra Altinn 2 til Altinn 3.\n\r\rNavigasjon i Altinn Studio\rSlik navigerer du mellom de ulike delene av Altinn Studio.\n\r\rTilganger\rHvordan man får tilganger til Altinn Studio, hemmeligheter og applikasjonslogger.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/",
	"title": "Lage apper",
	"tags": [],
	"description": "Altinn Studio er vårt nye verktøy for å utvikle digitale tjenester (apps). Dette kan være alt fra helt enkle skjema til veldig avanserte applikasjoner.",
	"content": "\rHvem kan ta i bruk Altinn Studio?\nDu må være tjenesteeier i Altinn samt godta bruksvilkår for Altinn i skyen for å kunne produksjonssette apper, men alle kan logge inn i altinn.studio og teste ut mulighetene.\n\r\rHvis du lurer på noe så er det bare å ta kontakt med oss på Slack eller GitHub, eller lese denne dokumentasjonen.\n\rKom i gang\rKom i gang slik at du kan utvikle apper i Altinn Studio.\n\r\rDesign og planlegging\rFor at tjenesten din skal bli best mulig for de som skal bruke den, er det viktig å starte med å fokusere på brukerne og forstå deres brukerbehov i møte med tjenesten din.\n\r\rUtvikling\rHvordan opprette og redigere apper i Altinn Studio.\n\r\rTesting av apper\rApplikasjoner (apper) kan testes i testmiljø, eller lokalt.\n\r\rProduksjonssetting av apper\rTjenesteeier kan selv produksjonssette sine applikasjoner, og gjøre vedlikehold av kode og avhengigheter.\n\r\rVedlikehold av app i produksjon\rApplikasjoner i produksjon krever jevnlig vedlikehold og oppdateringer.\n\r\rLanserte tjenester\rOversikt over hvilke tjenester som allerede er i produksjon, til informasjon og inspirasjon\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/navigation/",
	"title": "Navigasjon mellom sider",
	"tags": [],
	"description": "Hvordan sette opp navigasjon mellom sider.",
	"content": "Navigering videre til neste side skjer via en navigerings-knapp. Denne må legges til manuelt i hver layout-fil hvor man ønsker navigering fremover. Navigering tilbake til forrige side gjøres via tilbake-pil i venstre hjørnet. Denne knappen vises alltid så lenge det er en side å gå tilbake til, og er ikke en del av layout-filen. Se bilde under.\nLegge til knapp for navigering Knapp for navigering legges inn i alle layout-filer der det er behov. Om man ønsker at den skal dukke opp nederst på siden, må den legges inn nederst i layout-filen. Eksempel vises under\n{\r\u0026quot;id\u0026quot;: \u0026quot;nav-page2\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;NavigationButtons\u0026quot;,\r\u0026quot;textResourceBindings\u0026quot;: {\r\u0026quot;next\u0026quot;: \u0026quot;next\u0026quot;,\r\u0026quot;back\u0026quot;: \u0026quot;back\u0026quot;\r},\r\u0026quot;dataModelBindings\u0026quot;: {}\r}\rDet er også mulighet for å vise en tilbake-knapp sammen med neste-knappen, ved å legge til parameteren \u0026quot;showBackButton\u0026quot;: true på komponenten.\n   Parameter Beskrivelse     id Unik ID, tilsvarende som for alle andre skjemakomponenter.   type Må være \u0026quot;NavigationButtons\u0026quot;   textResourceBindings Setter man parametre next (og evt. back) her, vil man kunne overstyre med egne tekster som vises på knappen(e). Se eksempel over.   showBackButton Valgfri. Gjør at 2 knapper (tilbake/neste) vises i stedet for bare en (neste).    Rekkefølge Standard rekkefølge for sidene er alfabetisk. Utover det kan man navngi hver side som man ønsker, det er da filnavnet som gjelder her. For å sikre at sidene kommer i ønsket rekkefølge kan man f.eks. sette en prefix med tall foran sidenavnet i filnavn. F.eks:\n|- App/\r|- ui/\r|- layouts/\r|- 1.firstPage.json\r|- 2.secondPage.json\r|- 3.aFinalPage.json\rDet er også mulig å styre rekkefølgen på sidene ved hjelp av Settings.json under App/ui/. Dette gjøres på følgende vis:\n{\r\u0026quot;pages\u0026quot;: {\r\u0026quot;order\u0026quot;: [\u0026quot;side2\u0026quot;, \u0026quot;side1\u0026quot;]\r}\r}\rHer vil sidene da vises i rekkefølgen spesifisert i pages.order. Om denne array\u0026rsquo;en ikke settes i repo så vil man bruke alfabetisk rekkefølge som utgangspunkt for rekkefølgen på sidene.\nFunksjonalitet for å kunne dynamisk bestemme hvilken side som er neste er ikke noe som støttes i denne versionen av funksjonaliteten.\r\rValidering ved sidebytte Det er mulig å trigge validering i det brukeren prøver å bevege seg til neste side. Dette kan gjøres ved å legge til strengen validatePage i triggers på navigasjons-knapp komponenten. Eksempel:\n{\r\u0026quot;id\u0026quot;: \u0026quot;7cbc1c00-4c8c-42b6-bcef-12b3c4c45373\u0026quot;,\r\u0026quot;type\u0026quot;: \u0026quot;NavigationButtons\u0026quot;,\r\u0026quot;componentType\u0026quot;: \u0026quot;NavigationButtons\u0026quot;,\r\u0026quot;textResourceBindings\u0026quot;: {\r\u0026quot;next\u0026quot;: \u0026quot;Neste\u0026quot;,\r\u0026quot;back\u0026quot;: \u0026quot;Tilbake\u0026quot;\r},\r\u0026quot;triggers\u0026quot;: [\u0026quot;validatePage\u0026quot;],\r\u0026quot;dataModelBindings\u0026quot;: {},\r\u0026quot;showBackButton\u0026quot;: true\r}\rVed å legge til validatePage i triggers vil app-frontend kjøre valideringene på den aktuelle siden i det brukeren navigerer til neste side. Om det er feilmeldinger på siden vil brukeren bli hindret i å gå videre før dette er rettet opp. Om validatePage er lagt til som en trigger vil også id\u0026rsquo;en på siden som trigger valideringen sendes ved som en header LayoutId til valideringene som kjøres på serversiden. Dette muliggjør å skreddersy backend-valideringene basert på hvilken side brukeren trigger valideringen fra.\nDet er også mulig å trigge validering på alle sider ved å legge til validateAllPages i triggers.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/",
	"title": "Sider",
	"tags": [],
	"description": "Hvordan sette opp en app med flere sider, sporvalg, oppsummering eller flere skjema.",
	"content": "Oppsett av flere sider kan gjøres enten manuelt (som beskrevet under) eller direkte i skjema-editoren i Altinn Studio.\rMerk at siste side sluttbruker var innom nå caches slik at man kommer tilbake til denne siden når appen lastes inn på nytt.\r\rOppsett For å få funksjonalitet for flere sider i skjema, må nuget-versjon til pakkene app\u0026rsquo;en bruker oppgraderes til versjon 1.2.0-alpha eller nyere. Se instrukser for hvordan det gjøres her.\nFlere sider i skjema (innenfor samme prosess-task) støttes ved å dele opp dagens layout-fil App/ui/FormLayout.json i en fil per side. Filene må legges i en mappe App/ui/layouts. Hver layout-fil må bruke samme format som den eksisterende FormLayout.json filen. F.eks.:\n|- App/\r|- ui/\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json\rAnbefalt fremgangsmåte så lenge det er behov for å sette det opp manuelt, er å bruke ui-editoren i Altinn Studio for å legge inn alle komponentene inn i FormLayout.json, for å så kopiere de ut i sine respektive layout-filer, en for hver side man ønsker. FormLayout.json kan enten få nytt navn under layouts-mappen, eller slettes.\nMerk: FormLayout.json må enten flyttes (evt med nytt navn) inn i layouts-mappen, eller slettes. Dersom man har den gamle FormLayout.json-filen under App/ui-mappen som tidligere, vil kun denne brukes og alle filer under App/ui/layouts-mappen ignoreres.\n\rNavigasjon mellom sider\rHvordan sette opp navigasjon mellom sider.\n\r\rSporvalg\rHvordan legge til dynamisk sporvalg i app\n\r\rOppsummeringsvisning\rHvordan sette opp visning av oppsummering av utfylt skjema.\n\r\rFlere skjema i samme app (layout-sets)\rHvordan sette opp en app som inneholder flere ulike skjema.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/",
	"title": "UI-komponenter",
	"tags": [],
	"description": "De ulike komponentene er laget for at de skal passe sammen i en større helhet. Det er derfor viktig å følge retningslinjene for hvordan disse brukes for å oppnå et konsistent og gjenkjennbart uttrykk. UI-komponenter som foreløpig inngår i Altinns bibliotek finner du her.",
	"content": "Har du behov for en ny komponent?\nVi ønsker at alle er med på å videreutvikle biblioteket av komponenter med både design og kode. I praksis vil dette si at Altinn ønsker å ta imot forslag til nye komponenter etter hvert som tjenesteeierne ser behovet for det.\nSjekk gjerne nedenunder at ikke komponenten du trenger allerede eksisterer.\nOpprett en sak i github\rSkriv til oss på Slack\r\r\r\rTittel og avsnitt Det bør som hovedregel alltid være en header (H2) og et avsnitt i starten på en skjamaside for å oppsummere brukerens oppgave.\nRetningslinjer:  Tekstlengde på avsnitt strekkes ikke ut 100% i modalboksen, ettersom lange linjer tekst forstyrrer flyten i lesingen. Avsnitt er derfor begrenset til maks 696px i bredden, selv om modalen fyller ut 1056px. Teksten skal alltid være venstrestilt.  Eksempel på bruk: \r Knapp og lenke Hovedknapp (blå) brukes for å sende brukeren til neste steg.\nRetningslinjer:  Det skal kun være en hovedknapp per side. Sekundærvalg kan legges til som knapper stylet som lenker. Teksten på knappen skal være tydelig. Som regel fungerer \u0026ldquo;Neste\u0026rdquo; bra, men knappen kan også formuleres som svar på et spørsmål (se eksempel under). På siste steg i skjemaet (innsending) skal hovedknappen være grønn.  Eksempel på bruk: \r Inputfelt Inputfelt brukes når brukeren skal føre inn tekst eller tall.\nRetningslinjer:  Et inputfelt skal alltid ha en tilhørende label med forklarende tekst. Ta en vurdering på om ekstra beskrivelser og hjelpetekster må kobles til input elementet. To inputfelt kan plasseres ved siden av hverandre dersom de på et eller annet vis hører sammen. Se eksempel under. Deaktivert felt bør unngås. Dersom et felt ikke kan redigeres bør informasjonen heller presenteres i tekst.  Eksempel på bruk: \r Stort tekstfelt Stort tekstfelt benyttes når brukeren skal fylle inn en lengre beskrivelse. De samme retningslinjene som inputfelt gjelder.\nEksempel på bruk: \r Adresse For adresse finnes det et fast oppsett der postnr og poststed er sidestilt under datofeltet. Postfelt fylles ut automatisk basert på postnr-input.\nEksempel på bruk: \r Datovelger I forbindelse med planlegging, eller for datoer i nærliggende tid kan du bruke datovelgeren.\nRetningslinjer:  Dersom du skal hente inn en fødselsdato eller andre datoer lengre tilbake i tid, er ikke datovelgeren et anbefalt alternativ, se studier fra gov.uk I disse tilfellene kan du heller bruke datofeltet. Legg til korrekt validering og gi brukeren informasjon om hva som er gyldige datoer å velge. Skal brukeren kunne velge datoer tilbake i tid? Innenfor en gitt periode?  Eksempel på bruk: \r Datofelt For datoer lengre tilbake i tid, eller datoer brukeren kjenner godt, bør datofelt benyttes. Tre tekstfelt er i disse tilfellene den enkleste måten for brukeren å fylle ut datoen. Dersom det er noe som skal planlegges eller tilfeller der en spesifikk dag er viktig, bruk datovelgeren i stedet.\n⚠️ Denne komponenten er ikke tilgjengelig i Altinn Studio enda.\n\r\rRetningslinjer:  Bruk alltid label på hver av de tre boksene (dag, måned, år), og ledetekst (legend) for hele input-gruppen. Om datagrunnlaget finnes, kan en spesifikk dato være foreslått i feltet. Ellers kan eksempelinnholdet være dagen i dag.  Eksempel på bruk: \r Avkrysningsbokser Avkrysningsbokser brukes i tilfeller der brukeren kan huke av ett eller flere alternativer fra en liste. Dersom brukeren kun kan velge et av alternativene, bruk radioknapper i stedet.\nRetningslinjer:  Avkrysningsboksene skal stå foran tilhørende tekst, og skal aldri stå alene. Deaktiverte avkrysningsbokser bør unngås. Dersom et valg ikke er tilgjengelig bør det heller fjernes og forklares i tekst hvorfor det mangler.  Eksempel på bruk: \r Radioknapper Radioknapper brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder nedtrekksliste, så vær bevisst på når du bruker hvilken.\nRadioknapper velges når:\n Du ikke har for mange valgalternativer (Maks 7) Det ikke er et tydelig anbefalt valg Når brukeren enkelt skal kunne sammenligne alternativene Du ønsker at brukeren skal lese alle alternativene Valgalternativene er ukjent for brukeren  Retningslinjer:  Radioknapper skal stå foran tilhørende tekst, og skal aldri stå alene. Deaktiverte radioknapper bør unngås. Dersom et valg ikke er tilgjengelig bør det heller fjernes og forklares i tekst hvorfor det mangler.  Eksempel på bruk: \r Nedtrekksliste Nedtrekksliste brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder radioknapper, så vær bevisst på når du bruker hvilken.\nNedtrekksliste velges når:\n Du har mange alternativer (mer enn 5) Du har et anbefalt valg som vises som forhåndsvalgt Det ikke er så viktig for brukeren å kunne sammlenligne alternativene Du ønsker ikke at brukeren skal trenge å lese alle alternativene Valgalternativene er kjent for brukeren  Eksempel på bruk: \r Hjelpetekst Hjelpetekster er små tekstsnutter som kan benyttes for å gi brukeren ekstra veiledning i utfylling av skjemafelter. Man kan også benytte feltet til å forklare et regelverk, fremmede begreper, eller utdype hvorfor man ber om informasjonen.\nRetningslinjer:  Hjelpetekst plasseres i sammenheng med en label eller tittel som skal utdypes. Dersom innholdet er avgjørende informasjon for at brukeren skal kunne fylle ut skjemaet riktig, bør det heller plasseres i en infotekst i grensesnittet (under labelen).  Eksempel på bruk: \rFeilmeldinger Vær kort og tydelig i formuleringen av feilmeldingene og sørg for at brukeren vet hva som må gjøres for å komme videre. Å skrive \u0026ldquo;Feltet er påkrevd\u0026rdquo; gir ikke brukeren en forklaring på hva som er feil.\nEksempel på forklarende feilmeldinger:  \u0026ldquo;Postnummer må ha 4 siffer\u0026rdquo; \u0026ldquo;Du må velge minst ett leveringsalternativ\u0026rdquo; \u0026ldquo;For å sende inn skjemaet må du bekrefte at navnet er korrekt ved å huke av i avkrysningsboksen\u0026rdquo;  Les mer om å formidle feil i skjema på UU-tilsynets nettsider.\nRetningslinjer:  Feilmeldingstekst bør gjenta nøkkelord fra label Kravene for å fylle ut skjemaet riktig skal tydelig fremgå av skjemaet uten at brukeren trenger å få noen feilmeldinger fra valideringen for å forstå dette. Dersom skjemaet har feil når brukeren forsøker å gå videre, skal feilmeldingsboksen i toppen vise alle feilene og lenke til de feltene feilen gjelder. Feilene skal forsvinne etterhvert som de blir utbedret. ⚠️ NB: Denne funksjonaliteten er ikke tilgjengelig i Altinn Studio enda.  Eksempel på bruk: \r Filopplasting Du bør ikke be brukeren laste opp vedlegg med mindre det faktisk har en avgjørende betydning for tjenesten. Sjekk først om informasjonen kan hentes inn på annet vis, kanskje gjennom API?\nRetningslinjer:  Vær så fleksibel som mulig i forhold til hvilke filtyper som kan lastes opp. Ikke alle har kompetanse til å endre filtypeformat eller komprimere filer. Dersom det er feil i opplastingen, vær så spesifikk som mulig i feilmeldingen. Å si at “formatet ikke er godkjent” holder ikke, det må spesifiseres nøyaktig hva som kreves. Har du behov for at brukeren laster opp vedlegg av ulike typer/kategorier, anbefaler vi å bruke flere steg med en filopplaster i hvert steg. Spesifiser i innledningen på hver side hva som skal legges ved, slik at brukeren ikke blir i tvil.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/",
	"title": "Altinn 3 API",
	"tags": ["translate-to-norwegian"],
	"description": "Beskrivelse av Altinn API for sluttbrukere og applikasjonseiere.",
	"content": "The APIs The new solution will have multiple APIs, but they can be divided in two groups. The app APIs and the Platform APIs.\nApplication API The application API is an API that provides access to specific instances of a specific app. The API provides features for working with data elements while keeping the metadata document for the instance and its data elements updated. The instance level endpoints revolves around moving an instance through its defined process and controlling some instance level settings.\nMetadata for an app is the second job of the app API. There are endpoint that give access to the metadata of the app itself, its data types and process description.\nEvery app will expose almost identical endpoints and functionality. External parties should need only one client implementation across all app APIs. Technically there is nothing preventing an application owner from adding or making changes to the API, but in those cases it is probably an application with a different process flow. In these cases, the application might require some special handling, and additional documentation should be provided by the application owner.\nhttps://{org}.apps.altinn.no/{org}/{appname} The URL identifies the application owner specific hostname using the short name org, and the identificator of the app consisting of both the application owner short name and the name of the app org/appname.\nPlatform API The Platform APIs are primarily made to support the applications hosted on the platform, but a lot of endpoints can be used directly by both application owners and users. Primarily on the Authentication, Events and Storage APIs.\nThe Storage API provides access to all instances across all applications. It can be used to access metadata about applications, instances, data elements and instance activitylog (events), as well as the actual data content. This API should be the preferred method for application owners to download data associated with instances created based on their applications. Application users can use it if they need a form of message box or want to retrieve archived instances and their data.\nThe Authentication API provides methods for authentication.\nThe Events API provides access to the Events component endpoint for listing events. This can be used sporadically to query Altinn for events that have occured in the solution.\nhttps://platform.altinn.no API user groups There are primarily two groups of users of the Altinn APIs. The first group consists of applications and systems used by the owners of the Apps hosted by Altinn. This group is called Application Owners. The second group consists of organisations and people using the Apps to communicate with the application owners. This group is called Application Users.\nThe two groups have many similar needs, but there are some differences in what type of tasks they need to perform. All new APIs is technically available to both groups, but some endpoints have authorization to allow only on of the groups.\nApplication Owners A list of common tasks for an application owner:\n Query instances for a given application according to status or instance owners. Create an application instance. Upload form data and attachments. Download form data. Change process state (workflow). Confirm instance as complete.  Application Users A list of common tasks for an application user:\n Query instances for themselves or a party they can represent (instance owner). Create an application instance. Upload form data and attachments. Download form data. Change process state (workflow). View status of an instance.  \rApp APIer\rStandard API som eksponeres av apper i Altinn 3.\n\r\rPlatform APIer\rAPIer i Altinn Platform.\n\r\rAutentisering\rBeskrivelse av hvordan systemer og tjenesteeiere kan benytte Maskinporten eller ID-porten for å få tilgang til APIer i Altinn 3.\n\r\rScenarier\rForskjellige API-bruksscenarier.\n\r\rModeller\rDette er en oversikt over de fleste modellene brukt av de forskjellige APIen. Den forklarer ikke hver eneste property i alle modeller, men vil forsøke å gi en solid introduksjon til de viktigste delene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/app-metadata/",
	"title": "App metadata",
	"tags": ["api", "translate-to-norwegian"],
	"description": "The application metadata document holds technical information about the app and the data type requirements.",
	"content": "Application The Application model is the main model for metadata for the application.\n   Name Description     id A gobally unique id for the application. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the short name of the application owner and the second part is the name of the app.   versionId The current version of the application. (Currently not in use.)   org The short name of the application owner.   title A collection of the application title in different languages.   validFrom The date and time from when the application can be used to create instances.   validTo The data and time for when the application will expire and can no longer be used to create new instances.   processId The id of the process model being used by the application. (Currently not in use.)   dataTypes A list of all the data types associated with the application. See DataType.   partyTypesAllowed A collection of flags that controls what type of instance owners new instances can be created for. See PartyTypesAllowed   autoDeleteOnProcessEnd A value indicating whether an instance will be automatically deleted once the process ends. This can be used by highly sensitiv applications to force an instance delete instead of sending the instance to the archive.   presentationFields A collection of presentation fields. See PresentationField. Currently not in use.   dataFields A collection of data fields. See DataField.   eFormidling The configuration for the eFormidling integration for the application. See eFormidlingContract.    DataType Data type represents the requirements for data elements. Data types representing a form will have model validation in addition to the requirements defined here.\n   Name Description     id The id of the data type. Unique for the app.   description A collection of data type descriptions in different languages.   allowedContentTypes A list of Content-Types allowed by the data type.   allowedContributers A list of allowed contributors. This can be used to restrict who it is that can work with the data type.   appLogic A complex object with information on how a data type is connected to a model. See ApplicationLogic.   taskId A reference to a task from the application process. The value indicate that the data type requirements must be fulfilled before the process can move on from the given step in the process.   maxSize The maximum allowed size of the data element.   maxCount The maximum number of data elements of this type.   minCount The minimum required number of elements of this type.   grouping The name of a group. This can be used to logically associate a data type to a group. E.g Photos or a text resource key.    ApplicationLogic ApplicationLogic holds information about how a data type representing a form is connected to a model.\n   Name Description     autoCreate A value indicating whether a data element will be automatically created once an instance moves into the process step indicated by taskId.   classRef The name of the C# class used to represent the form as a model in application logic.   schemaRef A reference to the original schema used to define the model.    PartyTypesAllowed PartyTypesAllowed contains a set of values indicating the type of owners an instance can have.\n   Name Description     bankruptcyEstate A value indicating that the instance owner can be a bancruptcy estate.   organisation A value indicating that the instance owner can be any organisation.   person A value indicating that the instance owner can be a person.   subUnit A value indicating that the instance owner can be a sub unit.    PresentationField This type is used by a feature still in development.\nPresentationField represents a form field extraction rule. Every time a form is being saved the presentation field rules will be applied and any values from the form will be stored directly on the instance. This can later be used to present instance specific data in places like the portal message box. The purpose is to make it easier to identify a specific instance in a list with many almost identical instances.\n   Name Description     id An id or key to identify the specific rule.   path A path to a specific field or property in the form model.   dataTypeId The name of the datatype. See DataType.    DataField DataField represents a form field extraction rule. Every time a form is being saved the data field rules will be applied and any values from the form will be stored directly on the instance. While PresentationField will have logic applied to it with regards to where and how it\u0026rsquo;s used, the use of data fields is entirely up to the application developer and the application owner. One usage scenario is to provide data fields which can be used for routing to the correct backend system.\n   Name Description     id An id or key to identify the specific rule.   path A path to a specific field or property in the form model.   dataTypeId The name of the datatype. See DataType.    eFormidlingContract This type is used by a feature still in development.\neFormidlingContract holds the configuration of the eFormidling integration for the application. An application configured to enable eFormidling integration in combination with the eFormidiling contract will send a shipment to eFormidling for every instance that is created.\n   Name Description     serviceId The service identifier of the process   process The process type to be set on the shipment   receiver The receiver of the eFormidling shipment.   sendAfterTaskId The id of the last task to be completed before the shipment is sent   type The document type of the shipment e.g. arkivmelding   typeVersion The version of the document type   standard The document standard e.g. urn:no:difi:arkivmelding:xsd::arkivmelding   securityLevel The security level to be set on the standard business document   dataTypes A list of the dataTypes to be included in the shipment. Data type for both form data and attachments should be listed to be included in the shipment    Complete example This is a complete app metadata document with data types.\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/bli-applikasjonseier\u0026#34;, \u0026#34;versionId\u0026#34;: null, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Bli applikasjonseier\u0026#34; }, \u0026#34;validFrom\u0026#34;: null, \u0026#34;validTo\u0026#34;: null, \u0026#34;processId\u0026#34;: null, \u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;allowedContributers\u0026#34;: null, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.BliTjenesteeier_M\u0026#34;, \u0026#34;schemaRef\u0026#34;: null }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: null, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;grouping\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;allowedContributers\u0026#34;: null, \u0026#34;appLogic\u0026#34;: null, \u0026#34;taskId\u0026#34;: null, \u0026#34;maxSize\u0026#34;: null, \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0, \u0026#34;grouping\u0026#34;: null } ], \u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: true, \u0026#34;organisation\u0026#34;: true, \u0026#34;person\u0026#34;: true, \u0026#34;subUnit\u0026#34;: true }, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: false, \u0026#34;created\u0026#34;: \u0026#34;2020-07-17T08:26:21.5707559Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;sandgrainone\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-07-17T08:26:21.5708691Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;sandgrainone\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/",
	"title": "Endringslogg for app nuget pakker",
	"tags": [],
	"description": "Oversikt over endringer introdusert i App Nuget-pakker.",
	"content": "\rv4\rOversikt over endringer introdusert i v4 av Altinn.App.* pakkene.\n\r\rv3\rOversikt over endringer som ble introdusert i v3 av Altinn.App.* pakkene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/",
	"title": "App brukergrensesnitt",
	"tags": [],
	"description": "Konfigurering av komponenter, layouts, sider, grid, etc.",
	"content": "\r\rSider\rHvordan sette opp en app med flere sider, sporvalg, oppsummering eller flere skjema.\n\r\rFelter\rHvordan sette opp felter og gruppering.\n\r\rStyling\rHvordan styre styling, formattering og grid-layout for en app.\n\r\rTekster\rHvordan editere og formatere tekster, bruke variabler og legge til hjelpetekster.\n\r\rPDF\rHvordan konfigurere generering av PDF.\n\r\rWidgets\rHvordan bruke sammensatte komponenter (widgets).\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/",
	"title": "Design og planlegging",
	"tags": [],
	"description": "For at tjenesten din skal bli best mulig for de som skal bruke den, er det viktig å starte med å fokusere på brukerne og forstå deres brukerbehov i møte med tjenesten din.",
	"content": "Før du begynner utviklingen av tjenesten/applikasjonen din, anbefaler vi å gjennomføre en innsiktsfase, lage en prototype og utføre en brukertest.\n\rInnsiktsfase\rFørst av alt bør du samle prosjektgruppen og starte med å definere problemet. Hva er det dere skal løse og hvem skal det løses for?\n\r\rPrototype\rVed hjelp av Altinns Prototype-kit kan du lage en klikkbar prototype for å definere flyt og innhold i din tjeneste.\n\r\rBrukertest\rDet er alltid lurt å brukerteste i flere faser av prosjektet. Gjennom brukertester måler du om det du lager treffer brukernes behov. Det er en god investering å gjøre dette tidlig i prosjektet, slik at du ikke bruker penger på å utvikle en løsning som ikke løser utfordringene.\n\r\rRetningslinjer\rVi ønsker å oppnå helhetlige og konsistente brukeropplevelser ved å bruke gjenkjennbare og godt testede komponenter. For å oppnå dette ut i tjenestene, ber vi deg om å benytte retningslinjene på disse sidene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/",
	"title": "Endringslogg",
	"tags": [],
	"description": "Oversikt over endringer introdusert i Altinn 3.",
	"content": "\rEndringslogg for app frontend\rOversikt over endringer introdusert i app frontend.\n\r\rEndringslogg for app nuget pakker\rOversikt over endringer introdusert i App Nuget-pakker.\n\r\rEndringslogg for deployment\rOversikt over endringer introdusert i helm-chart for deployment.\n\r\rStorage Interface endringslogg\rOversikt over endringer introdusert i Altinn.Platform.Storage.Interface NuGet package.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/",
	"title": "Felter",
	"tags": [],
	"description": "Hvordan sette opp felter og gruppering.",
	"content": "\rGruppering av felter\rHvordan gruppere felter i skjema.\n\r\rInnstillinger for felt\rInnstillinger for tekster knyttet til et felt.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/tracks/",
	"title": "Sporvalg",
	"tags": [],
	"description": "Hvordan legge til dynamisk sporvalg i app",
	"content": "Dynamisk sporvalg i en applikasjon kan være nyttig dersom man ønsker å vise og/eller skjule enkelte sider basert input fra sluttbruker på forutgående deler av skjemaet.\nTrigge kalkulering av sporvalg fra frontend Appen vil gjøre et initielt kall for å kalkulere rekkefølgen ved innlasting. For å trigge kalkuleringingen av sporvalg på sidebytte må man legge inn dette som en trigger på den aktuelle navigasjons-komponenten man ønsker. Dette gjøres ved å legge til calculatePageOrder som en del av triggers. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;navigation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;Neste\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;Tilbake\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;calculatePageOrder\u0026#34;], \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;showBackButton\u0026#34;: true } Her vil frontend da gjøre kallet mot apiet definert i appen og benytte listen som returneres til å avgjøre hvilke side den går til i det brukeren trykker neste. Denne rekkefølgen blir også lagret i staten frontend slik at navigering vil fungere både frem og tilbake på den gitte rekkefølgen man returnerer fra backend.\nOm man ønsker å trigge kalkulering på hvert eneste sidebytte kan dette gjøres ved å enten legge inn calculatePageOrder som en del av triggers for alle navigasjonskomponentene man har i applikasjonen, eller legge til en trigger i Settings.json under pages-seksjonen. Eksempel:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [ \u0026#34;Side1\u0026#34;, \u0026#34;Side2\u0026#34;, \u0026#34;Side3\u0026#34; ], \u0026#34;triggers\u0026#34;: [\u0026#34;calculatePageOrder\u0026#34;] } } Om triggers er satt på navigasjonskomponenten vil denne overstyre triggers som settes i Settings.json, på denne måten er det mulig å styre default-oppførsel på komponentnivå om ønskelig.\nSette opp sporvalg backend I App.cs må man overstyre metoden som henter ut den standardrekkefølgen av sider som er definert i Settings.json Dette gjøres ved å legge til funksjonen nedenfor i App.cs. Forventet output fra denne metoden er en stortert liste som inneholder navnet på de relevante sidene i applikasjonen.\n/// \u0026lt;inheritdoc /\u0026gt; public override async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(string org, string app, int instanceOwnerId, Guid instanceGuid, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); // Implement your own logic here  return pageOrder; } Funksjonen får inn en rekke parametere som kan være nyttig dersom man skal benytte skjemadata eller annen informasjon om sluttbruker til å kalkulere sporvalget.\n layoutSetId Dersom appen din definerer flere layout set vil id på det gjeldende layout settet sendes inn. Dersom applikasjonen ikke har layout set vil denne strengen være tom. Basert på denne parameteren kan man hente ut standard siderekkefølge som er definert i applikasjonen:  List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResources.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResources.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } Dette forutsetter at servicen IAppResources gjøres tilgjengelig i App.cs. Da servicen allerede dependency injectes inn i klasen er det kun to steg som kreves.\n Opprett en privat variabel i staten av klassen.  private readonly IAppResources _appResources; Definer den nye private variabelen lik servicen som sendes med i konstruktøren til App.cs  _appResources = appResourcesService;   CurrentPage Siden man ønsker å navigere fra vil være spesifisert i denne parameteren.\n  FormData inneholder skjemadataen. Den kan enkelt jobbes med som et objekt ved å caste den til riktig type Skjema skjema = (Skjema)formData;. Her heter C# modellen til skjemadataen Skjema for din applikasjon kan det være et annet navn. Dette kan du sjekke ved å finne klassenavnet på C# filen i App/models-mappen.\n  Reflektere sporvalg i kvittering (PDF) Som applikasjonsutvikler må man selv sørge for å reflektere de sporvalgene som gjøres i PDFen som opprettes i slutten av hver task. I App.cs finnes funksjonen FormatPdf:\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } Som input til metoden får man layoutSettings som inneholder default siderekkefølge under propertyen layoutSettings.Pages.Order. I tillegg får man skjemadataen som er knyttet til steget som skal avsluttes. Denne kan parses til en C# modell som beskrevet lengere oppe på denne siden.\nVed å manipulere layoutSettings.Pages.Order i denne metoden vil man kunne duplisere de sporvalgene som er gjort for sluttbruker. MERK! Kallet til PDF handler, vist nedenfor, må ikke fjernes fra FormatPDF metoden dersom du har implementert ytterlig logikk for kvitteringen i PDFHandler.cs.\nreturn await _pdfHandler.FormatPdf(layoutSettings, data); For å unngå å duplisere logikk vil vi anbefale å lage en privat metode som manipulerer siderekkefølgen basert på skjemadata og kalle denne både fra FormatPdfog GetPageOrder. Et kodeeksempel på en slik implementasjon følger.\npublic override async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(string org, string app, int instanceOwnerId, Guid instanceGuid, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResourcesService.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResourcesService.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } UpdatePageOrder(pageOrder, (FavorittArtist)formData); return pageOrder; } public override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { UpdatePageOrder(layoutSettings.Pages.Order, (FavorittArtist)data); return await _pdfHandler.FormatPdf(layoutSettings, data); } private void UpdatePageOrder(List\u0026lt;string\u0026gt; pageOrder, FavorittArtist formdata) { if (formdata.EnGodNrTo.Contains(\u0026#34;Tix\u0026#34;)) { pageOrder.Remove(\u0026#34;Prince\u0026#34;); } else { pageOrder.Remove(\u0026#34;Tix\u0026#34;); } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/content/",
	"title": "Språk",
	"tags": [],
	"description": "Retningslinjene skal sørge for at vi får et ensrettet språk og forståelig innhold i tjenestene som lages i Altinn.",
	"content": "Som hovedregel bør du bruke retningslinjene fra Språkrådet når du skriver. I tillegg har vi definert noen mer spesifikke regler for Altinn som vi anbefaler at du følger.\nVi oppfordrer til at du skriver innholdet i tjenestene dine på både bokmål, nynorsk og engelsk.\nGenerelle anbefalinger  Bruk et muntlig og lett språk Skriv direkte til brukeren (bruk «du») Forklar hva som er neste steg Skriv kort, klart og klikkbart Skriv tekster som kan skummes Vær spesifikk om innholdet, men sørg samtidig for å bruke ord som alle kan forstå  Unngå:  lange ord lange setninger kryptiske eller lyriske overskrifter flere poenger i samme setning flere poenger i samme avsnitt VERSALER (store bokstaver)  Lengde på tekst:  overskrifter: maks. 8 ord setninger: 15-20 ord avsnitt: 40-80 ord  Skriv rett frem Formelt språk er ofte skrudd sammen slik at utsagnet (verbet) kommer sent i setningen. Det gjør at man må lese mange ord før man får verbet. Det krever mer av leseren som må huske hva som stod tidlig i setningen. Verbet bør stå så tidlig som mulig i setningen og bør stå så nært subjektet som mulig.\nEksempel:\nArbeidstaker har en del plikter som må oppfylles →\nArbeidstaker må oppfylle en del plikter\nUnngå verbalsubstantiver Verbalsubstantiver gjør teksten unødvendig tung å lese. Et verbalsubstantiv er et substantiv dannet av et verb, for eksempel at «å utrede» blir til «å foreta en utredning», der utredning er selve verbalsubstantivet. De fleste verbalsubstantiv slutter på «-ing» og «-else».\nEn tekst med mange verbalsubstantiver blir abstrakt fordi den fjerner seg fra de konkrete handlingene den egentlig beskriver. Teksten blir mer konkret når vi bruker verbene i stedet.\nEksempler:\n Ved avtaleinngåelsen → Da avtalen ble inngått Ny henvendelse → Kontakt oss Innmelding av feil → Meld inn feil  Skriv aktivt, ikke passivt: I lovspråk blir det ofte skrevet at noe skal gjøres og det er ikke ønskelig å si noe om hvem som skal gjøre det. I Altinn sine løsninger vil det gjerne være flere enn en person som skal gjøre noe, men vi kan skrive direkte til brukeren likevel.\nEksempel:\nForberedelser og planleggingsaktiviteter må gjennomføres før utviklingen av tjenesten(e) kan og bør starte →\nGjør forberedelser og planlegg godt før du utvikler tjenesten.\nOppdeling av tall Riktig og konsekvent oppdeling av tallene hjelper brukeren å lese og skille forskjellige typer nummer. Ingen av nummerne skal skilles med punktum, kun mellomrom. I felt hvor brukeren skal skrive inn lengre nummer er det hjelpsomt å indikere antall siffer.\n Organisasjonsnummer deles opp i tre og tre: 123 456 789 Bankkonto deles opp i fire, to og fem: 1234 56 78901 Personnummer deles opp i seks og fem: 123456 78901 Mobilnummer deles opp i tre, to og tre: 987 65 432 Fasttelefon og faks deles opp i to og to: 98 76 54 32  Tid og dato  Klokkeslett skriver vi kun med timer og minutter, aldri sekunder. Klokkeslett skrives slik: 13:45 Dato skal som hovedregel skrives slik: 05.06.2017 Unntaksvis kan datoer skrives slik i løpende tekst: 5. juni 2017  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/",
	"title": "App APIer",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Standard API som eksponeres av apper i Altinn 3.",
	"content": "Overview The features documented here are the default features of any app created based on the app template in Altinn Studio. Application owners are free to make changes to this, but it is probably safe to say that removal of features will be extremly rare. Any app with changes to its API should have its own documentation published by the application owner.\nAll app API endpoints have the same URL base path that will vary based on application owner and application name.\nTest environment (TT02)\nhttps://{org}.apps.tt02.altinn.no/{org}/{appname} Production\nhttps://{org}.apps.altinn.no/{org}/{appname} The URL identifies the application owner specific hostname using the short name org, and the identificator of the app consisting of both the application owner short name and the name of the app; org/appname.\n\rApp metadata\rApp API for å få metadata informasjon for appen.\n\r\rInstanser\rApp API å jobbe med forekomster av en app.\n\r\rData-elementer\rAPI å jobbe med dataelementene knyttet til en app instans.\n\r\rTilstandsløse data\rAPI til å arbeide med dateelementer uten tilstand som ikke er knyttet til en instans.\n\r\rProsess\rAPI endepunkter for å lede en instans gjennom prosessen som er definert.\n\r\rValidering\rValidering API-endepunktene for instanser og dataelementer.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/",
	"title": "Bidra til utviklingen av Altinn",
	"tags": [],
	"description": "Hvordan DU kan bidra til at Altinn blir en så bra løsning som mulig.",
	"content": "\r\rIntro for utviklere\rIntroduksjon\n\r\rUtviklingshåndbok\rUtviklingshåndbok for bidrag til kodebasen i Altinn.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/",
	"title": "Community",
	"tags": [],
	"description": "Vi bygger Altinn i lag med mange andre, helt åpent.",
	"content": "\rAltinn på GitHub\r\nVi ønsker at det skal være så enkelt som mulig for alle å bidra med sine endringer - derfor kan du finne våre løsninger på GitHub.\rVi setter veldig stor pris på dine kommentarer eller bidrag!\r\r\r\rOm Altinn 3\rAltinn 3 er tredje generasjon plattform for å utvikle og kjøre digitale tjenester.\n\r\rEndringslogg\rOversikt over endringer introdusert i Altinn 3.\n\r\rBidra til utviklingen av Altinn\rHvordan DU kan bidra til at Altinn blir en så bra løsning som mulig.\n\r\rRoadmap for Altinn\rHøynivå roadmap og funksjonell beskrivelse for Altinn.\n\r\rPresentasjoner og Altinn kaffe\rThe Altinn-kaffe meeting series is a low threshold meeting series, where app owners (and potential app owners) can learn more about what we\u0026#39;re doing in Altinn 3. It\u0026#39;s also designed to gather information on how Altinn can help app owners realise their Altinn 3 potential. Slides mainly in Norwegian.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/",
	"title": "Logikk",
	"tags": [],
	"description": "Hvordan legge til, endre og konfigurere applikasjonslogikk som validering, kalkulering og dynamikk.",
	"content": "\rGenerelt\rOversikt over logikkfiler og hvordan de kan brukes.\n\r\rDataprosessering\rHvordan legge til kalkuleringer og annen dataprosessering?\n\r\rDynamikk\rHvordan legge til dynamikk?\n\r\rInstansiering\rHvordan legge til logikk som skal kjøres ved instansiering?\n\r\rKalkuleringer\rHvordan legge til kalkuleringer?\n\r\rValidering\rHvordan legge til logikk for å validere skjemadata?\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/metadata/",
	"title": "App metadata",
	"tags": ["api", "translate-to-norwegian"],
	"description": "App API for å få metadata informasjon for appen.",
	"content": "Overview The endpoints documented here are all for accessing metadata on the app itself and the data types that are allowed in an instance of the app. Additional endpoints provides access to text resources.\nGet app metadata Endpoint for downloading a copy of the application metadata document.\nGET {basePath}/api/v1/applicationmetadata Get Application texts Get text resources for the application for a specific language code. If the requested language isn\u0026rsquo;t available, norsk bokmål (nb) will be returned as default. The langaugeCode URL path element should follow the ISO 639-1 standard\nGET {basePath}/api/v1/texts/{languageCode} Note that the texts are cached in Platform Storage for 60 minutes before being retrieved from the database again.\nGet model JSON schema Download the JSON schema for a specific model. The id parameter must have the name of a JSON Schema in the app. This is usually a generated name based on values in the original XSD uploaded on the app. E.g: Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\nGET {basePath}/api/jsonschema/{id} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/summary/",
	"title": "Oppsummeringsvisning",
	"tags": [],
	"description": "Hvordan sette opp visning av oppsummering av utfylt skjema.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\rMERK: PDF-genereringen har per nå ikke støtte for oppsummerings-komponenten. For at PDF-generering skal fungere må enten alle oppsummerings-komponentene, eller hele oppsummerings-siden(e) ekskluderes fra PDF. Dette gjøres i Settings.json-filen knyttet til layout-filene.\n\rOppsett Visning av oppsummering settes opp på samme måte som øvrige skjema-komponenter i et skjema. Man kan velge å ha oppsummeringen på en egen side, eller på samme side som andre skjema-komponenter.\nOppsummerings-komponenten er meget enkel, og refererer til komponent som skal oppsummeres, og siden denne ligger på. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;\u0026lt;komponent-id\u0026gt;\u0026#34;,  \u0026#34;pageRef\u0026#34;: \u0026#34;\u0026lt;side komponenten er definert på\u0026gt;\u0026#34; }, Komponenten viser oppsummering av data fra den spesifiserte komponenten. I tillegg får sluttbruker mulighet til å gå tilbake til den aktuelle komponenten/siden for å gjøre endringer.\nVisningen er litt forskjellig avhengig av hva slags skjemakomponent oppsummeringen refererer til.\nMerk: PDF-generering støtter ikke oppsummering side, så må den ekskluderes ved å endre layout/ui/Settings.json\n\u0026#34;pages\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [ \u0026#34;navn-til-oppsummering-side\u0026#34; ] } Enkel skjemakomponent Dette er skjemakomponenter som kun er knyttet til 1 felt i datamodellen. F.eks. Input, Dropdown, Checkbox/Radio, osv.\nOppsummeringen viser ledeteksten til skjemakomponenten, og tilknyttet data. Dersom det er en aktiv feilmelding knyttet til skjemakomponenten, vil dette også vises.\nAdressekomponent Denne komponenten har flere felter som inngår. Visningen er lik som for en enkel skjemakomponent, slik at feltene blir slått sammen til en enkel tekst.\nFilvedlegg Oppsummeringsvisningen for filvedlegg viser en liste over de vedleggene som er lastet opp for den aktuelle komponenten.\nRepeterende grupper Grupper i grupper Oppsummering støttes også for repeterende grupper inne i repeterende grupper. Vi støtter kun ett nivå av grupper i grupper. I dette tilfellet vises oppsummeringen av hvert innslag av gruppen på øverst nivå som en egen kategori, og gruppen på nederste nivå vises på samme måte som vanlige repeterende grupper. Kategorier Det er mulig å gruppere oppsummeringene i forskjellige kategorier, for å gjøre en ev. oppsummeringsside mer oversiktlig. Dette gjøres ved å bruke den eksisterende gruppe-komponenten, uten å sette den opp som en repeterende gruppe.\nFeltene i oppsummeringen vises da med en tittel, som settes i title-feltet for textResourceBindings for gruppe-komponenten. Se eksempel under.\n{ \u0026#34;id\u0026#34;: \u0026#34;personalia-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Personalia\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-1\u0026#34;, \u0026#34;summary-2\u0026#34;, \u0026#34;summary-3\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d566c79c-3e3e-445b-be25-a404508f6607\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;22a60bf0-d5b7-4b45-9ac9-c266b6ad3716\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d497737b-67b2-4e03-87a9-43f58579c938\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, Eksempel på oppsummeringsside Under er et eksempel på en oppsummeringsside, med oppsett i layout-filen. Da oppsummeringen settes opp i layout-filene på samme måte som andre komponenter, kan man også ha med andre skjemakomponenter som tekster ved behov.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layout.schema.v1.json\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;send-in-text\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;componentType\u0026#34;: 1, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;finish\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;personalia-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Personalia\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-1\u0026#34;, \u0026#34;summary-2\u0026#34;, \u0026#34;summary-3\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d566c79c-3e3e-445b-be25-a404508f6607\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;22a60bf0-d5b7-4b45-9ac9-c266b6ad3716\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d497737b-67b2-4e03-87a9-43f58579c938\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;drugs-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Rus- og dopingmidler\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-4\u0026#34;, \u0026#34;summary-5\u0026#34;, \u0026#34;summary-6\u0026#34;, \u0026#34;summary-7\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;064c0033-8996-4825-85fc-2a19fe654400\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-5\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;7f22e523-3f6d-4371-a5dd-233dc41af824\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-6\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;18a7c709-ae2f-48b3-b6f6-bd631f5d8d56\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-7\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;b7417cf9-f806-4835-a3d1-424c8d094d5f\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-group-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;arbeidserfaring-group\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;work\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-8\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;25f720db-5784-4c95-a530-43f0bf523466\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;attachment\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;312afa87-c2a9-4ef1-a681-26cc47462878\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/",
	"title": "Retningslinjer",
	"tags": [],
	"description": "Vi ønsker å oppnå helhetlige og konsistente brukeropplevelser ved å bruke gjenkjennbare og godt testede komponenter. For å oppnå dette ut i tjenestene, ber vi deg om å benytte retningslinjene på disse sidene.",
	"content": "\r\rDesign\rAltinn har som mål å gjøre det enklere for innbyggere og næringsliv å være i kontakt med det offentlige uavhengig av digital kompetanse. Felles retningslinjer for design hjelper oss å skape konsistens på tvers av tjenester som lages i Altinn Studio.\n\r\rUI-komponenter\rDe ulike komponentene er laget for at de skal passe sammen i en større helhet. Det er derfor viktig å følge retningslinjene for hvordan disse brukes for å oppnå et konsistent og gjenkjennbart uttrykk. UI-komponenter som foreløpig inngår i Altinns bibliotek finner du her.\n\r\rSpråk\rRetningslinjene skal sørge for at vi får et ensrettet språk og forståelig innhold i tjenestene som lages i Altinn.\n\r\rTilgjengelighet\rGod tilgjengelighet hjelper mennesker med funksjonshemninger å oppfatte innholdet vårt på en meningsfull måte. Ved å bruke Altinn 3 får du mye på kjøpet, men noen ting må du fortsatt huske på selv.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/styling/",
	"title": "Styling",
	"tags": [],
	"description": "Hvordan styre styling, formattering og grid-layout for en app.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\nMERK: for å benytte denne funksjonaliteten må man ha app-frontend versjon 3. Se denne lenken om endringer som må til i appen.\n\rSidestilte komponenter (grid) Det er mulig å sidestille komponenter i skjema. Denne funksjonaliteten baserer seg på grid systemet til Material-UI, og vil også være kjent om man er kjent med grid-systemet til boostrap. Grid systemet baserer seg på en oppbygning av containere i 12 deler, hvor man så kan tildele barn (items) av en grid-container en gitt andel av denne bredden. Material-UI tilbyr også muligheten til å dynamisk endre hvor stor andel av skjermen man ønsker å oppta basert på hvilken skjermstørrelse sluttbrukeren har. Følgende størrelser med tilhørende breakpoints er definert:\n xs: 0px sm: 600px md: 1024px lg: 1440px xl: 1920px  For å sidestille komponenter horisontalt må man gjøre noen små endringer i formlayout. Det er definert en egen property grid som man kan fylle inn bredde ønsket på de ulik størrelsene. Her er et eksempel hvor to input-felt har blitt satt til å ta halve skjermen (enkelte props er fjernet for lesbarhet):\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 6, } }, { \u0026#34;id\u0026#34;: \u0026#34;input-felt-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 6 } } } I komponentene over er størrelsen satt til 6 (altså halv bredde) for størrelse xs. Siden xs er den minste størrelsen tilgjengelig vil dette gjelde fra størrelse xs og opp, altså fra xs til xl. Oppsettet over vil gi følgende resultat:\nSiden man har 12 inndelinger tilgjengelig i sidebredden er det opp til apputvikler å tildele hvor stor andel komponenten skal ha. Om man ønsker at en komponent skal ta 2/12, en annen 6/12 og siste 4/12 så er det mulig. Det er viktig å tenke på brukeropplevelsen når man gjør slike endringer, og sidestilling av komponenter bør gjøres med omhu. Komponenter med lengre tekster og beskrivelser blir også fort små og uoversiktelige om disse sidestilles. Skal det benyttes lengre tekster og beskrivelser anbefales det at disse benytter full bredde av skjema.\nOm man i eksemepelet over hadde ønsket at komponentene skulle ta hele bredden frem til skjermen ble større enn 960px så kunne man satt opp følgende layout:\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;sm\u0026#34;: 12, \u0026#34;md\u0026#34;: 6 } }, { \u0026#34;id\u0026#34;: \u0026#34;input-felt-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;sm\u0026#34;: 12, \u0026#34;md\u0026#34;: 6 } } } Da ville komponentene først legge seg sidestilt i det sluttbruker faktisk sitter på en skjerm som oppfyller kravet stilt.\nInnerGrid Utover det å sette bredde på grid i komponenten har vi også lagt til mulighet til å styre innerGrid. Å overstyre denne bredden vil typisk være for caser hvor man ønsker at teksten til en komponent skal oppta en større bredde enn input-feltet. Du kan tenke på komponenten på denne måten:\n\u0026lt;Grid id=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;div\u0026gt; Komponentens tekster \u0026lt;/div\u0026gt; \u0026lt;Grid id=\u0026#34;innerGrid\u0026#34;\u0026gt; Komponentens input \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; Her vil det da være mulig å styre bredden til både ytterste grid og den innerste griden. Eksempel:\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innerGrid\u0026#34;: { \u0026#34;xs\u0026#34;: 6 } } } } Her har man satt at komponent griden skal ta hele bredden, mens man begrenser komponentens input til å kun ta halve bredden. InnerGrid vil kunne styres for komponentene:\n Kort svar (Input) Langt svar (TextArea) Filopplaster (FileUpload) Nedtrekksliste (Dropdown) Datovelger (Datepicker)  Eksempelet over vil gi følgende output:\nFormattering av tall Det er nå implementert støtte for å kunne spesifisere formattering av tall i inputfelt. Dette gjøres ved å legge til en property formatting på Input-komponenten. Formatteringsmuligheter er dokumentert i et JSON-schema, og vil dukke opp automatisk i intellisense når man redigerer komponenten i f.eks. VSCode.\nEksempelet under vil resultere i et inputfelt for tall, hvor tallet vil bli formattert med , mellom hver tusen, og $ foran tallet.\nFormatteringen er kun for visning i frontend, og tallene som legges inn i et inputfelt med formattering vil lagres uformattert.\r\r{ \u0026#34;id\u0026#34;: \u0026#34;numberComponent\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;number\u0026#34;, }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;someNumberField\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: false, \u0026#34;formatting\u0026#34;: { \u0026#34;number\u0026#34;: { \u0026#34;thousandSeparator\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;$\u0026#34; }  } }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/wcag/",
	"title": "Tilgjengelighet",
	"tags": [],
	"description": "God tilgjengelighet hjelper mennesker med funksjonshemninger å oppfatte innholdet vårt på en meningsfull måte. Ved å bruke Altinn 3 får du mye på kjøpet, men noen ting må du fortsatt huske på selv.",
	"content": "Forskrift om universell utforming av IKT-løsninger stiller krav om at nettsider må oppfylle 35 av 61 suksesskriterier i standarden Retningslinjer for tilgjengelig webinnhold (WCAG) 2.0. Sjekk ut minimumskravene på UU-tilsynet som er omfattet av forskriften.\nSjekkliste  Innholdsstruktur Sjekk at du har en logisk struktur på overskrifter (H1 - H4), og at du ikke har noen tomme overskriftselementer. Det er fort gjort å glemme et nivå. For å oppdage feil i innholdstrukturen kan det være nyttig å benytte “Wave” som er et utvidelsesverktøy til chrome. Last ned Wave til Chrome, installer og ikonet vil dukke opp øverst til høyre i nettleseren.    Forklarende tekster og hjelpetekst Sjekk at lenker, label og knapper har forklarende tekster. Ta en vurdering på om ekstra beskrivelser og hjelpetekster må kobles til input elementet.\n  Knapp vs lenke Det er viktig at man er bevisst på om det blir brukt knapper eller lenker, da skjermlesere kan få problemer med å tolke funksjonaliteten.\n  Feilmeldinger Du er selv ansvarlig for at korrekte feilmeldinger blir lagt inn på hvert av skjemafeltene.\n  NB: Skal du lage tjenester i egen løsning, der Altinns grensesnitt er usynlig for brukeren, må du selv huske på å ta hensyn til øvrige WCAG-krav.\n\r\rHvordan teste Det er viktig at dere tester at tjenesten deres er tilgjengelig for alle. Dette vil ikke bare hjelpe deres tjeneste, men det kan også belyse feil som har oppstått eller blitt oversett hos oss. Her er noen verktøy som kan brukes til å gjøre enkle tester.\nTastaturnavigasjon Sjekk at alle knapper og inputfelter kan nåes ved tastaturnavigasjon.\nSkjermleser Gå gjennom flyten med en skjermleser som hjelpemiddel. Her kan du forsikre deg om at alt blir lest opp riktig og at tekstene er beskrivende nok.\n  Mac: VoiceOver er forhåndsinstallert på Apples mobiler og PCer. VoiceOver Brukerveiledning\n  Windows: NVDA Screenreader er et gratis skjermleser verktøy laget av NV Access Om NVDA Screenreader\n  Kontrast Følgende fargekombinasjoner som er brukt på Altinn oppfyller kravene til kontrast i liten tekst. AA er minstekravet, mens AAA er anbefalt, særlig for løpende tekst.\n\rAA\rAAA\rAAA\r\rAA\rAA\r\rAAA\r\rAA\rAAA\rAAA\r\rAAA\r\rAA\r\rAA\rAAA\r\rAA\rAA\rAAA\rAAA\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/",
	"title": "Endringslogg for deployment",
	"tags": [],
	"description": "Oversikt over endringer introdusert i helm-chart for deployment.",
	"content": "\rMigrering til versjonerte charts\rMigrering fra helm template filer til versjonert helm dependency.\n\r\rv1\rOversikt over endringer introdusert i v1 av deployment.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/layout-sets/",
	"title": "Flere skjema i samme app (layout-sets)",
	"tags": [],
	"description": "Hvordan sette opp en app som inneholder flere ulike skjema.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\r\rOppsett For å få funksjonalitet for flere skjema i tjeneste, må nuget-versjon til pakkene app\u0026rsquo;en bruker oppgraderes til versjon 3.1.4 eller nyere. Se instrukser for hvordan det gjøres her.\nSentralt i løsningen er at man har flere layout-sets som består av en eller flere sider og configurasjon. Hvert layout-set består av tilsvarende filer som en skjema tjenester.\n|- App/\r|- ui/\r| - layout-sets.json\r|- skjema-a/\r|- Settings.json\r|- RuleHandler.js\r|- RuleConfiguration.json\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json\r|- skjema-b/\r|- Settings.json\r|- RuleHandler.js\r|- RuleConfiguration.json\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json I layout-set.json defineres det hvilke steg i prosessen (task) hvor et gitt layout-set skal brukes. Merk at id\u0026rsquo;en er case sensitiv, så om du har stor bokstav i mappenavnet må id\u0026rsquo;en reflektere dette. Vi anbefaler små bokstaver i mappenavn.\nEksempel:\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rf0002\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;schema_4222_160523_forms_212_20160523\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_1\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;superform\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;schema_3161_140411_forms_1549_11554\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_2\u0026#34; ] } ] } "
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/instance/",
	"title": "Instance",
	"tags": ["api", "translate-to-norwegian"],
	"description": "An instance is a metadata container that is used to track the status and progress of one interaction between an app user and owner.",
	"content": "Instance The Instance model is the main model of an instance. An instance can be regarded as an envelope or folder where data is collected and exchanged between the application user and owner. The instance document is a way for Altinn and external parties to track the state of one specific data exchange.\nProperties    Name Description     id A gobally unique id for the instance. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the internal unique id of the instance owner and the second part is a generated UUID value.   instanceOwner A complex type identifying the owner of the instance. See InstanceOwner   appId The id for the app the instance is associated with. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the short name/identifier of the owner of the app and the second part is the app name.   org The short name of the app owner.   selfLinks A complex type containing a set of named URLs. See ResourceLinks   dueBefore This can be use by app owner to indicate a deadline for when the instance must be completed and submitted by a user that can represent the instance owner.   visibleAfter This can be used by app owner to have an instance become visible for app users at a given date and time. This way an instance can be created in advance and populated with data before being available to an application user.   process A complex type tracking the process state of the instance. See ProcessState   status A complex type with more state data. See InstanceStatus   completeConfirmations A list of complete confirmations. See CompleteConfirmation   data A list of data elements. This include all forms, attachments and other data types being collected. See DataElement   presentationTexts A dictionary with text values extracted from forms that are saved on the instance. Values are extracted based on PresentationField values stored in the application metadata document. Also see PresentationField   dataValues A dictionary with data values extracted from forms that are saved on the instance. Values are extracted based on configured data fields in the applicationmetadata document. Also see DataField   created The date and time when the instance was first initialized.   createdBy An idenfificator indicating who it was that created the instance.   lastChanged The date and time when the instance was last changed.   lastChangedBy An idenfificator indicating who it was that made the last change to the instance.    InstanceOwner The InstanceOwner model is a simple definition whose only porpose is to hold a universally known identification value of the instance owner.\nProperties    Name Description     partyId A value used internally by Altinn to uniquely identify an entity across Organisations, Persons and Self identified users.   personNumber If the instance owner is a person this field is populated with a person number from the National Population Register in Norway.   organisationNumber If the instance owner is an organisation this field is populated with an organisation number from the National Unit Register in Norway.    InstanceStatus The InstanceStatus model is used to hold key status related metadata about an instance. All information is also tracked through instance events, but this is an easily accessible summary of the last events.\nProperties    Name Description     archived The date and time for when an archived instance was archived.   softDeleted The date and time for when a deleted instance were moved to the recycle bin.   hardDeleted The date and time for when an instance became unrecoverable through any API. A few days later the instance and all its data will be physically deleted from storage and truly unrecoverable.   readStatus A field indicating whether an application user has opened the instance at any time. Used internally by the message box to indicate read status of elements.   substatus A property with human readable status information that will be displayed by the message box.    CompleteConfirmation The CompleteConfirmation model is a simple type for holding information about who and when a given stakeholder has told Altinn that the instance is no longer needed. They have obtained all the information they needed from the instance. The instance can be deleted permanently should an application user decide to to so. At the time of writing an instance can have only one stakeholder and that is the Application Owner.\nDataValues Data values are values either extracted from the instance data or other sources. The values are stored with the instance for easy access and can be used for example in routing logic on the receiving end.\nWhile data fields configured in the app metadata file will be extracted and automatically picked up by the application, there is also the option of adding values manually by using the UpdataDataValues method from the IInstance interface. You can mix and match data fields from configuration and by manually adding. It\u0026rsquo;s the UpdateDataValues method that is called under the hood in both cases. UpdateDataValues merges the incoming collection with what\u0026rsquo;s allready stored. However if yo specify the same id it will be overwritten by one or the other and you have no guaranties on which is stored.\nValues passed in to the UpdataDataValues can have any source and is not restricted to data stored in the application. It can be called from any place but it\u0026rsquo;s recomended to not call it more than strictly required. A good place is to override the RunProcessTaskEnd method from AppBase causing the method to be called when a task is completed.\nProperties    Name Description     stakeholderId The short name of an application owner.   confirmedOn The date and time for when the application owner confirmed that they consider the instance as no longer needed in Altinn.    ProcessState The process state model keeps track of the process of a specific instance.\nProperties    Name Description     started Date and time for when the process was initially started.   startEvent The name of the start event triggering the beginning of the process.   currentTask A complex model keeping track of current process step. See ProcessElementInfo   ended Date and time for when the process was finished.   endEvent The name of the end event that the process ended with.    ProcessElementInfo The process element info holds information about the current task in the process.\nProperties    Name Description     flow A step counter that increase every time the process moves forward.   started Date and time for when the instance entered the current step.   elementId The unique id of current process task.   name The name of the task. (Human readable.)   altinnTaskType The type of task.   validated A date and time for when the instance was validated as well as a value indicating if the task can be completed without additional changes and a new validation.    ResourceLinks The resource link model is should have a collection of URLs that can be used to obtain a copy of the instance document through different API. The propose is to make it easy to switch between API. Primarily when the original was obtain from the storage instance query API and you need to use the app API to perform changes on the instance.\nProperties    Name Description     apps Contains a URL for the endpoint to use to obtain a copy of the current instance document through the app API.   platform Contains a URL for the endpoint to use to obtain a copy of the current instance document through the Platform Storage API.    Complete example This example was created by instantiating an app running locally on a development machine using LocalTest. The process is at first step, Task_1, and it has a single data element which is the main form of the app.\n{ \u0026#34;id\u0026#34;: \u0026#34;1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;instanceOwner\u0026#34;: { \u0026#34;partyId\u0026#34;: \u0026#34;1337\u0026#34;, \u0026#34;personNumber\u0026#34;: \u0026#34;01039012345\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;appId\u0026#34;: \u0026#34;ttd/bli-applikasjonseier\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://altinn3local.no/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34; }, \u0026#34;dueBefore\u0026#34;: null, \u0026#34;visibleAfter\u0026#34;: null, \u0026#34;process\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2020-11-18T15:56:41.5662973Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2020-11-18T15:56:41.5664762Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Utfylling\u0026#34;, \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;ended\u0026#34;: null, \u0026#34;validated\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2020-11-20T13:00:05.1800273+00:00\u0026#34;, \u0026#34;canCompleteTask\u0026#34;: true } }, \u0026#34;ended\u0026#34;: null, \u0026#34;endEvent\u0026#34;: null }, \u0026#34;status\u0026#34;: null, \u0026#34;completeConfirmations\u0026#34;: null, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;filename\u0026#34;: null, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/bli-applikasjonseier/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://altinn3local.no/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34; }, \u0026#34;size\u0026#34;: 401, \u0026#34;locked\u0026#34;: false, \u0026#34;refs\u0026#34;: [], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;createdBy\u0026#34;: null, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: null } ], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:42.1972942Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;1337\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:42.1972942Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;1337\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/",
	"title": "Konfigurasjon",
	"tags": [],
	"description": "Konfigurering av ulike aspekter av en app.",
	"content": "\r\rAutorisasjon\rHvordan definere autorisasjonsregler (tilgangsstyring) for en app.\n\r\rAktørtyper\rHvordan sørge for at kun bestemte typer aktører kan bruke en app.\n\r\rDatafelter på instansobjektet\rKonfigurasjon av datafelter for app.\n\r\rPresentasjonsfelter i meldingsboksen\rKonfigurasjon av presentasjonsfelter for app.\n\r\rDefinere applikasjonsprosess\rHvordan definere prosessen til en app.\n\r\rHemmeligheter\rHvordan håndtere hemmeligheter og sensitiv data i en app.\n\r\rEvents\rHvordan lage egendefinerte events for en app.\n\r\rSettings og miljøvariabler\rHvordan legge inn konfigurasjon- og miljøspesifikke verdier slik at de er tilgjengelig fra app-koden.\n\r\rStateless applikasjon (innsynstjeneste)\rHvordan legge inn konfigurasjon for å styre oppførsel ved applikasjonens oppstart\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/",
	"title": "Platform APIer",
	"tags": [],
	"description": "APIer i Altinn Platform.",
	"content": "\rEvents (hendelser)\rPlatform API for hendelser.\n\r\rInstanser\rPlatform API for instanser.\n\r\rInstance events\rPlattform API for å jobbe med instans-hendelser.\n\r\rSwagger\rOpen API-spesifikasjoner for Altinn 3 Platform API.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/technology/",
	"title": "Teknologi",
	"tags": [],
	"description": "Systemdokumentasjon for Altinn Studio, Altinn Apps og Altinn Platform.",
	"content": "Dokumentasjon for teknologi er foreløpig kun tilgjengelig på engelsk.\n\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/texts/",
	"title": "Tekster",
	"tags": [],
	"description": "Hvordan editere og formatere tekster, bruke variabler og legge til hjelpetekster.",
	"content": "Tekster lagres i ressursfiler i appen (App/config/texts). Tekster kan være fra felles biblioteker, datamodellen eller manuelt lagt inn av utvikler.\nTekstressursene er tilgjengelig når man redigerer UI komponenter i skjemaet via Altinn Studio, og de vises til sluttbruker når skjemaet lastes inn i nettleser.\nTekster lagres i JSON-format og det er én fil pr språk.\nFormat på filnavn for tekster er resource.[språk].json f.eks: resource.nb.json.\nFormatering av tekster Alle tekster kan formateres med markdown. Nedenfor er de mest benyttede formateringene beskrevet. Mer omfattende dokumentasjon og tips til hvordan markdown kan benyttes finnes her: Markdown Cheatsheet.\nUthevede tekster Det er ekstremt enkelt å gjøre ord eller setninger fet eller kursiv i markdown.\nDette er en _kursiv tekst_ laget med understrek. Dette er også en *kurvis tekst* laget med stjerne. Dette er __fet tekst__ laget med understrek. Dette er også **fet tekst**, men laget med stjerner! Lenker Trykk [her](https://altinn.github.io/docs) for å komme til Altinn docs. Headinger # Dette er en stor heading (H1) ## Dette er en litt mindre heading (H2) ### Og enda litt mindre (H3) #### Bitteliten heading (H4) Legge til og endre tekster i en app Man har to alternativer når man skal endre tekster i en app: enten gjøres det via Altinn Studio eller direkte i repository.\nLegge til og endre tekster i Altinn Studio Designer I den øverste navigerings menyen i Altinn Studio, velg Språk for å kunne redigere tekster. En oversikt over tekstene som allerede er tilgjengelig for applikasjonen listes opp.\nPå denne siden kan man redigere eksisterende tekster samt legge til nye teksressurser. Nye tekster legges til ved å trykke på Ny tekst, og fylle ut tekst og en unik nøkkel.\nLagre endringer i tekstene ved å trykke på Lagre tekster.\nLegge til og endre tekster i repository Dersom det er mange tekster som skal endres på en gang kan det være praktisk å redigere tekstene i JSON-struturen direkte i repoet. Enten via Altinn Studio Repos eller i en lokal klone i selvvalgt kodeeditor.\nTekstene ligger lagret i App/config/texts\nVariabler i tekster Variabler i tekster kan inkluderes ved å følge oppsettet nedenfor.\nStøttede datakilder: datamodel.\n{ \u0026#34;id\u0026#34;: \u0026#34;good.text.id\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Hello, {0}! Here is a second variable {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;datamodelField\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.\u0026lt;dataModelName\u0026gt;\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;datamodelField\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.\u0026lt;dataModelName\u0026gt;\u0026#34; } ] } Rekkefølgen på variablene må matche parameterne i teksten.\n{ \u0026#34;id\u0026#34;: \u0026#34;common.submitinfo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du leverer nå skjema for: {0} med organisasjonsnummer: {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig.organisasjonsnavn\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig.organisasjonsnummer\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; } ] } Det er anbefalt at variablene er statiske gjennom prosessflyten til en instans. Dette kan man oppnå ved å enten bruke prefill data eller verdier som settes under instansiering som variabler. Se et eksempel på hvordan å sette et datafelt under instansiering her.\nVariabler i tekst - repeterende grupper For at variabler i tekst skal fungere med data som ligger i repeterende grupper, må oppsettet vist over endres litt for de aktuelle feltene, for å spesifisere den repeterende gruppen dataene ligger i.\nDette gjøres ved å legge til [{0}] etter den repeterende gruppen når man spesifiserer felt i datamodellen i key-parameteren. F.eks.:\n{ \u0026#34;id\u0026#34;: \u0026#34;common.submitinfo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du leverer nå skjema for: {0} med organisasjonsnummer: {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig[{0}].organisasjonsnavn\u0026#34;,  \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig[{0}].organisasjonsnummer\u0026#34;,  \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; } ] } Det er fullt mulig å kombinere variabler fra felter i repeterende gruppe med variabler fra felter ikke i repeterende gruppe. Det anbefales ikke å kombinere variabler fra felter fra forskjellige repeterende grupper, med mindre man er helt sikker på at rekkefølgen på innslag i gruppene vil bli helt like.\nLegge til hjelpetekst Hjelpetekster er små tekstsnutter som gir en kort og konsis beskrivelse av hva sluttbrukeren er forventet å fylle ut i feltet som teksten er tilknyttet.\nSpråknøklene som peker på hjelpeteksten er definert i FormLayout.json. I app repoet finner du filen under App/ui/.\nNedenfor ser du et eksempel på en FormLayout.json uten hjelpetekster.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;componentType\u0026#34;: 0, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;ServiceName\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;08d707a9-2475-4d23-bf76-f209fb434ec2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;componentType\u0026#34;: 7, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tilleggsopplysninger.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;tilleggsopplysninger.desc\u0026#34;, }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;omsetningsoppgaverTilleggsopplysninger.value\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;bd6589b6-e2ab-49ba-b39a-dd3f8b63e5de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Dersom du skulle ønske å legge til hjelpetekst på en av disse skjemakomponentene må du\n Legge til hjelpeteksten i tekstressursfilen som beskrevet her. Åpne FormLayout.json-filen. Legg til en binding til den nye hjelpeteksten med nøkkel \u0026quot;help\u0026quot; og verdi lik nøkkel til tekstressursen.  Slik ser hele filen ut etter å ha lagt til en hjelpetekst:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;componentType\u0026#34;: 0, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;ServiceName\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;08d707a9-2475-4d23-bf76-f209fb434ec2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;componentType\u0026#34;: 7, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tilleggsopplysninger.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;tilleggsopplysninger.desc\u0026#34;, \u0026#34;help\u0026#34;: \u0026#34;tilleggsopplysninger.help\u0026#34;  }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;omsetningsoppgaverTilleggsopplysninger.value\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;bd6589b6-e2ab-49ba-b39a-dd3f8b63e5de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Endre applikasjonstittel Når man oppretter en applikasjon vil man ha en tekstressurs med label ServiceName. Dette er tittelen på applikasjonen som vil gjenspeiles flere steder i løsningen vår. Blant annet når en sluttbruker fyller ut skjema, og når elementer skal vises i meldingsboksen på altinn.no.\nTittelen på applikasjonen skal ligge to steder i applikasjonsrepoet:\n  I tekstressurser med nøkkelen ServiceName. Tjenesteeiere oppfordres til å legge inn tittel på bokmål, nynorsk og engelsk. Dersom tittel mangler i tekstressursene vil lagringsnavnet (navnet på repoet) vises til sluttbrukeren.\n  I applicationmetadata.json under property title. Denne filen ligger under App/config/.\n  Dersom man gjør endrer ServiceName på applikasjonen sin lokalt er det viktig at også legge til den oppdatere tittelen i applicationmetadata.json også. Dersom tittel på applikasjonen endres i Altinn Studio enten på \u0026ldquo;Om\u0026rdquo; eller \u0026ldquo;Språk\u0026rdquo;-siden bli applicationmetadata.json oppdatert automatisk.\nEksempel på korrekt konfigurasjon for applikasjonstittel I App/config/applicationmetadata.json:\n\u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34;, \u0026#34;nn\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34;, \u0026#34;en\u0026#34;: \u0026#34;Auto deploy application\u0026#34; }, I App/config/texts/resource.nb.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;ServiceName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34; }, . . . ] } I App/config/texts/resource.nn.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;nn\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;ServiceName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34; }, . . . ] } I App/config/texts/resource.en.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;ServiceName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Auto deploy application\u0026#34; }, . . . ] } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/",
	"title": "Utvikling",
	"tags": [],
	"description": "Hvordan opprette og redigere apper i Altinn Studio.",
	"content": "\r\rData\rKonfigurering av datamodell, preutfylling og andre ting relatert til data i en app.\n\r\rApp brukergrensesnitt\rKonfigurering av komponenter, layouts, sider, grid, etc.\n\r\rLogikk\rHvordan legge til, endre og konfigurere applikasjonslogikk som validering, kalkulering og dynamikk.\n\r\rKonfigurasjon\rKonfigurering av ulike aspekter av en app.\n\r\rAPI\rAppene som man utvikler i Altinn Studio kan både eksponere standard og custom APIer samt benytte seg av APIer. Slik gjør du det.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/",
	"title": "API",
	"tags": [],
	"description": "Appene som man utvikler i Altinn Studio kan både eksponere standard og custom APIer samt benytte seg av APIer. Slik gjør du det.",
	"content": "\r\rEksponere APIer fra en app\rMan kan legge til flere API enn det som er definert som standard API for applikasjoner utviklet i Altinn Studio.\n\r\rInstans\rHvordan gjøre endringer på applikasjonsinstanser\n\r\rKonsumere APIer i en app\rEn applikasjon kan konsumere åpne og lukkede API som er tilgjengelig via Internett.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/instances/",
	"title": "Instanser",
	"tags": ["api", "translate-to-norwegian"],
	"description": "App API å jobbe med forekomster av en app.",
	"content": "Overview An instance can be regarded as an envelope or folder where data is collected and exchanged between the application user and owner. The instance document is a way for Altinn and external parties to track the state of one specific data exchange. How long an instance lives and how many interactions there are between the application owner and user will vary from one app to another. Advanced apps will have their own documentation.\nbasePath\n{org}/{appname}/instances Get instance Endpoint for downloading the instance metadata document for a specific instance. The app API does not have an endpoint for listing instances. The Storage API in the Platform has a query endpoint that can be used for this purpose.\nUse this endpoint for instances that are active, and the owner party id and instance guid for the instance are known. External systems that work with an instance over multiple sessions might want to keep these values (or full URL) stored on their end to limit the need to query this information multiple times.\nGET {basePath}/{instanceOwnerPartyId}/{instanceGuid} Get active instances Endepunkt for å liste aktive instanser for en avgiver.\nDette endepunktet kan benyttes for å avgjøre om en ny instans av en app skal opprettes eller om det er mer hensiktsmessig å fortsette utfylling av en eksisterende instans. Merk at objektet som returneres er en liste med forenklede instansobjekt og at LastChangedBy inneholder navnet på den sist aktive entiteten i stedet for id.\n[ { \u0026#34;id\u0026#34;: \u0026#34;1337/bffd2c17-9d93-49f4-b504-3d0ece2402c7\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2021-09-23T10:19:43\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;Sophie Salt\u0026#34; }, { \u0026#34;instanceId\u0026#34;: \u0026#34;1337/agfd2c17-4d93-49f4-b504-3d0ece2402d8\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2021-07-11T22:14:02\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;Sophie Salt\u0026#34; } ] GET {basePath}/{instanceOwnerPartyId}/active Create instance Altinn assigns a unique identifier to all users that wish to report data. We call this id instanceOwner.partyId. If you do not know this, you should provide the official identity number, e.g national identification number for persons or organisation number for organisations, and in some case user name. This should be provided as part of the payload to the creation request. Altinn will look up this identifier and replace it with the instanceOwner.partyId. The official identity number will be stored in the instance metadata.\nData elements can be provided as part of the creation request, but can also be uploaded at a later time.\nThe client specifies the instance owner and may set a number of the metadata fields of the instance by attaching the following form:\n{ \u0026#34;appId\u0026#34; : \u0026#34;org/app\u0026#34;, \u0026#34;instanceOwner\u0026#34;: { \u0026#34;personNumber\u0026#34;: \u0026#34;12247918309\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;dueBefore\u0026#34;: \u0026#34;2019-06-01T12:00:00Z\u0026#34;, \u0026#34;visibleAfter\u0026#34;: \u0026#34;2019-05-20T00:00:00Z\u0026#34; } Notice that all dates must be expressed in Utc (Zulu) time zone and represented according to ISO 8601!\nData elements (files) can be attached to the initial request as a multipart/form-data or as attachments. The name of the parts must correspond to element types defined in the application metadata.\nPOST {basePath} A multipart/formdata should contain the instance json document and the data element files of the instance. The first part should be instance which contains the json template to create an instance from.\nThe subsequent parts must have a name that correspond to the element types defined in application metadata. They may have a filename. Hence the model1 and certificate names correspond to data types defined in the application metadata. If additional data elements are required they must be defined in the application metadata.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { ... } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;model1\u0026#34; \u0026lt;xml\u0026gt; ... \u0026lt;/xml\u0026gt; --abcdefg Content-Type: application/pdf Content-Disposition: form-data; name=\u0026#34;certificate\u0026#34;; filename=certificate.pdf %PDF-1.4 %Óëéá 1 0 obj ... --abcdefg-- This call will return the instance metadata document that was created.\nUpdate sub status The instance sub status is used to give an end user further details about the state of their instance. Currently, only application owner is allowed to update substatus for an instance. Include the new substatus in the body of the requests as a json.\nPUT {basePath}/{instanceOwnerPartyId}/{instanceGuid}/substatus Request body\n{ \u0026#34;label\u0026#34;: \u0026#34;some.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beskrivelse i klarteskst\u0026#34; } The values can be referencing text resource names from the language files or be regular text.\nComplete instance Endpoint used by application owner to mark an instance as completed. Technically this only means that the instance is no longer needed by the application owner.\nAltinn will permanently delete an instance and all the data, if both application owner and a user with the necessary rights indicate on the instance that they no longer have a need for it.\nPOST {basePath}/{instanceOwnerPartyId}/{instanceGuid}/complete The request does not use the request body for anything even though it is a POST request.\nDelete instance Endpoint for marking an instance as deleted. This can be used by both application owner and user to delete an instance. The endpoint has an optional parameter called hard that can be used to indicate the type of delete that is wanted. Setting the parameter to false or simply omitting it, will move the instance to a recycle bin. Hard delete means that the instance will be unrecoverable.\nInstances that where active might be permanently deleted by Altinn within a few days. Archived instances will be permanently deleted if both application owner and a user with the necessary rights indicate on the instance that they no longer have a need for it.\nDELETE {basePath}/{instanceOwnerPartyId}/{instanceGuid}?hard=true The endpoint does not use the request body for anything.\nThere are no Application API endpoint for recovering instances in the recycle bin.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pdf/",
	"title": "PDF",
	"tags": [],
	"description": "Hvordan konfigurere generering av PDF.",
	"content": "Ekskludere sider Det er mulig å konfigurere hvilke sider man vil ha med i den genererte pdf\u0026rsquo;en ved hjelp av Settings.json under App/ui/. Dette gjøres på følgende vis:\n{ \u0026#34;pages\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [\u0026#34;side2\u0026#34;] } } Her vil sidene spesifisert i pages.excludeFromPdf bli ekskludert fra pdf. Om denne array\u0026rsquo;en ikke settes i repo så vil alle sidene bli med.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/",
	"title": "Testing av apper",
	"tags": [],
	"description": "Applikasjoner (apper) kan testes i testmiljø, eller lokalt.",
	"content": "\r\rTest av app lokalt\rBeskrivelse av hvordan test av app lokalt på egen maskin kan gjøres\n\r\rTest app i testmiljø\rBeskrivelse av hvordan test i testmiljø kan utføres.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/data-element/",
	"title": "DataElement",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Et DataElement er en metadatabeholder som brukes til å spore statusen til faktiske data blobs.",
	"content": "DataElement The data element model is the main model for metadata related to a specific data element. A data element can be any data associated with an instance. The two most common type of data is the actual form data and attachments.\nProperties    Name Description     id A globally unique id for the data element.   instanceGuid The globally unique id for the instance the data element is associated with.   dataType The name of the data type describing the requirements of the data element.   filename The data blob name if represented as a file.   contentType The mime-type of the content of the blob.   blobStoragePath The physical location of the data as it is stored in the Application owner storage account.   selfLinks A complex type containing a set of named links of how to obtain a copy of the data element.   size The number of bytes in the blob.   locked A value indicating whether the blob is read only.   refs A list of UUID values. Can be used to link related data elements.   isRead A boolean indicating if the dataElement has been read by a user.   created The date and time when the data element was first created.   createdBy An idenfificator indicating who it was that created the data element.   lastChanged The date and time when the data element was last changed.   lastChangedBy An idenfificator indicating who it was that made the last change to the data element.    Complete example This data element example is from the instance example.\n{ \u0026#34;id\u0026#34;: \u0026#34;8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;filename\u0026#34;: null, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/bli-applikasjonseier/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://altinn3local.no/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34; }, \u0026#34;size\u0026#34;: 401, \u0026#34;locked\u0026#34;: false, \u0026#34;refs\u0026#34;: [], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;createdBy\u0026#34;: null, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: null } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/widgets/",
	"title": "Widgets",
	"tags": [],
	"description": "Hvordan bruke sammensatte komponenter (widgets).",
	"content": "Hva er en widget? En widget er en kompleks komponent, sammensatt av en eller flere enkle skjemakomponenter - de skjemakomponentene som er tilgjengelige for bruk i Altinn Studio i dag. En widget er et verktøy i Altinn Studio som gjør det lettere å lage og gjenbruke layouts.\nHvordan bruke widgets Widgets er tilgjengelige i venstre-menyen i skjemaeditoren i Altinn Studio. Den kan dras inn i skjemasiden på samme måte som andre skjemakomponenter. Når en widget dras inn i skjema i Altinn Studio, legges de skjemakomponentene som er definert som del av widget\u0026rsquo;en til i layouten, sammen med ev. standard oppsett som knytning til datamodell, tekster, osv. Når en widget er dratt inn i skjema, vil man kun se de skjemakomponentene som den er laget av. Disse kan redigeres som normalt i skjemaeditoren. Dersom det er tekster definert for widget\u0026rsquo;en, disse legges til i ressursfilene for tekster automatisk.\nEksempel: Meldings-widget Tilgjengelige widgets Standard widgets Vi vil etter hvert kunne tilby en samling av forskjellige widgets, disse vil dukke opp automatisk i venstre-menyen i skjemaeditoren i Altinn Studio. Listen oppdateres etter hvert som nye widgets legges til. Per nå. er følgende widgets tilgjengelig:\n   Navn Beskrivelse Skjermbilde     Melding Inneholder komponentene som utgjør en standard melding:\n tittel\nmeldingstekst\nvedlegg\nnavigasjonsknapp\nTekstene er satt opp med referanse til felt i standard melding datamodell. Se her for mer info om meldinger.     Egendefinerte widgets I tillegg til standard widgets som kommer opp automatisk i Altinn Studio, er det også mulig å definere sine egne widgets. En widget består av 3 deler:\n Komponenter: Dette er liste over komponentene som skal inngå, inkl. definisjon av disse komponentene. Dette settes opp på samme måte som i layout-filene, man kan f.eks. kopiere ut komponenter direkte fra en layout-fil. Visnings-navn: Dette er teksten som vises i Altinn Studio, i menyen der widget\u0026rsquo;en ligger. Tekstressurser: Dette er valgfritt, og er en liste over tekstressurser på de språk som man ønsker å ha med. Nyttig om komponentene f.eks. skal ha noen standard tekster de bruker.  Se oppsett for meldings-widget for et konkret eksempel. Det fins også en widget-mal som kan lastes ned for å komme i gang.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v3 av Altinn.Platform.Storage.Interface.",
	"content": "3.3.0 Lagt til Tags på modellen DataElement  DataElement modellen har blitt utvidet med en ny egenskap for å holde på en liste med stikkord (tags).  3.2.0 Innføring av ny modell OnEntryConfig  Innføring av en ny model, OnEntryConfig for å støtte definering av hva som skal skje når en bruker åpner opp en applikasjon. Modellen er lagt inn som en egenskap på Application.  3.0.1 Innføring av ny modell DataValues  Modellen DataValues er innført til å representere input til API endepunkt for registrering av tekster fra skjema direkte på en Instance.  3.0.0 Refactoring and model application/instance model changes Endringer som krever tilpassninger i app kode (breaking changes)  Modellen PresentationField har endret navn til DataField.\nDette gjøres slik at den kan benyttes i flere sammenhenger. Bruken av modellen er utvidet til å representere et element i egenskapen DataFields på Application i tillegg til at den fortsatt brukes for å representere elementer i egenskapen PresentationFields. Det er ingen andre endringer i modellen eller hvordan den blir brukt.  Andre endringer  Application modellen er utvidet med en ny egenskap kalt DataFields og Instance er utvidet med korresponderende egenskap kalt DataValues for å holde verdiene identifisert basert på DataFields.  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/",
	"title": "v4",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v4 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v4.0.0.\n\r\rHva er nytt?\rOversikt over endringer som ble introdusert i versjon 4.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v3 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v3.0.0.\n\r\rHva er nytt?\rOversikt over endringer som ble introdusert i versjon 3.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/scenarios/authentication/",
	"title": "Autentisering",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Hvordan autentisere ved å bruke APIene.",
	"content": "Authentication for application owners Application owners should be authenticated with Maskinporten.\nAPI provisioning in Maskinporten API-provider To provide an API in maskinporten Altinn has to do two operations.\n As API-provider Altinn registres a scope in Maskinporten POST /scopes { \u0026#34;prefix\u0026#34;: \u0026#34;altinn\u0026#34;, \u0026#34;subscope\u0026#34;: \u0026#34;instances/metadata.read\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Clients can access metadata for all instances for all apps of the organisation\u0026#34; }  As API-provider Altinn has to give access to its scope for a given organisation PUT /scopes/access/889640782?scope=altinn:apps.read Here we have given organisation 889640782 access to the scope altinn:instances/metadata.read. The organisation must then create a client that uses the scope.\n  API-consumer To access the Altinn API an organisation must create a client.\n As API-consumer the organisation must create a client in Maskinporten with scopes provided by Altinn: POST /clients { \u0026#34;client_name\u0026#34;: \u0026#34;altinnOrgRead\u0026#34;, \u0026#34;client_type\u0026#34;: \u0026#34;CONFIDENTIAL\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Client for accessing the my orgs app data\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;altinn:instances/metadata.read\u0026#34; ],  \u0026#34;token_reference\u0026#34;: \u0026#34;SELF_CONTAINED\u0026#34; }   Scopes scope names must follow the following regexp:\n^([a-z0-9]+\\/?)+[a-z0-9]+(\\.[a-z0-9]+)?$? It means that we cannot have - or _ in scope names.\nAll instances scope altinn:serviceowner/instances.read altinn:serviceowner/instances.write This is the most general scope which can be given to an organisation by Altinn. It means that the application owner can create a client that can access all instances of apps issued by that application owner.\nClients with write scope will be able to instantiate applications through direct access to the app\u0026rsquo;s api, update metadata, update process state, upload data, validate data, and change process of an instance.\nClients with read token will only be allowed to read metadata, data and events information.\nExchange of JWT token Application owners register clients in Maskinporten and selects the scope they need.\nA client is authenticated by Maskinporten and are given a Maskinporten JWT access token.\nThis token has to be validated and replaced with an Altinn JWT access token which should be used to access the apis.\nMaskinporten JWT access token (input) Client provides a self-contained access-token.\nAutorization: Bearer eyJraWQiOiJIdFlaMU1UbFZXUGNCV0JQVWV3TmxZd1RCRklicU1Hb081OFJ4bmN6TWJNIiwiYWxnIjoiUlMyNTYifQ.eyJhdWQiOiJ0ZXN0X3JwIiwic2NvcGUiOiJ ... GET /authentication/api/v1/exchange/maskinporten The token looks something like this (after base64-decoding):\n{ \u0026#34;kid\u0026#34;: \u0026#34;HtYZ1MTlVWPcBWBPUewNlYwTBFIbqMGoO58RxnczMbM\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34; } . { \u0026#34;aud\u0026#34;: \u0026#34;https://tt02.altinn.no/maskinporten-api/\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;altinn:instances.write\u0026#34;, \u0026#34;iss\u0026#34;: \u0026#34;https://oidc-ver2.difi.no/idporten-oidc-provider/\u0026#34;, \u0026#34;client_amr\u0026#34;: \u0026#34;virksomhetssertifikat\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;exp\u0026#34;: 1571935870, \u0026#34;iat\u0026#34;: 1571923870, \u0026#34;client_id\u0026#34;: \u0026#34;0de19f7a-f5fa-45d1-874c-3d2e88ce97d9\u0026#34;, \u0026#34;client_orgno\u0026#34;: \u0026#34;974760673\u0026#34;,  \u0026#34;jti\u0026#34;: \u0026#34;U3HMLIY8b_X454CADQzfttSuWpCADPQhc57iZXVF_Ac\u0026#34;, \u0026#34;consumer\u0026#34;: { \u0026#34;authority\u0026#34;: \u0026#34;iso6523-actorid-upis\u0026#34;, \u0026#34;ID\u0026#34;: \u0026#34;0192:974760673\u0026#34; } } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Maksinporten provides the legal consumer (the client) in ISO 6523 format. The client_orgno claim is deprecated.\nThe Altinn JWT Access token (output) The convert operation validates the incoming token and generates a new JWT token with the same scope as the token. The scopes is copied. The orgNumber and org is added by the token converter.\n{ \u0026#34;scope\u0026#34;: \u0026#34;altinn:instances.read altinn:instances.write\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;exp\u0026#34;: 1571996946, \u0026#34;iat\u0026#34;: 1571995146, \u0026#34;client_id\u0026#34;: \u0026#34;0de19f7a-f5fa-45d1-874c-3d2e88ce97d9\u0026#34;, \u0026#34;client_orgno\u0026#34;: \u0026#34;974760673\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;BcNIAuZKXdjpECmmwalAm-pcBp0iNc56T6eXhlxNBZE\u0026#34;, \u0026#34;consumer\u0026#34;: { \u0026#34;authority\u0026#34;: \u0026#34;iso6523-actorid-upis\u0026#34;, \u0026#34;ID\u0026#34;: \u0026#34;0192:974760673\u0026#34; }, \u0026#34;org\u0026#34;: \u0026#34;brg\u0026#34;, \u0026#34;orgNumber\u0026#34;: 974760673,  \u0026#34;iss\u0026#34;: \u0026#34;https://platform.altinn.cloud/\u0026#34;, \u0026#34;AuthenticateMethod\u0026#34;: \u0026#34;maskinporten\u0026#34;, \u0026#34;AuthenticationLevel\u0026#34;: 3, \u0026#34;nbf\u0026#34;: 1571995146 } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Authentication for end user system End user systems should be authentication with ID-porten. When authenticated the system may exchange a token provided by ID-porten with an Altinn token by instructions below.\nExchange of JWT token This token has to be validated and replaced with an Altinn JWT access token which should be used to access the apis.\nID-porten JWT access token (input) Autorization: Bearer eyJraWQiOiJjWmswME1rbTVIQzRnN3Z0NmNwUDVGSFpMS0pzdzhmQkFJdUZiUzRSVEQ0IiwiYWxnIjoiUlMyNTYifQ.eyJhdF9 ... GET /authentication/api/v1/exchange/id-porten The token looks something like this (after decoding):\n{ \u0026#34;kid\u0026#34;: \u0026#34;cZk00Mkm5HC4g7vt6cpP5FHZLKJsw8fBAIuFbS4RTD4\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34; } . { \u0026#34;at_hash\u0026#34;: \u0026#34;IF-jpSLtMjzoHdEhLq9pnw\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;PZcxQYOR_ylbrlj69pXn_HdTmrpDRpA3X0rTyOEyN5I=\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;Minid-PIN\u0026#34; ], \u0026#34;iss\u0026#34;: \u0026#34;https://oidc-ver2.difi.no/idporten-oidc-provider/\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;191080XXXXX\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;nonce\u0026#34;: \u0026#34;1584978003167642\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;bQDBkJmjrX3bx2agu4q7BS5QW6TPf9CHnJX11vEthZg\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;38e634d9-5682-44ae-9b60-db636efe3156\u0026#34;, \u0026#34;acr\u0026#34;: \u0026#34;Level3\u0026#34;, \u0026#34;auth_time\u0026#34;: 1584978021, \u0026#34;exp\u0026#34;: 1584978141, \u0026#34;iat\u0026#34;: 1584978021, \u0026#34;jti\u0026#34;: \u0026#34;_Og8JT1zMKzzHFB4WoVCdvqzmEpoY1hPhLa47bieJ94\u0026#34; } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; The Altinn JWT Access token (output) The exchange operation validates the incomming token and generates a new JWT token that contains user data retrieved from the database using the provided pid (person identification number) and pre-existing data from the ID-porten token.\npid is referred to as ssn (social security number) i Altinn Platform.\n{ \u0026#34;nameid\u0026#34;: \u0026#34;20000011\u0026#34;, \u0026#34;urn:altinn:userid\u0026#34;: \u0026#34;20000011\u0026#34;, \u0026#34;urn:altinn:username\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;urn:altinn:partyid\u0026#34;: 50002119, \u0026#34;urn:altinn:authenticatemethod\u0026#34;: \u0026#34;Minid-PIN\u0026#34;, \u0026#34;urn:altinn:authlevel\u0026#34;: 3, \u0026#34;amr\u0026#34;: \u0026#34;Minid-PIN\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;191080XXXXX\u0026#34;,  \u0026#34;locale\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;nonce\u0026#34;: \u0026#34;1585045781364132\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;BYSqEpVGRrh6rElmnzzTjcU0roC95rxNCC2kAsB2hmY\u0026#34;, \u0026#34;acr\u0026#34;: \u0026#34;Level3\u0026#34;, \u0026#34;auth_time\u0026#34;: 1585045793, \u0026#34;exp\u0026#34;: 1585047785, \u0026#34;iat\u0026#34;: 1585045985, \u0026#34;nbf\u0026#34;: 1585045985 } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Open ID Connect configuration This is work-in-progress. The response is still missing required information and might be inconsistent with actual authentication mechanisms.\r\rMetadata about Altinn as an Open ID provider is exposed as a .well-known endpoint as defined by OpenID Connect Discovery.\nThe primary porpose of this endpoint is to make available the Altinn signing certificate for the JSON Web Tokens being generated. It is recommended that clients of Altinn use this discovery endpoint to automatically have their systems updated when Altinn changes their signing certificate.\n   Environment URL     AT2x https://platform.at2x.altinn.cloud/authentication/api/v1/openid/.well-known/openid-configuration   YT01 https://platform.yt01.altinn.cloud/authentication/api/v1/openid/.well-known/openid-configuration   TT02 https://platform.tt02.altinn.no/authentication/api/v1/openid/.well-known/openid-configuration    "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorisation/",
	"title": "Autorisasjon",
	"tags": [],
	"description": "Hvordan definere autorisasjonsregler (tilgangsstyring) for en app.",
	"content": "Autorisasjonsregler for en applikasjon er definert i en XACML Policy-fil som ligger i applikasjonsrepoet. XACML Policy-en inneholder en eller flere regler som definerer hvem som kan gjennomføre ulike aksjoner på ulike ressurser.\nBeskrivelse av XACML-strukturen og definisjon av regler finnes her\nXACML-filen kan endres i en valgfri teksteditor.\nRegler i applikasjonsmalen Når det opprettes en app i Altinn Studio basert på den nåværende asp.net malen vil det følge med en autogenerert XACML policy-fil. Reglene som er definert i denne filen er kort beskrevet nedenfor.\nOvernevnte regler kan endres i policy.xml som ligger i App/config/authorization i applikasjonsrepoet. Detaljer om hvordan å konfigurere policy filen finnes her I tillegg vil du finne en del eksempelregler her.\nMerk at endringer i policyfilen gjøres på eget ansvar, og at det oppfordres til å alltid delegere leserettigheter dersom en entitet også har fått tildelt skriverettigheter.\r\rRettigheter for rolleinnhaver I denne filen er det definert regler som gir innehaver av rollene daglig leder (DAGL) og/eller regnskapsmedarbeider (REGNA) rettigheter til å instansiere, skrive, lese og slette instanser av applikasjonen.\nRettigheter for applikasjonseier Applikasjonseier (organisasjonen) har rettigheter til å instansiere, skrive og lese instanser av applikasjonen. Til slutt har de rettigheter til å markere på en instans at de er ferdig med den.\nPåkrevd autentiseringsnivå Påkrevd autentiseringsnivå er satt til 2 som default. Dette gjøres som en obligation i XACML Policy\nHvis nivået settes til 4 må man definere at tjenesteier kan nå det via nivå 3 for maskinporten. Dette for at maskinporten er definert som nivå 3. Se regelbibliotek for eksempel. Merk: Appen trenger nuget versjon 3.1.5 eller høyere versjon.\n\rRegelbibliotek\rBibliotek av autorisasjonsregler som kan brukes i en app. Husk å bytte ut tags ([ORG], [APP], [RULE_ID]) med din egen data.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/data-elements/",
	"title": "Data-elementer",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API å jobbe med dataelementene knyttet til en app instans.",
	"content": "Overview A data element consist of two parts: its metadata document and the actual data blob. This API work primarily with the blob while keeping the metadata document updated.\nbasePath\n{org}/{appname}/instances/{instanceOwnerPartyId}/{instanceGuid}/data Get data Endpoint for downloading the data blob.\nGET basePath/{dataGuid} Accept: application/{xml/json} The response will depend on the type of blob. There are currently 2 primary types: form data based on a model and attachments. An Accept header in a request will be considered only when the requested data element is connected to a data model. The header is then used to pick a serializer for the data.\nResponse with form data A response with form data will either be a json or xml serialized version of the data model depending on the Accept header in the request. The value application/xml will result in an XML document and the value application/json will result inn a JSON document.\nResponse with attachment A response with a file attachment will be a file stream. Content-Type will be the same as the original value given when the file was uploaded. The same is true for the file name.\nContent-Disposition: attachment; filename=cute_cat.png; filename*=UTF-8\u0026#39;\u0026#39;cute_cat.png Content-Length: 16994 Content-Type: image/png Upload data Endpoint for uploading a new data element on a specific instance.\nPOST basePath?dataType={data type name} The dataType parameter is required and should reference one of the data types defined on the application. Data types with an appLogic property are linked to a form and will have data validation and calculation rules associated with them. Data types without an appLogic property will be handeled as an attachment and streamed directly to storage.\nRequest Content-Type is handled a little differently between the two cases:\n If a request is uploading form data, the Content-Type is used by Altinn to deserialize the request into a strongly typed object. A request must either be application/json or application/xml. No other Content-Types are supported. Content-Type is not validated against allowed Content-Types on the data type. If a request is uploading an attachment, the validation of Content-Type will depend on the rules of the data type.  If the data type has no Content-Type requirements, there will be no validation and the request can contain any Content-Type. If the data type has Content-Type requirements, there is a new set of checks.  The request Content-Type must either be application/octet-stream or match the MIME type of the file being uploaded. Altinn will perform a mapping from file extension to MIME type before comparing with Content-Type. As an example we can see that .xml will map to text/xml and not application/xml. If the data type allow Content-Type application/octet-stream no further validation is performed. If not, the identified MIME type must match one of the allowed Content-Types on the data type.      Uploading form data as application/json Content-Type: application/json { \u0026#34;dataFormatProvider\u0026#34;: \u0026#34;SERES\u0026#34;, \u0026#34;dataFormatId\u0026#34;: \u0026#34;5703\u0026#34;, \u0026#34;dataFormatVersion\u0026#34;: \u0026#34;34553\u0026#34;, \u0026#34;Tjenesteeier\u0026#34;: null, \u0026#34;Kontaktperson\u0026#34;: { \u0026#34;navn\u0026#34;: \u0026#34;Sophie Salt\u0026#34;, \u0026#34;epost\u0026#34;: \u0026#34;1337@altinnstudiotestusers.com\u0026#34;, \u0026#34;telefonnummer\u0026#34;: \u0026#34;90001337\u0026#34; }, \u0026#34;OEnsketBruk\u0026#34;: null } Uploading form data as application/xml Content-Type: application/xml \u0026lt;BliTjenesteeier_M xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; dataFormatProvider=\u0026#34;SERES\u0026#34; dataFormatId=\u0026#34;5703\u0026#34; dataFormatVersion=\u0026#34;34553\u0026#34;\u0026gt; \u0026lt;Kontaktperson\u0026gt; \u0026lt;navn\u0026gt;Sophie Salt\u0026lt;/navn\u0026gt; \u0026lt;epost\u0026gt;1337@altinnstudiotestusers.com\u0026lt;/epost\u0026gt; \u0026lt;telefonnummer\u0026gt;90001337\u0026lt;/telefonnummer\u0026gt; \u0026lt;/Kontaktperson\u0026gt; \u0026lt;/BliTjenesteeier_M\u0026gt; Uploading an attachment An example of a request uploading a PDF file.\nContent-Type: application/pdf Content-Disposition: attachment; filename=\u0026#34;receipt.pdf\u0026#34;; filename*=UTF-8\u0026#39;\u0026#39;receipt.pdf Content-Length: 16994 %PDF-1.4 %Óëéá 1 0 obj ... Response example The endpoint returns the data element metadata document that was created.\n{ \u0026#34;id\u0026#34;: \u0026#34;692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;762011d1-d341-4c0a-8641-d8a104e83d30\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;org/app/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;{appPath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;{storagePath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34; }, \u0026#34;filename\u0026#34;: \u0026#34;default.xml\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-03-06T15:00:23Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;org23\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2019-03-07T15:00:23Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;org23\u0026#34;, \u0026#34;size\u0026#34;: 20001, \u0026#34;locked\u0026#34;: false } Replace data Endpoint for replacing the content of an existing data element with new data. The new data must match the data type of the data element it is replacing.\nPUT basePath/{dataGuid} The endpoint works exactly like the endpoint for uploading a new data element.\nDelete data Endpoint for deleting an existing data element. It is currently not possible to delete the data for a form this way.\nDELETE basePath/{dataGuid} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/",
	"title": "Datamodell i Altinn Studio",
	"tags": [],
	"description": "Slik importerer eller viser du datamodellen i Altinn Studio.",
	"content": "Det er planlagt datamodelleringsfunksjonalitet inn i Altinn Studio. Den midlertidige funksjonaliteten er derfor svært begrenset.\r\rLaste opp / vise datamodell Datamodellen definerer hvilke data som kan sendes inn via en app, og hvilket format det skal sendes på. Per nå må datamodellen være definert som en XSD i et eksternt verktøy - gjerne Seres Domeneklient.\nDet må lastes opp en datamodell for hver app.\n Åpne appen fra dashboardet Velg fanen Lage, og valget Datamodell i navigasjonsmenyen Klikk på Velg XSD og velg XSD-en i filvelgeren Klikk Last opp  Datamodellen blir da parset, og alle nødvendige filer generert og lagret i app-repositoryet. Disse filene kan vises ved å velge de ulike fanene på datamodellsiden.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/designer/",
	"title": "Designer",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Designer.",
	"content": "Designer er verktøyet du starer i etter å ha logget inn på https://altinn.studio. Det er et verktøy for å opprette, konfigurere og deploye apper.\nNavigere til en app Alle apper du har tilgang til å endre på vises på dashboardet. Gå til appen ved å klikke på appen. Dersom du ikke har en lokal klone av appen, vil du bli bedt om å opprette det.\nHvis du ønsker å gå til app-repositoryet når du er inne i en app i Designer, er det en lenke i menyen som ligger i profilmenyen øverst til høyre.\nRedigere en app Det er to navigasjonsmenyer - en toppmeny og en venstremeny.\nI toppmenyen kan du navigere mellom ulike funksjonelle områder av applikasjonen. I venstremenyen kan du navigere innad i området.\n Om  Om appen   Lage  Datamodell UI-Editor Tilgangsstyring   Språk  Tekster   Deploy  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/events/",
	"title": "Events (hendelser)",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Platform API for hendelser.",
	"content": "Overview Events are in this context is information about events created by applications or other sources. The event itself is based on the CloudEvent standard and is a small JSON structure containing the most important information of an event. Details are found here.\nThe events APIs are used to access events created by applications in Altinn Apps and other event sources that use Altinn Platform as av \u0026ldquo;event hub\u0026rdquo;.\nSubscription The highly preferred way to use events is to set up a subscription that enables push of events to a webhook-endpoint. This is done through the subcriptions API. This API supports the following consumers\n Persons, authenticated through ID-porten Orgs, authenticated through Maskinporten  The subscriptions API is described here as Swagger.\nThe webhook endpoint needs to be able to accept cloud event that is posted through HTTPS to the endpoint URL.\nThe push functionality also supports pushing events to Slack. Other platforms might be added at a later point.\nSearch API The search allows searching for events. The storage of events is limited to 90 days.\nThis is available to be used by the following consumers.\n Persons, authenticated through ID-porten Orgs, authenticated through Maskinporten  The API is described in swagger here.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/instances/",
	"title": "Instanser",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Platform API for instanser.",
	"content": "Overview An instance works as a form of envelope or folder where data can be collected and exchanged between the user and owner of the application. The instance document is a way for Altinn and external parties to track the state of one specific data exchange. How long an instance can live and how many interactions there can be between the application owner and user will vary from one app to another. Advanced Apps will have their own documentation.\nbasePath = https://{hostname}/storage/instances Query instances It is possible to query instances based on a number of query parameters.\nApplication owners can search for from a single application or across all applications that they have. Using this endpoint requires the scope \u0026lsquo;altinn:instances.read\u0026rsquo;. And query parameter \u0026lsquo;org\u0026rsquo; or \u0026lsquo;appId\u0026rsquo; must be included in the request.\nUsers can search for instances linked to either themselves or an instanceOwner they are authorized to read the instances of. Query parametr \u0026lsquo;instanceOwner.partyId\u0026rsquo; must be included in the request if using this endpoint as an end user.\nSearch for instances with a simple GET request towards the instances endpoint. Avaliable query paramters include:\n process.currentTask (string)\nSearch for instances at a specific step in its process. process.isComplete (bool)\nSearch for instances where the process is completed. process.endEvent (string)\nDeprecated. The parameter doesn\u0026rsquo;t have any code associated with it. process.ended (datetime)\nFilter instances based on ended date. instanceOwner.partyId (int)\nFilter instances based on the instance owner party id. lastChanged (datetime)\nFilter instances based on the last time they where worked on. created (datetime)\nFilter instances based on when they where initially created. visibleAfter (datetime)\nFilter instances based on when they became visible. dueBefore (datetime)\nFilter instances based on their due date. excludeConfirmedBy (string)\nExclude instances already confirmed by a specific stakeholder. Usually the short name of an application owner. isArchived (bool) Filter instances based on whether they are archived. isSoftDeleted (bool) Filter instances based on whether they are soft deleted. isHardDeleted (bool) Filter instances based on whether they are hard deleted. Note that hard deleted instances are only included if an application owner retrieves instances, and the results may include deleted drafts.  Some examples:\nGet all instances of application org/app, that is at process task with id Task_2 (which is Submit, see process definition), and has last changed date greater than 2019-05-01.\nGET {storagePath}/instances?appId=org/app\u0026amp;process.currentTask=Task_2\u0026amp;lastChanged=gt:2019-05-01 Get all instances of all applications of a given application owner org that has ended date greater than 2020-03-10.\nGET {storagePath}/instances?org=org\u0026amp;process.ended=gt:2020-03-10 Get all instances of all applications of a given application owner org that has not already been confirmed completed by org.\nGET {storagePath}/instances?org=org\u0026amp;excludeConfirmedBy=org Get all instances of an application that are at a specific process task e.g. Task_1.\nGET {storagePath}/instances?appId={org}/{app}\u0026amp;process.currentTask={taskId} On query parameters specifying date time you can use the following operators:\n gt: - greater than gte: - greater than or equal to lt: - less than lte: - less than or equal to eq: - equal (can also be blank)  They can be combined to define a range:\ndueBefore=gt:2019-02\u0026amp;dueBefore=lt:2019-03-01 The query returns a result object (page) which includes a collection of instances that matched the query. 100 instances is returned by default. Use size to get more or less instances per page. To get to the next page you have to use the continuationToken present in the next link.\nThe instances endpoint returns a query result object with information about how many total hits totalHits that the query matched and how many objects returned count.\nThe endpoint supports application/json.\nAccept: application/json { \u0026#34;totalHits\u0026#34;: 234, \u0026#34;count\u0026#34;: 50, \u0026#34;self\u0026#34;: \u0026#34;{storagePath}/instances?appId=org/app\u0026amp;size=50\u0026#34;, \u0026#34;next\u0026#34;: \u0026#34;{storagePath}/instances?appId=org/app\u0026amp;size=50\u0026amp;continuationToken=%257b%2522token%2522%253a%2522%252bRID%...\u0026#34; \u0026#34;instances\u0026#34;: [ {...}, {...}, ... ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/intro/",
	"title": "Intro for utviklere",
	"tags": [],
	"description": "Introduksjon",
	"content": "Altinn Studio aka. \u0026ldquo;Tjenester 3.0\u0026rdquo; What are we creating  A app development solution Altinn Studio: The development tool Altinn Platform: The supporting platform Altinn Apps: The solution to host the Apps   What technologies are we using  .NET Core : Backend / API React : Frontend Altinn Studio \u0026amp; App Docker: Apps are created as Docker Containers Kubernetes: The containers are hosted in Kubernetes Azure: We use Azure for Kubernetes hosting   Altinn Studio  Design frontend Define frontend logic Define datamodel for app Define app logic for backend Build \u0026amp; deploy app container Source Control for App files       Altinn Apps  Kubernetes Cluster where apps are hosted One cluster per Organisation   Altinn Platform  Supporting functionality Authentication Authorization Storage Register Profile   Documentation  The different solutions are described in detail on docs Terms Architecture   The End Tilbake\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/",
	"title": "Test av app lokalt",
	"tags": [],
	"description": "Beskrivelse av hvordan test av app lokalt på egen maskin kan gjøres",
	"content": "Dersom man skal skrive en del kode (f.eks. logikk), eller kjapt sjekke hvordan skjema ser ut kan det være nytting å kunne teste endringer uten å måtte deploye hele appen til testmiljø.\nNår appen lages, kommer den med alle nødvendige filer og oppsett til å kunne kjøres som en frittstående applikasjon. Ved å laste ned alle filene knyttet til appen fra repoet til appen, kan man kjøre appen lokalt på egen maskin, og på den måten enkelt teste endringer.\nI testmiljø bruker appen et sett med plattform-tjenester for å kunne hente ut/lagre data osv. Det er opprettet en forenklet versjon av disse tjenestene som kan settes opp og kjøres lokalt, og dette er nødvendig for at appen skal kunne testes lokalt.\nKjøre appen lokalt  Naviger til app repoet i Altinn Studio. Se her for hvordan man navigerer seg dit. Last ned alle filene i repoet   ved å bruke git clone kommandoen (les mer) ved å trykke på nedlastingsikonet (da lastes det ned som en zip-fil)  Se Altinn Studio på Github for informasjon om hvordan man laster ned og kjører den lokale plattformen,og hvordan man kjører appen.\n\rTesting av app API-er lokalt\rHvordan teste app-APIer lokalt.\n\r\rDebugging av app\rNår man kjører appene lokalt kan man debugge ved hjelp av ulike verktøy.\n\r\rTestbrukere lokalt\rVi har definert et lite sett med testbrukere som er tilgjengelig for lokal test.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/maskinporten/",
	"title": "Autentisere med Maskinporten",
	"tags": [],
	"description": "Beskrivelse av hvordan tjenesteeiers systemer kan benytte Maskinporten for å få tilgang til APIer.",
	"content": "Samarbeidsportalen I Min profil i Samarbeidsportalen så har du tilgang til selvbetjening for Maskinporten, og der kan du opprette nye integrasjoner (klienter).\n https://tt02.altinn.no er testmiljø for apper i Altinn, og det er koblet mot Ver 2-miljøet i Maskinporten. https://www.altinn.no er koblet mot Produksjon.  Tilgang som tjenesteeier For å kunne hente data fra Storage i Altinn 3 via API som tjenesteeier, så må man opprette en integrasjon (klient) i Maskinporten, med nødvendige scopes.\nFølgende scopes er opprettet av Altinn, og delegert til tjenesteeier. Disse scopene behøves for å benytte APIene relatert til instanser som tjenesteeier:\naltinn:serviceowner/instances.read altinn:serviceowner/instances.write Klienter med write scope kan bl.a. instansiere apper på vegne av bruker via appens eget API, laste opp data, oppdatere metadata og prosess-status. Klienter med read scope kan kun lese data, metadata og events.\nI de fleste tilfeller så vile en klient for tjenesteeier ha behov for begge scopene.\nOppretting av klient kan gjøres via API eller i Samarbeidsportalen.\nPOST https://integrasjon.difi.no/clients/ { \u0026#34;integration_type\u0026#34;: \u0026#34;maskinporten\u0026#34;, \u0026#34;client_name\u0026#34;: \u0026#34;DIHE testklient for instanser\u0026#34;, \u0026#34;client_type\u0026#34;: \u0026#34;CONFIDENTIAL\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Klient for å hente data fra mine apper\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;altinn:serviceowner/instances.read\u0026#34;, \u0026#34;altinn:serviceowner/instances.write\u0026#34; ], \u0026#34;token_reference\u0026#34;: \u0026#34;SELF_CONTAINED\u0026#34; } Mer informasjon  For mer informasjon, se dokumentasjon for API-konsument fra Maskinporten. Se også scenario for autentication for enda flere detaljer (på engelsk).  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/first-time-setup/",
	"title": "Opprette bruker i Altinn Studio",
	"tags": [],
	"description": "Konfigurer brukeren din i Altinn Studio for første gang.",
	"content": "Lag en bruker i Altinn Studio Din Altinn Studio bruker er personlig for deg og kan knyttes til en eller flere organisasjoner for å samarbeide med andre og få tilgang til eksisterende apper.\n\rVis/skjul innhold\r\rLag bruker med GitHub brukernavn\r\r\r Velg å logge inn på altinn.studio. På “Logg in”-siden, klikk på knappen “Har du en Github konto? Registrer deg med den her”.  Logg inn i GitHub hvis du ikke allerede er det.  Godkjenn at Altinn Studio bruker din GitHub-konto for å logge inn.  Lage en Altinn Studio bruker ved å fylle ut brukernavn, epost, passord, en captcha og klikk på “Fullfør”.\nBrukeren i Altinn Studio vil bli koblet til din GitHub-bruker og du er klar for å begynne arbeide med din første applikasjon.   \r\r \rVis/skjul innhold\r\rLag en bruker med epostadresse (uten GitHub)\r\r\r På “Logg inn”-siden, klikk på knappen “Behov for konto? Registrer deg nå.”  Lage en Altinn Studio bruker ved å fylle ut brukernavn, epostadresse, passord, en captcha og klikk på “Fullfør”. Du er nå klar for å begynne arbeide med din første applikasjon.   \r\r Bli del av en organisasjon Organisasjoner i Altinn Studio er det samme som tjenesteeiere i Altinn. De eier applikasjonene og gjør det mulig for flere innen samme organisasjon å samarbeide.\nFor å bli del av en organisasjon tar du kontakt med administrator for organisasjonen du arbeider for som legger deg til. Hvis du er usikker på hvem som er administrator eller du ikke vet om organisasjonen din er satt opp i Altinn Studio, kan du spørre Altinn servicedesk om hjelp.\nOpprette en organisasjon Det er Altinn som oppretter organisasjoner i Altinn Studio. For å kunne få en organisasjon i Altinn studio må du ha en avtale med Altinn.\nSend en mail til Altinn Servicedesk med navn på organisasjonen og hvem som skal være administrator for å opprette en ny organisasjon. Det vil kunne ta noen dager å opprette organisasjonen og du vil få en mail så fort det er gjort.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/slide/",
	"title": "Presentasjon",
	"tags": [],
	"description": "En presentasjon om målsettinger og konsepter for Tjenester 3.0",
	"content": "Altinn Studio Aka. \u0026ldquo;Tjenester 3.0\u0026rdquo; Dagens løsning  Produksjonsatt sommeren 2010 Basert på InfoPath og SharePoint 115.000.000 skjema fylt ut 404 aktive innsendingstjenester i 2018   Bakgrunn og mål  Behov har vært kjent lenge POC utviklet i 2015 (men lagt på is grunnet manglende finansiering) Finansiering på Statsbudsjettet 2018 Startet opp igjen våren 2018    Hva er målet med prosjektet?  En modern utviklingsplattform Et effektivt utviklingsverktøy En moderne infrastruktur En plattform for gjenbruk En platform for deling av data og erfaringer   En moderne utviklingsplattform Altinn Studio er en åpen og modern utviklingsplattform\n Versjonering og samarbeid via Git Støtte for distribuert utvikling All programvare som benyttes er åpen kildekode. Også selve 3.0-plattformen. Funksjonalitet i Altinn tilgjengelig via API’er Moderne og populær teknologi, f.eks. React og Visual Studio Code Full selvbetjening Tekniske utviklere kan benytte best-of-breed utvikler-verktøy og teknologi, slik de er vant til.       Et effektivt utviklingsverktøy Altinn Studio tilbyr enkel, effektiv og 100% selvbetjent utvikling og forvaltning av tjenester, også for ikke-teknologer.\n Brukergrensesnitt (GUI) API’er Arbeidsflyt Logikk og dynamikk Datamodellering Konfigurasjon og tilgangsstyring Automatisert testing …   En moderne infrastruktur Altinn Studio (og tjenester som lages der) vil kjøre på en moderne infrastruktur.\n Docker containers for applikasjoner Kubernetes for orkestrering av containers  Dette gir isolering mellom applikasjoner (microservices), enklere skalering og understøtter “DevOps”.\n  Hva kan jeg gjøre med MVP?  Opprette bruker og logge inn i Altinn Studio  Lage (og finne igjen) en tjeneste  Finne tjenester fra andre organisasjoner  Laste opp en datamodell som fungerer i tjenesten (Seres eller OR)  Lage et skjemadesign med drag and drop av elementer (begrenset utvalg av komponenter)  Legge inn tekster/tekstnøkler for tjeneste  Legge inn regler for skjemalogikk (validering, kalkulering, dynamikk)  Bruke API-oppslag i tjenesten (forutsetter Ajax kall kodet i GUI)\n Endre på standardfil for arbeidsflyt  Endre på filer med versjonskontroll  Legge den ferdige tjenesten i test- og produksjonsmiljø  Tjenster 3.0 vs Tjenester 2.0  Skjemaverktøy  Egenutviklet vs InfoPath React vs SharPoint formserver Responsivt vs ikke responsivt   Arbeidsflyt  BPMN vs Custom   Tjenester som API  REST vs SOAP Individuell API vs Generelle   Ressurser  Isolerte vs delte Raskt skalerbar vs lang leveringstid   Dataformat  JSON/XML vs XML   Kontroll på logikk  Full kontroll på når ting skjer i plattformen i motsetning til Infopath   Shipment  Inntil videre kun pull-basert nedlasting av skjemadata.   Videre arbeid i MVP  Fokus på infrastruktur Skyløsninger Sikkerhet Deploy av tjenester Integrasjon med tjenesteeier Understøtte piloter   Detaljer løsning Tre nye løsninger\n Altinn Studio Altinn Apps Altinn Platform   Altinn Studio  Altinn Apps  Altinn Platform  Status Du kan følge utviklingen på Github. Motivasjon Se Archimate arkitekturmodell. The End Tilbake\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/stateless-data-elements/",
	"title": "Tilstandsløse data",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API til å arbeide med dateelementer uten tilstand som ikke er knyttet til en instans.",
	"content": "Overview A stateless data element is a data object based on a data model without relations to an instance, instance owner or a state. The data is never persisted anywhere, and the avilable endpoints simply creates, prefills and/or runs calculations on a data object before returning it to the caller.\nbasePath\n{org}/{app}/v1/data Create new data Endpoint for creating a new stateless dataelement based on a data type.\nPOST basePath?dataType=[dataTypeId] Accept: application/{xml/json} The dataType parameter is required and should reference one of the data types defined on the application that requires app logic.\nIf prefill or calculations are defined for the data type, these will be run on the data element before it is returned.\nResponse A response with the data element in the body will be returned if a valid data type is provided.\nCalculate data Endpoint for running calculations on a data element.\nPUT basePath?dataType=[dataTypeId] Accept: application/{xml/json} The dataType parameter is required and should reference one of the data types defined on the application that requires app logic.\nThe Content-Type is used by Altinn to deserialize the request into a strongly typed object. A request must either be application/json or application/xml. No other Content-Types are supported. Content-Type is not validated against allowed Content-Types on the data type.\nProviding data as application/json Content-Type: application/json { \u0026#34;dataFormatProvider\u0026#34;: \u0026#34;SERES\u0026#34;, \u0026#34;dataFormatId\u0026#34;: \u0026#34;5703\u0026#34;, \u0026#34;dataFormatVersion\u0026#34;: \u0026#34;34553\u0026#34;, \u0026#34;Tjenesteeier\u0026#34;: null, \u0026#34;Kontaktperson\u0026#34;: { \u0026#34;navn\u0026#34;: \u0026#34;Sophie Salt\u0026#34;, \u0026#34;epost\u0026#34;: \u0026#34;1337@altinnstudiotestusers.com\u0026#34;, \u0026#34;telefonnummer\u0026#34;: \u0026#34;90001337\u0026#34; }, \u0026#34;OEnsketBruk\u0026#34;: null } Providing data as application/xml Content-Type: application/xml \u0026lt;BliTjenesteeier_M xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; dataFormatProvider=\u0026#34;SERES\u0026#34; dataFormatId=\u0026#34;5703\u0026#34; dataFormatVersion=\u0026#34;34553\u0026#34;\u0026gt; \u0026lt;Kontaktperson\u0026gt; \u0026lt;navn\u0026gt;Sophie Salt\u0026lt;/navn\u0026gt; \u0026lt;epost\u0026gt;1337@altinnstudiotestusers.com\u0026lt;/epost\u0026gt; \u0026lt;telefonnummer\u0026gt;90001337\u0026lt;/telefonnummer\u0026gt; \u0026lt;/Kontaktperson\u0026gt; \u0026lt;/BliTjenesteeier_M\u0026gt; "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/v2/",
	"title": "v2",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i v2 av Altinn.Platform.Storage.Interface.",
	"content": "2.5.10 Dependency on .NETStandard2.0  The package was changed to depend on .NetStandard2.0 in place of .NetStandard2.1. This should ensure that applications based on .NET Framework 4.7 can use the package.  2.5.9 Expanded the eFormidlingContract with SecurityLevel  eFormidlingContract model was given a new property holding security level information. #5740  2.5.8 Extended eFormidlingContract with additional parameters  eFormidlingContract model was given three new properties to support eFormidling in apps. #5740  2.5.7 Extended eFormidlingContract with a new property: sendAfterTaskId  eFormidlingContract model was given a new property to identify which task should trigger an eFormidling shipment. #5740  2.5.6 Adjustments around PresentationField and texts  Fixes to how PresentationFields were annotated. New class PresentationTexts to hold a list of texts generated by presentation field rules on an instance.  2.5.5 Added PresentationFields to Application  New class PresentationField to represent a data extraction rule. Instance model was given a new property called presentationFields. #5638  2.5.4 Fix the OpenAPI specification of ReadStatus  ReadStatus was changed to be defined as a string. #5637  2.5.3 eFormidling support  Added a new model to support integration with eFormidling.  2.5.2 Dependency on .NETStandard2.1  The package was changed to depend on .NetStandard2.1 in place of .NETCoreApp3.1. The dependency to the Microsoft.AspNetCore.Mvc.NewtonsoftJson package was removed and there is now instead a direct dependency to the Newtonsoft.Json package.  2.5.1 DataElement IsRead is true by default  The value of IsRead is changed to have default value true.  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v3 av app frontend.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i app frontend i v3.0.0\n\r\rHva er nytt?\rOversikt over endringer som ble introdusert i v3 av app frontend.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/partytype/",
	"title": "Aktørtyper",
	"tags": [],
	"description": "Hvordan sørge for at kun bestemte typer aktører kan bruke en app.",
	"content": "Avgrense tilgang i Altinn Studio designer I Altinn Studio designer finner du mulighet for å styre hvilke aktørtyper som har tilgang til en app i kategorien \u0026ldquo;Lage\u0026rdquo; i toppmenyen, på siden \u0026ldquo;Tilgangsstyring\u0026rdquo; representert ved låshull-ikonet. På denne siden krysser du av for de aktørtypene en app er tilgjengelig for. Hvis ingen (eller alle) aktørtyper er valgt, vil alle ha tilgang. Valget \u0026ldquo;Virksomhet\u0026rdquo; benyttes for tilfeller der det skal rapporteres på hovedenhet.\nSkjermdumpen under viser innstillingene for at alle organisasjonsnummer (både hovedenheter og underenheter) skal kunne bruke appen.\nJustere i applicationmetadata.json Hvis du foretrekker å jobbe i kode, finner du muligheten til å justere hvilke aktørtyper som kan benytte en app i applicationmetadata.json som ligger i mappa App/config i app-repositoryet. Eksempelet under viser samme innstillinger som skjermdumpen.\n\u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: false, \u0026#34;organisation\u0026#34;: true, \u0026#34;person\u0026#34;: false, \u0026#34;subUnit\u0026#34;: true }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/copy-app/",
	"title": "Kopier app i Altinn Studio",
	"tags": [],
	"description": "Slik oppretter man en kopi av applikasjon i Altinn Studio.",
	"content": "I Altinn Studio har man mulighet til å lage en kopi av en eksisterende applikasjon innad i en organisasjon. Dette gjøres fra dashboardet. Merk: for å ha mulighet til å lage en kopi i en org må du ha rettigheter til å opprette nye repositories. Medlemmer av teamene \u0026ldquo;Owners\u0026rdquo; og \u0026ldquo;Developers\u0026rdquo; har disse rettighetene. Dersom du mangler skrivetilgang må du ta kontakt med personen som har administratorrettigheter for din organisasjon.\n  Klikk på \u0026ldquo;\u0026hellip;\u0026quot;-ikonet i det øvre høyre hjørnet av app oversikten til applikasjonen du ønsker kopiere.\n  Velg \u0026ldquo;Lag kopi\u0026rdquo; fra menyen.\n  Legg inn navnet du ønsker den nye applikasjonen skal ha. Dette navnet brukes til å identifisere appen, og brukes også som navn på repository, og i URL-er og API-er. Navnet bør være kort og beskrivende som for eksempel \u0026ldquo;sykmelding\u0026rdquo; eller \u0026ldquo;lokalvalg-2019\u0026rdquo;. Navnet kan ikke endres etter at appen er publisert.\n  Opprett kopien ved å klikke \u0026ldquo;Lag kopi\u0026rdquo;.\n  Når applikasjonen har blitt kopiert vil du bli sendt til din nye applikasjon.\n  For at den kopierte applikasjonen skal være klar til å brukes trengs det en liten endring i koden. Denne endringen har automatisk blitt lagt inn som en pull request mot repositoriet ditt. For å navigere til repo klikk på profil-ikonet i høyre hjørne og velg \u0026ldquo;Åpne repository\u0026rdquo;.   Naviger så til fanen \u0026ldquo;Pull requests\u0026rdquo; og se at det ligger klar en pull request med navnet \u0026ldquo;Auto-generated: Final changes for cloning app.\u0026rdquo;.   Klikk deg inn på denne og se over at endringene stemmer overens med det nye navnet på applikasjonen din.\n  Om alt ser greit ut så kan endringen merges ved å klikke på \u0026ldquo;Merge pull request\u0026rdquo;.\n  Siste steget som trengs er nå å pulle endringene dine til studio. Naviger så til fanen med den ny appen din og klikk \u0026ldquo;Pull\u0026rdquo; for å hente endringene du nettopp merget.   Viola! Du er nå klar til å utvikle på den kopierte appen.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/create-app/",
	"title": "Opprette app i Altinn Studio",
	"tags": [],
	"description": "Slik oppretter man en ny applikasjon i Altinn Studio.",
	"content": "Altinn Studio brukes til å opprette applikasjoner (apps). En app kan være alt fra enkle skjemaer til større applikasjoner med både API-er og UI, og alt derimellom.\nDu lager en ny app fra dashboardet i Altinn Studio.\n Klikk på \u0026ldquo;ny app\u0026quot;-knappen i det øvre høyre hjørnet av dashboardet. Velg hvem som skal være eier av appen. Hvis du ikke har tilgang for noen organisasjoner, må du velge deg selv så du lager appen i din sandkasse. Legg inn navnet på appen. Dette navnet brukes til å identifisere appen, og brukes også som navn på repository, og i URL-er og API-er. Navnet bør være kort og beskrivende som for eksempel \u0026ldquo;sykmelding\u0026rdquo; eller \u0026ldquo;lokalvalg-2019\u0026rdquo;.\nNavnet kan ikke endres etter at appen er gått i produksjon. Opprett appen ved å klikke \u0026ldquo;Opprett\u0026rdquo;.  Når apppen er opprettet vil du videresendes til den nyopprettede appen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/migrate-services/",
	"title": "Migrere tjenester",
	"tags": [],
	"description": "Fra Altinn 2 til Altinn 3.",
	"content": "Migrere en eksisterende tjeneste til Altinn 3 Gjør deg kjent med Tjenesteeier-funksjonalitet i Altinn 3.\n Opprett bruker og app i Altinn Studio.\nNår bruker er opprettet kan du be om å bli en del av en organisasjon. Dette for å kunne samarbeide med andre i organisasjonen og ha tilgang til å kjøre deploy av apper. Utvikle app/tjeneste.\nHer finner du veiledninger som er nyttige når man utvikler en app i Altinn Studio. Se også punkt 9. Laste opp datamodell.\nDet er mulig å gjenbruke datamodeller som er basert på InfoPath uten for store endringer. Slik importerer du datamodellen i Altinn Studio. Kombiner UI editor og kodeverktøy.\nAltinn Studio UI editor gjør det enkelt å legge til og flytte skjema komponenter. Kodeverktøy er enklere å bruke når man skal redigere koden. Test lokalt.\nLokalt test miljø er en effektiv måte å teste apper uten å måtte kjøre en delploy. Test app i testmiljø.\nUnder fanen Deploy i Altinn Studio kan du bygge og deploye app. Når Appen er klart kan du logge inn i test miljøet med en testbruker for å kjøre tjenesten. Sette opp App i produksjonsmiljø og bestille om skjema-side.\nFør man setter app i produksjon må man ha tilgang til et produksjonsmiljø. Nyttig informasjon på om skjema-side gjør bruker av tjenesten selvhjulpen og Altinn brukerservice i stand til å hjelpe brukere. Tilrettelegge system for mottak av data.\nDet finnes standardiserte mønstre basert på REST-API for å sende og motta data fra/til dine interne systemer. Autentisering skjer med Maskinporten og du laster ned data ved pull fra database, og laster opp data direkte mot API i den enkelte applikasjon. Vår referanseapplikasjon Altinn CLI​ viser disse mønstrene og kan brukes for å komme i gang. Konvertere fra tjenster med Altinn2-converter.\nAltinn2-converter er et komandolinje basert verktøy for å konvertere Altinn 2 tjenester til Altinn 3 apps. Dette verktøyet har status som Proof of concept (POC) og kan derfor mangle en del funksjonalitet.  Lag en skisse av skjema For å migrere en utvalgt tjeneste kan det være nyttig å lage seg en skisse av tjenesten slik at man gjør seg kjent med designelementer i Altinn 3, og slik at man har en referanse å se til når man utvikler løsningen. Slik gjør du dette.\n\rVis/skjul innhold\r\rLage en skisse av skjema i Figma.\r\r\r Gå inn på nettsiden https://www.figma.com/ og lag deg en bruker. Figma kan installeres lokalt eller brukes i din nettleser. Altinn har et åpent design kit for eksterne og det finner du her. Gå inn på denne siden for å få mer informasjon om hvordan du kan komme i gang med Figma.  \r\r "
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/process/",
	"title": "Prosess",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API endepunkter for å lede en instans gjennom prosessen som er definert.",
	"content": "Overview All apps have a process definition that specifies start events, end events, tasks and the allowed flows (transitions) between these. A process is started by the application, which selects a start event to start and follows the sequence flow to the first task and creates a current task object to holde the process state.\nA process is represented by an process modell in BPMN/XML notation. Each task has an unique id, which is used to refer to the task in the api.\nProcess model Get the application\u0026rsquo;s process model.\nGET {appPath}/process Returns the bpmn file defining the process.\n\u0026lt;bpmn2:process id=\u0026#34;Process_1\u0026#34; isExecutable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;bpmn2:startEvent id=\u0026#34;StartEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn2:outgoing\u0026gt;Flow_1\u0026lt;/bpmn2:outgoing\u0026gt; \u0026lt;/bpmn2:startEvent\u0026gt; \u0026lt;bpmn2:task id=\u0026#34;Task_1\u0026#34; name=\u0026#34;Utfylling\u0026#34; altinn:tasktype=\u0026#34;data\u0026#34;\u0026gt;  \u0026lt;bpmn2:incoming\u0026gt;Flow_1\u0026lt;/bpmn2:incoming\u0026gt; \u0026lt;bpmn2:outgoing\u0026gt;Flow_2\u0026lt;/bpmn2:outgoing\u0026gt; \u0026lt;/bpmn2:task\u0026gt; \u0026lt;bpmn2:endEvent id=\u0026#34;EndEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn2:incoming\u0026gt;Flow_2\u0026lt;/bpmn2:incoming\u0026gt; \u0026lt;/bpmn2:endEvent\u0026gt; \u0026lt;bpmn2:sequenceFlow id=\u0026#34;Flow_1\u0026#34; sourceRef=\u0026#34;StartEvent_1\u0026#34; targetRef=\u0026#34;data_1\u0026#34; /\u0026gt; \u0026lt;bpmn2:sequenceFlow id=\u0026#34;Flow_2\u0026#34; sourceRef=\u0026#34;Task_1\u0026#34; targetRef=\u0026#34;EndEvent_1\u0026#34; /\u0026gt; \u0026lt;/bpmn2:process\u0026gt; Altinn specific task types Application developers can in their BPMN Definition specify some altinn specific task types, see altinn:tasktype, which signify the behaviour of the task. So far we have defined the following:\n data - user is asked to fill inn one or more data elements, e.g. upload data or fill in forms submit - user is asked if he should submit the information which has been filled in on previous tasks payment - user is asked to pay a specific amount signing - user is asked to provide a digital signature external - task is handled by an external entity, user must wait until they have completed the task.  Get process state of a specific instance GET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process For an ongoing process this process state can look like the json below. It indicates that the process was started at a given date time and that it\u0026rsquo;s current task is Task_1. The flow number indicates the sequence of process events/tasks that occurs during the execution of the process. Notice that same task can be visited multiple times in a process if there is a sequence flow that allows that.\n{ \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-10T32:22.00Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Fyll ut\u0026#34;, \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;validated\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2019-10-04T12:00.00Z\u0026#34;, \u0026#34;canCompleteTask\u0026#34;: true } } For an ended process the following will be returned:\n{ \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-10T14:01:22.034Z\u0026#34;, \u0026#34;endEvent\u0026#34;: \u0026#34;EndEvent_1\u0026#34; } Process events The system will generate a number of process related events, which can be found in the instances event history.\n Start Event StartTask Event EndTask Event End Event  Start Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:Start\u0026#34;, \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34; }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-10T14:01:22.034Z\u0026#34;, } StartTask Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:StartTask\u0026#34;,  \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-01T13:22.01Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Fyll ut MVA rapport\u0026#34;, \u0026#34;altinnTaskId\u0026#34;: \u0026#34;data\u0026#34; } }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-01T13:22.01Z\u0026#34;, } EndTask Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:EndTask\u0026#34;,  \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2017-10-01T13:22.00Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;altinnTaskId\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34; } }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34;, } End Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:EndEvent\u0026#34;,  \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2017-10-01T13:22.00Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-05T08:15:23.544Z\u0026#34;, \u0026#34;endEvent\u0026#34;: \u0026#34;EndEvent_1\u0026#34; }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-05T08:15:23.544Z\u0026#34;, } Get process history of a specific instance Based on the process events the history of the instance\u0026rsquo;s process is generated. The following illustrates an ended process:\nGET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/history \u0026#34;processHistory\u0026#34;: [ { \u0026#34;eventType\u0026#34;: \u0026#34;process_StartEvent\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;occured\u0026#34;: \u0026#34;2020-01-21T13:49:09.3109169Z\u0026#34; }, { \u0026#34;eventType\u0026#34;: \u0026#34;process_StartTask\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;started\u0026#34;: \u0026#34;2020-01-21T13:49:09.4264322Z\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2020-01-21T13:49:39.66609Z\u0026#34; }, { \u0026#34;eventType\u0026#34;: \u0026#34;process_EndEvent\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;EndEvent_1\u0026#34;, \u0026#34;occured\u0026#34;: \u0026#34;2020-01-21T13:49:39.7681248Z\u0026#34; } ] } Start Process To start a process one can post start to the process endpoint.\nPOST {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/start[?startEvent=StartEvent_1] This will start the process and move the process state to the first task from the given start. If process has more than one start event, then the client has to chose which one to start with the startEvent query parameter.\nComplete and move to next task The process logic attempts to finish the current task and then moves the process forward to the next task in the flow. The cannot always select the next task, especially when more than one tasks can be chosen. In this case the client must chose which process element id to select.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next[?id=Task_2] Complete the process The complete process method will attempt to complete the process for an instance. Hence, the app will move the process from one task to the next until it reaches an valid end state.\nIf a task\u0026rsquo;s exit condition is not met, the process will be stopped in the last valid task. And the user must manually fix the problem and complete the process.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/completeProcess Get the next tasks in a process Returns an list of the next tasks/events that can be reached from the current task.\nGET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next Start a task If you are at a specific task and want to start the next task you can try to put next to the process endpoint. The process controller then tries to close the current task and start the wanted task. Updates process state accordingly. If exit condition of current task is not met, an error will be returned. If the task is not directly reachable by the flow, an error will be returned.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next?id=Task_2 "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/apps/",
	"title": "Apps infrastruktur tilganger",
	"tags": [],
	"description": "Hvordan bestille tilganger til Altinn Apps infrastruktur.",
	"content": "Tilgang til logger og hemmeligheter Det er definert to forskjellige typer roller for tilgang i driftsmiljøene i Altinn Apps.\n Developer gir tilgang til Application Insights der applikasjonslogger samles for tjenesteeier sine applikasjoner i miljøet. Operations gir tilgang til Key Vault for å laste opp hemmeligheter som sertifikater, passord og api-nøkler.  Disse rollene er videre delt opp i tilgang til test (TT02) og produksjon (prod). En bruker kan tildeles en eller flere roller.\nTjenesteeiere kan bestille følgende tilganger for sine ressurser i miljøene TT02 og produksjon:\n Test Developer Test Operations Prod Developer Prod Operations  For å få aksess til disse rollene må autoriserte bestillere hos Tjenesteeier, bestille dette via skjemaet Apps på vår Selvbetjeningsportal under menyvalget Bestilling/tilganger.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/datafields/",
	"title": "Datafelter på instansobjektet",
	"tags": [],
	"description": "Konfigurasjon av datafelter for app.",
	"content": "I noen tilfeller kan det være nyttig å legge ekstra informasjon på instansobjektet f. eks. for å kunne basere ruting av instans til rett system i bakkant hos tjenesteeier.\nDette kan gjøres på to måter, ved konfigurasjon eller manuelt. Ved konfigurasjon vil systemet ekstrahere data fra skjemafeltene og legge disse på instansobjektet. Man er da begrenset til skjemafelter, men slipper å programmere dette selv. Hvis man velger å gjøre det manuelt har man frihet til å legge på de dataene man selv ønsker f. eks. fra eksterne apier, kalkuleringer, faste strenger etc.\nDet er også mulig å benyttes seg av begge metoder så lenge man benytter seg av forskjellige id\u0026rsquo;er på datafeltene. De konfigurerte verdiene vil da flettes sammen med de manuelle på instansen.\nDatafelter er på mange måter tilsvarende presentasjonsfelter. Men der hvor bruken av presentasjonsfelter er forhåndsbestemt (benyttes i meldingsboksen til Altinn), er bruken av datafelter opp til den enkelte applikasjonseier.\nKonfigurasjon Konfigurasjon av datafelter gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn dataFields med følgende underfelter\n   Navn Beskrivelse     id Id på datafeltet. Benyttes til å identifisere feltet når den er lagret på instansen.   path Datamodell path til skjemafeltet. Denne verdien er den samme som bindes til en komponent i layoutfilen til appen.   dataTypeId Id på datamodellen som verdien skal hentes fra.    Konfigurasjonen til en app med to definerte datafelter vil se slik ut:\n\u0026#34;dataFields\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;AnsettelseAntAar\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.Arbeidsforhold-grp-8856.AnsattAar-datadef-33267.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;Navn\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.OpplysningerOmArbeidstakeren-grp-8855.AnsattNavn-datadef-1223.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }] Resultatet vil være en liste på instansobjektet med verdier fra de konfigurerte feltete:\n\u0026#34;dataValues\u0026#34;: { \u0026#34;AnsettelseAntAar\u0026#34;: 10, \u0026#34;Navn\u0026#34;: \u0026#34;Ola Nordmann\u0026#34; } Legg merke til at det på instansobjektet heter dataValues mens når det konfigureres heter dataFields, det er fordi dataValueser resultatet av konfigureringen som gjøres på dataFields.\nManuelt For å legge til dataverdier manuelt benyttes metoden UpdateDataValues fra IInstance interfacet. Det er den samme metoden som kalles når dataverdier populeres fra konfigurasjon og den sørger for å flette sammen verdiene til en liste.\nMerk at det er applikasjonsutvikler sitt ansvar å sørge for unike id'er hvis man kombinerer dataverdier fra konfgiurasjon og manuelt.\rHar man ikke unike id'er vil verdier overskrives, og man har ingen garanti for hvilken som blir lagret på instansen.\r\rEksemplet under viser hvordan man kan sette datavedier manuelt. I dette tilfellet gjøres det ved å gjøre legge inn kode i RunProcessTaskEnd i App.cs som kjører når en task avsluttes.\npublic override async Task RunProcessTaskEnd(string taskId, Instance instance) { var customDataValues = new DataValues() { Values = new Dictionary\u0026lt;string, string\u0026gt;() { { \u0026#34;customKey\u0026#34;, \u0026#34;customValue\u0026#34; } } }; var (instanceOwnerPartyId, instanceGuid) = InstanceHelper.DeconstructInstanceIdFromUrl(_httpContextAccessor.HttpContext.Request.Path.Value); await _instanceService.UpdateDataValues(instanceOwnerPartyId, instanceGuid, customDataValues); await Task.CompletedTask; } Man bør også tenke gjennom når man trenger disse verdiene på instansobjektet slik at man ikke gjør unødvendige api kall og dermed får en dårligere ytelse på applikasjonen.\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/deploy/",
	"title": "Test app i testmiljø",
	"tags": [],
	"description": "Beskrivelse av hvordan test i testmiljø kan utføres.",
	"content": "Klargjøring av app og deploy til testmiljø gjøres fra Deploy-fanen i Altinn Studio.\nBygge app Før en app kan deployes til testmiljø, må alle nødvendige filer samles sammen i en pakke som kan deplpoyes. Dette gjøres ved å bygge appen.\nMerk at det er filene fra app-repoet som benyttes i bygget. Dersom en har gjort endringer på en app i Altinn Studio så må disse sendes til repoet for at endringene skal bli med i bygg-pakken.\rDette gjøres ved å velge _Push_ fra _Lage_-fanen i Altinn Studio.\r\rNår en app er klar til test, kan den bygges ved å gå til Deploy-fanen i Altinn Studio (inne på den appen som skal deployes).\nPå høyre side vises et panel for å bygge appen.\nMerk at det kun er mulig å bygge ny versjon av appen dersom det faktisk er gjort endringer i appen. Dersom det er gjort endringer og det ikke er mulig å bygge ny versjon, pass på at endringene har blitt sendt til app repoet.\r\r Skriv inn versjonsnummer for den versjonen av appen som skal bygges. Må være unikt (altså ikke brukt tidligere for denne appen). Skriv inn beskrivelse for denne versjonen av app\u0026rsquo;en. Trykk på Bygg versjon for å starte bygget.  Status for bygget vises under Tidligere bygg av applikasjonen. Når status er grønn, er denne versjonen av app\u0026rsquo;en klar til å bli deployet til testmiljø.\nDeploy av app til testmiljø Når en app er bygget ferdig kan den deployes til testmiljø. Dette gjøres fra Deploy-fanen. Der vises en oversikt over tilgjengelige miljø, i tilegg til en oversikt over hvilke versjoner av appen som er i de forskjellige miljøene.\n Velg versjonen av appen som skal deployes fra nedtrekkslisten som ligger under det aktuelle miljøet. Trykk på Deploy ny versjon.  Valgt versjon vil da deployes til valgt miljø. Her er det mulig å deploye ny versjon, eller rulle tilbake til en eldre versjon om det er ønsket.\nTeste app i testmiljø Logg inn i testmiljø med testbruker. Bruk lenken som vises over hvert miljø i Deploy-fanen for å komme til ønsket testmiljø og starte ny instans av appen.\nAlle instanser vil være synlig i meldingsboks/arkiv til valgt aktør, på samme måte som dagens tjenester (som er basert på Altinn II).\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/id-porten/",
	"title": "Autentisere med ID-porten",
	"tags": [],
	"description": "Beskrivelse av hvordan systemer kan benytte ID-porten for å få tilgang til APIer i Altinn 3.",
	"content": "Systemer for sluttbrukere kan autentisere brukere via ID-porten. Dette for å kunne benytte API fra applikasjoner kjørende i Altinn Apps og enkelte funksjoner i Altinn Platform på vegne av sluttbruker.\nDet er i hoveddsak to typer systemer hvor dette er aktuelt. Dette er webbaserte løsninger og tykke klienter.\nFelles for begge løsninger er at sluttbruker vil logge inn via nettleser i ID-porten med den autentiseringsmekanismen de ønsker.\nDette er for eksempel:\n Min-ID BankID på mobil BankId  Systemet må forespøre et sett med scopes i ID-porten som sluttbruker må akseptere at systemet kan utføre på vegne av sluttbruker.\nDet er disse scopene som tildels avgrenser hva systemet kan utføre på vegne av sluttbruker.\nScopene som er definert og relevant for Altinn 3 er:\n altinn:instances.meta - Se oversikt over innboks og arkiv i Altinn altinn:instances.read - Lese innholdet i innboks og arkiv i Altinn for alle elementer som sluttbruker er autorisert for altinn:instances.write - Fylle ut, signere og sende inn skjema i Altinn for alle elementer sluttbruker er autorisert for altinn:lookup - Benytte innsynstjenester i Altinn altinn:reportees - Se hvem du kan representere i Altinn  Bildet nedenfor viser hvordan sluttbruker må bekrefte tilgangen.\nFor detaljer om scope og opplisting av alle scopes tilgjengelig se dokumentasjon fra ID-porten.\nDet er disse scopene som avgjør hva sluttbruker kan utføre. Bildet nedenfor viser hvordan sluttbruker må bekrefte tilgangen.\nNår pålogging er gjennomført vil systemet ha tilgang til et ID-token, refresh token og et access token.\nDette access tokenet har begrenset levetid, men kan fornyes med ved hjelp av refresh token.\nWeb baserte systemer Webbaserte systemer består av løsninger med en webbasert frontend som kjører i nettleser, samt serverside kode.\nSe detaljer hos ID-porten.\nTykke klienter Med tykke klienter mener vi applikasjoner som installeres og kjøres lokalt på en datamaskin og ikke i nettleser.\nDisse må likevel benytte seg av nettleser for å logge inn.\nSe detaljer hos ID porten.\nVeksling av access token til Altinn token Access-tokenet som utstedes fra ID-porten må veksles inn i et Altinn-token før det kan benyttes mot Altinns API\u0026rsquo;er.\nDette Altinn-tokenet vil ha samme levetid som access-tokenet.\nFlytdiagrammet nedenfor viser hvordan tokenet veksles inn.\nSe detaljer i Altinns API dokumentasjon.\nSluttbrukere har i Altinn mulighet til å få oversikt over alle systemer og hvilke tilganger de har.\nPå denne måten kan man trekke langvarige tilganger. Systemet vil da bli avvist neste gang det prøver å refresehe access-token.\nBildet nedenfor viser hvordan dette vil bli i Altinn (ikke satt i produksjon enda).\nEt system som har fått tilgang til et token fra ID-porten vil kunne utføre handlinger som bruker er autorisert kun begrenset av bruksområdet til scope. Det betyr at hvis system har fått scope for innsending av skjema så vil systemet kunne sende inn alle skjema for alle avgivere som sluttbruker er autorisert for. Det er derfor viktig at sluttbruker kan stole på systemet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/instance-events/",
	"title": "Instance events",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Plattform API for å jobbe med instans-hendelser.",
	"content": "Instance events All instance events, e.g. creation, read, save, change process state, \u0026hellip;\nGET {storagePath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/events Example of event data.\n{ \u0026#34;id\u0026#34;:\u0026#34;6dff32bc-0928-4ae8-937c-b362d6941c89\u0026#34;, \u0026#34;instanceId\u0026#34;: \u0026#34;60238/5c6b1a71-2e1f-447a-ae2f-d1807dcffbfb\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;deleted\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-05-02T13:08:21.981476Z\u0026#34;, \u0026#34;instanceOwnerPartyId\u0026#34;: \u0026#34;60238\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;userId\u0026#34;: 338829, \u0026#34;authenticationLevel\u0026#34;: 1, \u0026#34;enduserSystemId\u0026#34;: 2 }, \u0026#34;process\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-05-01T12:45:01.3233Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;Start_22\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;elementId\u0026#34;: \u0026#34;Task_2\u0026#34; } } } Application events (for application owners)  WARNING: This section will be redesigned\n Selected instance events. Created, first read, change process state. Optinally specified by application developer.\nEvents can be queried. May be piped.\nGET {storagePath}/applications/org/app/events?created=gte:2019-03-30\u0026amp;process.currentTask=Task_2 "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/",
	"title": "Navigasjon i Altinn Studio",
	"tags": [],
	"description": "Slik navigerer du mellom de ulike delene av Altinn Studio.",
	"content": "Som bruker av Altinn Studio kan du bruke ulike verktøy, avhengig av kompetanse, preferanser og kompleksiteten på det du skal utvikle. Hvordan du navigerer er ulikt mellom verktøyene.\n\rDesigner\rSlik navigerer du i Altinn Studio Designer.\n\r\rRepos\rSlik navigerer du i Altinn Studio Repos.\n\r\rCode\rSlik navigerer du i Altinn Studio Code.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/presentationfields/",
	"title": "Presentasjonsfelter i meldingsboksen",
	"tags": [],
	"description": "Konfigurasjon av presentasjonsfelter for app.",
	"content": "I noen tilfeller kan det være nyttig med presentasjonsfelter for å enklere kunne skille mellom flere instaner av samme applikasjon.\nVed å konfigurere presentasjonsfelter på en applikasjon vil man hente ut verdier fra skjemadataene og legge dette på instansobjektet. Disse verdiene benyttes i meldingsboksen i Altinn til å berrike tittelen til instansen med dataverdiene.\nKonfigurasjon Konfigurasjon av presentasjonsfelter gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn presentationField med følgende underfelter\n   Navn Beskrivelse     id Id på presentasjonsfeltet. Benyttes til å identifisere presentasjonsteksten når den er lagret på instansen.   path Datamodell path til presentasjonsfeltet. Denne verdien er den samme som bindes til en komponent i layoutfilen til appen.   dataTypeId Id på datamodellen som verdien skal hentes fra.    Konfigurasjonen til en app med to definerte presentasjonsfelter vil se slik ut:\n\u0026#34;presentationFields\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Ansettelse\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.Arbeidsforhold-grp-8856.AnsattAar-datadef-33267.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;Navn\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.OpplysningerOmArbeidstakeren-grp-8855.AnsattNavn-datadef-1223.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }], Resultatet i meldingsboksen vil være tittel på applikasjonen med påfølgende presentasjonstekster i en kommaseparert liste.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/prefill/",
	"title": "Preutfylling av data (prefill)",
	"tags": [],
	"description": "Hvordan konfigurere prefill for en app.",
	"content": "Altinn tilbyr i dag tre fremgangsmåter for å preutfylle data i en app for en sluttbruker. Disse metodene kan kombineres fritt for å oppnå ønsket resultat\nPrefill fra nasjonale register og brukerprofil Altinn apps støtter prefill med data fra Enhetsregisteret, Folkeregisteret og brukerprofil i Altinn.\nVed å følge beskrivelsen nedenfor vil man under instansiering av et skjema preutfylle datamodellen med de definerte verdiene hentet fra Altinns database.\nOppsett av prefill i applikasjons repository Opprett en ny json-fil i app repoet under App/models. Navnet på filen skal inneholde navnet på datamodellen og ha postfix \u0026ldquo;.prefill.json\u0026rdquo;. Dersom datamodellen din heter appModel skal du nå kunne finne disse tre filene i mappen: appModel.metadata.json, appModel.schema.json, appModel.prefill.json\nLim inn innholdet nedenfor i filen.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/prefill/prefill.schema.v1.json\u0026#34;, \u0026#34;allowOverwrite\u0026#34;: true, \u0026#34;ER\u0026#34;: { }, \u0026#34;DSF\u0026#34;: { }, \u0026#34;UserProfile\u0026#34;: { } } Konfigurering av prefill.json   $schema peker på json schema definisjonen til filen. Nåværende versjon er v1.\nVisual Studio Code vil pga. denne validere og tilby intellisense/autocomplete når du editerer filen lokalt.\n  allowOverwrite avgjør om prefill definert i denne filen kan overskrive et felt i datamodellen dersom det allerede har en verdi.\n  ER her legger man inn felter fra datamodellen som skal preutfylles med data fra enhetsregisteret. Felt som preutfylles med ER-data vil kun få en verdi dersom man instansierer på vegne av en organisasjon. Instansiering vil feile dersom man forsøker å preutfylle ER-data, men ikke har en organisasjon tilgjengelig.\n  Eksempelet nedenfor vil populere feltet Datamodell.Organisasjon.Organisasjonsnummer med organisasjonsnummeret hentet fra enhetsregisteret.\n\u0026#34;ER\u0026#34;: { \u0026#34;OrgNumber\u0026#34;:\u0026#34;Datamodell.Organisasjon.Organisasjonsnummer\u0026#34; }  DSF her legger man inn felter fra datamodellen som skal preutfylles med data fra folkeregistret. Feltet som preutfylles med DSF-data vil kun få en verdi dersom man instansierer på vegne av en person. Instansiering vil feile dersom man forsøker å preutfylle DSF-data, men ikke har en person tilgjengelig.  Eksempelet nedenfor vil populere feltet Datamodell.Person.Nummer med telefonnummer henter fra folkeregistret.\n\u0026#34;DSF\u0026#34;: { \u0026#34;TelephoneNumber\u0026#34;:\u0026#34;Datamodell.Person.Nummer\u0026#34; }  UserProfile her legger man inn telter fra datamodellen som skal preutfylles med data fra brukerens profil i Altinn. Merk at det er den innloggede brukeren om instansierer man henter ut data for.  Eksempelet nedenfor vil populere feltet _Datamodell.Bruker.Epost med epost hentet fra brukerens profil i Altinn.\n\u0026#34;UserProfile\u0026#34;: { \u0026#34;Email\u0026#34;:\u0026#34;Datamodell.Bruker.Epost\u0026#34; } Tilgjengelige prefill verdier JSON-schema definisjonen av prefill-filen er også tilgjengelig her.\nBruken av et schema gjør at editorer, f.eks. Visual Studio Code, kan validere og tilby intellisense for raskere editering.\nFolkeregisteret Personedataen som eksponeres er den tilknyttet personen som skjemaet instansieres på vegne av. Dersom Ola Nordman instansierer et skjema på vegne av Kari Nordmann vil det være Kari sin data som eksponeres. Tilgjengelige verdier for prefill inkluderer:\n SSN Name FirstName MiddleName LastName TelephoneNumber MobileNumber MailingAddress MailingPostalCode MailingPostalCity AddressMunicipalNumber AddressMunicipalName AddressStreetName AddressHouseNumber AddressHouseLetter AddressPostalCode AddressCity  Enhetsregisteret Enheten som eksponeres er den tilknyttet organisasjons som et skjema blir instansiert på vegne av. Tilgjengelige verdier for prefill inkluderer:\n OrgNumber Name UnitType TelephoneNumber MobileNumber FaxNumber EMailAddress InternetAddress MailingAddress MailingPostalCode MailingPostalCity BusinessAddress BusinessPostalCode BusinessPostalCity  Brukerprofil Brukerprofilen som eksponeres er profilen til den som instansierer tjenesten. Dersom Ola Nordmann instansierer et skjema på vegne av Kari Nordmann vil dataen som hentes ut herfra være knyttet til Ola. For objektene Party.Organization og Party.Person vil man finne igjen samme feltene som man ser i ER og DSF-prefill. Merk at Party.Organization vil være null om brukeren er logget inn som en privatperson, og tilsvarende for Party.Person om man er logget inn med en virksomhetsbruker. Preutfyllingen vil feile om objektet man preutfyller fra ikke finnes, så om man ønsker å dynamisk preutfylle basert på disse verdiene må dette settes opp som egendefinert prefill.. Tilgjengelige verdier for prefill inkluderer:\n UserId UserName PhoneNumber Email PartyId Party.PartyId Party.PartyTypeName Party.OrgNumber Party.SSN Party.UnitType Party.Name Party.isDeleted Party.OnlyHierarchyElementWithNoAccess Party.Person Party.Organization Party.ChildParties UserType ProfileSettingPreference.Language ProfileSettingPreference.PreSelectedPartyId ProfileSettingsPreference.DoNotPromptForParty  Egendefinert prefill Altinn apps muliggjør prefill av en instans med egendefinert data, det være seg resultet fra et API-kall, beregninger gjort under instansiering, eller annen logikk. Dette implementeres i metoden DataCreation i filen InstansiationHandler.cs som finnes i applikasjonsrepoet under App/logic.\nEksempelet nedenfor populerer feltet Bruker.FulltNavn i modellen Datamodell med verdien \u0026ldquo;Test Testesen\u0026rdquo;.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; model.Bruker.FulltNavn = \u0026#34;Test Testesen\u0026#34;;  } } Bytt ut Datamodell med navnet på C# klassen som er blitt generert basert på xsd-en som ble lastet opp i Altinn Studio. Dersom du bruker en egnet kodeeditor vil du kunne definere felter som skal populeres ved bruk av intellisense.\nVær oppmerksom på at dersom du har komplekse typer i modellen din, må disse instansieres før man kan tilegne en verdi til ett av typens underelementer. Se eksempel nedenfor der vi legger til grunn at \u0026lsquo;Bruker\u0026rsquo; og \u0026lsquo;Name\u0026rsquo; er egne C# klasser.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; Bruker b = new Bruker(); b.Navn = new Name(); b.Navn.FulltNavn = \u0026#34;Test Testesen\u0026#34;; } } Instansiering med prefill Altinn apper støtter instansiering med prefill. Skjemadataen legges ved i en multipart i instansieringsrequesten som sendes til appen. Nedenfor ser du et eksempel på en request for å instansiere en app med prefill for partyId 12345.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; Body: --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;PartyId\u0026#34; : \u0026#34;12345\u0026#34;  } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;Endring-av-navn\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;1533\u0026#34; spesifikasjonsnummer=\u0026#34;11172\u0026#34; blankettnummer=\u0026#34;RF-1453\u0026#34; tittel=\u0026#34;Endring av navn\u0026#34; gruppeid=\u0026#34;9308\u0026#34;\u0026gt; \u0026lt;Innledning-grp-9309 gruppeid=\u0026#34;9309\u0026#34;\u0026gt; \u0026lt;NavneendringenGjelderFor-grp-9310 gruppeid=\u0026#34;9310\u0026#34;\u0026gt; \u0026lt;SubjektFornavnFolkeregistrert-datadef-34730 orid=\u0026#34;34730\u0026#34;\u0026gt;Ola Nordmann\u0026lt;/SubjektFornavnFolkeregistrert-datadef-34730\u0026gt; \u0026lt;/NavneendringenGjelderFor-grp-9310\u0026gt; \u0026lt;Kontaktinformasjon-grp-9311 gruppeid=\u0026#34;9311\u0026#34;\u0026gt; \u0026lt;MelderFultnavn orid=\u0026#34;34735\u0026#34;\u0026gt;LANGØY MADS\u0026lt;/MelderFultnavn\u0026gt; \u0026lt;/Kontaktinformasjon-grp-9311\u0026gt; \u0026lt;/Innledning-grp-9309\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/",
	"title": "Definere applikasjonsprosess",
	"tags": [],
	"description": "Hvordan definere prosessen til en app.",
	"content": "En applikasjon har definert en prosess som styrer flyten. Prosessen er definert som BPMN 2.0.\nStøttede prosess-task-typer Nåværende applikasjonsmal støtter følgende tasks.\n Data (Data) (Tilsvarer utfyllingssteg i Altinn II) Bekreftelse (Confirmation) Feedback  Fremtidige prosess-tasker (tentativ)  Signering (Signing) Betaling (Payment) Parallellsignering (Paralell Signing) Brukerstyrt signering (User Controlled Signing) Ekstern validering (External Validation)  Endre prosessen For å endre på prosessen kan du manuelt redigere BPMN-filen med en valgfri XML- eller BPMN-editor. Den ligger lagret i app-repoet som App/config/process/process.bpmn.\n\rAutomatisk sletting\rEn applikasjon kan konfigureres til å slette alle spor når prosessen er slutt.\n\r\rMelding\rHvordan sette opp en melding i Altinn Studio.\n\r\rTilpasse visninger av steg\rHvordan tilpasse visninger i forskjellige steg av en prosess.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/repos/",
	"title": "Repos",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Repos.",
	"content": "Repos er verktøyet der appene er lagret som Git repositoryer, og kan bli funnet på https://altinn.studio/repos.\nHovedmeny Hovedmenyen øverst inneholder disse elementene:\n Altinn-logoen - tilbake til Altinn Studio-dashboardet. Dashboard - Lister ut dine aktiviteter og de repositoryene og organisasjonene du har tilgang til. Du kan også se dashboard for den enkelte organisasjonen. Issues - Lister ut åpne og lukkede issues som er relevant for deg. Pull requests - Lister ut åpne og lukkede pull requests som er relevant for deg. Utforsk - Gir deg tilgang til å se alle repositoryer, brukere og organisasjoner  Navigere innad i et repository Når du har navigert til et repository dukker det opp et nytt sett menyvalg som er relevant for repositoryet.\n Kode - innholdet, alle filer appen består av Issues - \u0026ldquo;saker\u0026rdquo; for repositoryet Pull Requests - for repositoryet Releases - opprettet for repositoryet Aktivitet - hva har skjedd i repositoryet  Hvis du vil til Designer for det aktuelle repositoryet, er det et valg for dette i toppmenyen:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/studio/",
	"title": "Altinn Studio tilganger",
	"tags": [],
	"description": "Hvordan konfigurere tilganger for team i Altinn Studio.",
	"content": "Tilgangsstyring for organisasjonen Som eier av en organisasjon i Altinn Studio har man mulighet til å konfigurere tilgangene til de øvrige brukerne knyttet til organisasjonen. Dette gjøres via Gitea på følgende lenke: https://altinn.studio/repos/org/{organisasjonens kortnavn}/teams/\nDet er definert fire standard team som legger føringer for hva en bruker har tillatelse til å gjøre innad i en organisasjon i Altinn Studio. Ved behov kan man som eier kan man legge til/fjerne brukere i team, opprette nye team og endre konfigurasjon på eksisterende team.\nOwners Beskrivelse Medlemmer i dette teamet kan tenkes på som administrator for organisasjonen. De vil kunne administrere tilgangsstyringen for alle team og repositories knyttet til organisasjonen.\nSom medlem i dette teamet kan man blant annet:\n opprette/slette team legge til og fjerne brukere i ulike team endre konfigurasjon for team  Konfigurasjon Dette teamet ligger inne som standard i alle organisasjoner og det er ikke mulig å endre konfigurasjonen for dette teamet.\nDeploy-Prod Beskrivelse Medlemmer i dette teamet kan deploye applikasjoner til produksjonsmiljøet.\nØvrige rettigheter kan defineres fritt av owners. Default konfigurasjon inkluderer rettigheter for:\n Lesetilgang i samtlige repositories Kan ikke opprette nye repositories Full tilgang til alle områder i Gitea  Konfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, muligheten til å deploye til testmiljø er ikke avhengig av øvrig config.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\n Lese samtlige repositories Aksessere alle områder i Gitea  Deploy-TT02 Beskrivelse Medlemmer i dette teamet kan deploye applikasjoner til testmiljøet.\nØvrige rettigheter kan defineres fritt av owners. Default konfigurasjon inkluderer rettigheter for:\n Lesetilgang i samtlige repositories Kan ikke opprette nye repositories Full tilgang til alle områder i Gitea  Konfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, muligheten til å deploye til testmiljø er ikke avhengig av øvrig config.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\n Lese samtlige repositories Aksessere alle områder i Gitea  Devs Beskrivelse Medlemmer i dette teamet jobber med å utvikle applikasjoner og har tilgang til samtlige repositories.\nKonfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, avhengig av hvor mye frihet man ønsker at apputvikleren skal ha. Merk at det blant annet er mulig å spesifisere hvilke(t) repository teamet skal ha tilgang til.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\n Opprette nye repositories Skrive til samtlige repositories Aksessere alle områder i Gitea  Tilgangsstyring for repository [Mer informasjon kommer]\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/",
	"title": "Tilganger",
	"tags": [],
	"description": "Hvordan man får tilganger til Altinn Studio, hemmeligheter og applikasjonslogger.",
	"content": "\r\rApps infrastruktur tilganger\rHvordan bestille tilganger til Altinn Apps infrastruktur.\n\r\rAltinn Studio tilganger\rHvordan konfigurere tilganger for team i Altinn Studio.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/validation/",
	"title": "Validering",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Validering API-endepunktene for instanser og dataelementer.",
	"content": "Overview There are multiple endpoints that can trigger validation and provide feedback regarding the state of an instance and its data. Some of them validates data already uploaded and stored in Altinn while others can validate input.\nValidate stored instance This action will validate an entire instance including the all data elements already uploaded and stored in Altinn. Validation will be performed based on current task in the process. Validation will ensure that all required data elements, as defined by the application metadata, have been uploaded and are valid. If the result of the validation is that nothing is missing or wrong, the action will update the instance with information indicating that the instance is valid. The response will be an empty array. In the case of validation issues the response will provide an array of the identified issues. Validation of a full instance use validation of data as described in the chapter below.\nGET https://{org}.apps.at21.altinn.cloud/{org}/{app}/instances/{instanceOwnerPartyId}/{instanceId}/validate Example response:\n[ { \u0026#34;severity\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;INSTANCE\u0026#34;, \u0026#34;targetId\u0026#34;: null, \u0026#34;field\u0026#34;: null, \u0026#34;code\u0026#34;: \u0026#34;TooManyDataElementsOfType\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;TooManyDataElementsOfType\u0026#34; } ] Validate stored data This action will validate a specific data element already uploaded and stored in Altinn. The logic validates that the data element has the correct Content-Type, that it isn\u0026rsquo;t too large and so on. Data elements with a model bound to them will be validated against the model (Schema).\nValidation will also check that the data element being validated is required for the current task in the process. If the data is validated during a task different from what is intended, the validator will give a warning.\nGET https://{org}.apps.at21.altinn.cloud/{org}/{app}/instances/{instanceOwnerPartyId}/{instanceId}/data/{dataid}/validate Example response:\n[ { \u0026#34;severity\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;targetId\u0026#34;: null, \u0026#34;field\u0026#34;: null, \u0026#34;code\u0026#34;: \u0026#34;MissingContentType\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MissingContentType\u0026#34; } ] Validate data The application will provide a method to validate the datamodel without creating a instance of the data. Data must be provided as formdata. The validate method takes a data file of an dataType and performs validation on that file. It returns a validation report.\nPUT {appPath}/validate?dataType=modelA "
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/",
	"title": "Autentisering",
	"tags": [],
	"description": "Beskrivelse av hvordan systemer og tjenesteeiere kan benytte Maskinporten eller ID-porten for å få tilgang til APIer i Altinn 3.",
	"content": "\r\rAutentisere med Maskinporten\rBeskrivelse av hvordan tjenesteeiers systemer kan benytte Maskinporten for å få tilgang til APIer.\n\r\rAutentisere med ID-porten\rBeskrivelse av hvordan systemer kan benytte ID-porten for å få tilgang til APIer i Altinn 3.\n\r\rDelegere API-tilganger til en leverandør\rBeskrivelse av hvordan tjenesteier kan delegere API-tilganger (scopes) til en underleverandør.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/code/",
	"title": "Code",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Code.",
	"content": "Selv om vi har støtte for å redigere kode og konfigurasjonsfiler direkte i Altinn Studio Repos, er det ofte mer behagelig å gjøre det lokalt på din maskin.\nFor å gjøre dette må du laste ned og installere et koderedigeringsverktøy.\nVi anbefaler Visual Studio Code, men det er fritt fram hvilket verktøy du velger.\nFinne adressen til et repo URL-en til et gitt app repository er strukturert slik, så bytt ut owner og repo-navn:\nhttps://altinn.studio/repos/owner/repo.git.\nDu kan finne URL-en ved å navigere til repositoryet. Klikk ikonet til høyre for å kopiere.\nDu kan også finne samme URL i en popup i Designer hvis du klikker på \u0026ldquo;Clone\u0026rdquo;-knappen.\nKlone koden Etter at du har åpnet Visual Studio Code, åpne den integrerte terminalen (ctrl + ø) og skriv klone-kommandoen. Husk å få med riktig organisasjon og repo-navn.\ngit clone https://altinn.studio/repos/owner/repo Om du ikke er kjent med Visual Studio Code eller Git arbeidsflyt, er det god dokumentasjon her:\nhttps://code.visualstudio.com/docs/getstarted/introvideos https://code.visualstudio.com/docs/editor/versioncontrol#_git-support\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/secrets/",
	"title": "Hemmeligheter",
	"tags": [],
	"description": "Hvordan håndtere hemmeligheter og sensitiv data i en app.",
	"content": "Administrasjon av hemmeligheter i Azure Som applikasjonsutvikler administrerer man selv hemmelighetene som applikasjonen benytter i Azure Key Vault.\nRutiner for bestilling av tilgang til din organisasjons ressurser er beskrevet her.\nKonfigurer støtte for hemmeligheter i din app For å kunne benytte hemmeligheter i din applikasjon må du bruke nugetversjon \u0026gt;= 1.2.2. Se hvordan du oppdaterer nugetreferanser for applikasjonen din her.\n  Oppdater helm charts for å koble opp rett konfigurasjon til din\nI applikasjonsrepoet ditt finner du filen values.yaml i mappen deployment.\nUnder seksjonen volumeMounts legger du til følgende linjer:\n- name: altinn-appsettings-secret mountPath: \u0026#34;/altinn-appsettings-secret\u0026#34; Under seksjonen volumes legger du til følgende linjer:\n- name: altinn-appsettings-secret secret: secretName: altinn-appsettings-secret OBS! Vær påpasselig med antall linjeskift og innrykk når du jobber i values.yaml.\nSiste del av filen skal se omtrent slik ut når du har gjort ferdig alle endringer.\n  Videre må konfigurasjonen som ligger i appclusteret knyttes til den kjørende tjenesten\nI applikasjonsrepoet ditt finner du filen Program.cs i mappen App.\nI metoden CreateHostBuilder skal det kalles på en metode som vil laste opp konfigurasjon for hemmeligheter.\nDu kan bytte ut hele metoden med kodesnuten nedenfor.\npublic static IHostBuilder CreateHostBuilder(string[] args) =\u0026gt; Host.CreateDefaultBuilder(args) .ConfigureWebHostDefaults(webBuilder =\u0026gt; { webBuilder.ConfigureAppConfiguration((hostingContext, configBuilder) =\u0026gt; { configBuilder.LoadAppConfig(); }); webBuilder.UseStartup\u0026lt;Startup\u0026gt;(); }); I tillegg må man importere biblioteket der configBuilder.LoadAppConfig er implementert. Lim inn følgende øverst i filen.\nusing Altinn.App.PlatformServices.Extensions;   I applikasjonsrepoet ditt finner du filen Startup.cs i mappen App.\nI metoden ConfigureServices skal det kalles på en metode som vil tilgjengeliggjøre konfigurasjon samt en klient for å hente tjeneser for applikasjonens ulike klasser.\nLim inn følgende et sted i denne metoden. Gjerne der andre kall til services blir gjort.\nservices.AddAppSecrets(Configuration, _env);   Forsikre deg om at applikasjonen din fortsatt bygger og at deploy via Altinn Studio enda er mulig. Din applikasjon er nå klar til å benytte hemmeligheter!\n  Hvordan benytte hemmeligheter i applikasjonen Servicen ISecret er eksponert i applikasjonen og kan dependency injectes i den klassen der du har behov for å hente ut en hemmelighet.\nLokal mock For å kunne kjøre tjenesten din lokalt uten å koble seg til Azure Key vault må man opprette filen secrets.json under mappen App. I Json strukturen kan man legge inn dummydata for hemmelighetene man har behov for. Har man lastet opp en hemmelighet i Key Vault med navnet \u0026ldquo;secretId\u0026rdquo; vil innholdet i json-filen se slik ut\n{ \u0026#34;secretId\u0026#34;: \u0026#34;local cecret dummy data\u0026#34; } Type hemmeligheter Secret - lagres som en streng direkte i keyvault. F.eks et sertifikat som er base64 encoded eller et token. Key - Nøkkel Certificate - et sertifikat\nKodeeksempel I denne seksjonen finner du et eksempel på hvordan man benytter en hemmelighet til å populere et skjemafelt under instansiering.\nLogikken er implementert i InstantiationHandler.cs\nusing Altinn.App.Models; using Altinn.App.Services.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; using System.Threading.Tasks; namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; private ISecrets _secretsService; /// \u0026lt;summary\u0026gt;  /// Set up access to profile and register services  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;profileService\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;registerService\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public InstantiationHandler(IProfile profileService, IRegister registerService, ISecrets secretsService) { _profileService = profileService; _registerService = registerService; _secretsService = secretsService; } /// \u0026lt;summary\u0026gt;  /// Run events related to instantiation  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;remarks\u0026gt;  /// For example custom prefill.  /// \u0026lt;/remarks\u0026gt;  /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;Instance information\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data object created\u0026lt;/param\u0026gt;  public async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Skjema)) { Skjema model = (Skjema)data; model.etatid = await _secretsService_.GetSecretAsync(\u0026#34;secretId\u0026#34;); } await Task.CompletedTask; } } }   Den private variabelen for servicen inkluderes i klassen\nprivate ISecrets _secretsService;   ISecrets servicen dependency injectes inn i klassen. Og den private variabelen blir assignet en verdi.\npublic InstantiationHandler(IProfile profileService, IRegister registerService, ISecrets secretsService) { _profileService = profileService; _registerService = registerService; _secretsService = secretsService; }   I metoden der man har behov for hemmeligheten kaller man på servicen. secretId vil være navnet på hemmeligheten i KeyVault evt. i lokal mock.\nawait _secretsService_.GetSecretAsync(\u0026#34;secretId\u0026#34;);   Dersom du prøver å bygge løsningen nå vil det feile.\nISecrets vil mangle der InstantiationHandler instansieres. Naviger til App.cs og dependency inject servicen inn i konstruktøren til App.\nVidere må tjenesten legges til i kallet der InstantiationHandler instansieres som vist nedenfor.\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, ISecrets secretsService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService, secretsService); }   "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/options/",
	"title": "Kodelister (options)",
	"tags": [],
	"description": "Hvordan konfigurere options/kodelister for en app.",
	"content": "Altinn tilbyr i dag to ulike måter en app kan eksponere kodelister. Dette gjøres gjennom et options-api som er eksponert av appen, og kodelisten vil være tilgjengelig på endepunktet {org}/{app}/api/options/{optionsId}. Dropdown-komponenten vil automatisk kunne hente ut en slik liste om man kobler denne komponenten til en options-id.\nStatisk kodeliste fra app-repo Ved å legge json-lister i options mappen i app repo vil appen automatisk lese denne filen og eksponere det gjennom options-apiet. Options filene må ligge under App/options/ og vil bli differensiert ved hjelp av navngivningen på json-filen. F.eks land.json. Her vil da optionsId være land, og vil være eksponert gjennom endepunktet {org}/{app}/api/options/land. Kodelistene må være på et spesifikt format. Eksempel på en kodeliste som inneholder land (App/options/land.json):\n[ { \u0026#34;value\u0026#34;: \u0026#34;norway\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Norge\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;denmark\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Danmark\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;sweden\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;country.label.sweden\u0026#34; } ] label feltet kan inneholde en tekstnøkkel til teskstressursene eller ren tekst.\nKodeliste generert runtime I app-templaten har man også mulighet til å dynamisk eksponere/endre kodelister under kjøringen av appen. Dette muligjør det å eksponere dynamiske verdier som en del av kodelisten, og settes opp i metoden GetOptions i App.cs. Denne metoden vil bli kalt i det appen får et kall mot options-apiet, og man kan selv velge å returnere det objektet man ønsker.\nUnder finner du et eksempel på hvordan dette kan settes opp. Her vil man få ut den oppsatte kodelisten i det appen får et kall mot {org}/{app}/api/options/demo_id.\npublic override Task\u0026lt;AppOptions\u0026gt; GetOptions(string id, AppOptions options) { if (id.Equals(\u0026#34;demo_id\u0026#34;)) { var demoOptions = new AppOptions { Options = new List\u0026lt;AppOption\u0026gt; { new AppOption { Label = \u0026#34;Some label\u0026#34;, Value = \u0026#34;Some value\u0026#34; }, new AppOption { Label = \u0026#34;Some other label\u0026#34;, Value = \u0026#34;Some other value\u0026#34; } } }; return Task.FromResult(demoOptions); } else { // don\u0026#39;t touch existing options  return Task.FromResult(options); } } Koble dropdown-komponent til kodeliste Dette gjøres ved å legge til feltet optionsId som referer til hvilken option (kodeliste) man ønsker refere til. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;8e6f7b2f-fcf0-438d-8336-c1a8e1e03f44\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;componentType\u0026#34;: 4, \u0026#34;textResourceBindings\u0026#34;: {}, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;optionsId\u0026#34;: \u0026#34;biler\u0026#34;, } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/events/",
	"title": "Events",
	"tags": [],
	"description": "Hvordan lage egendefinerte events for en app.",
	"content": "Aktivere generering av events i applikasjonen din For at applikasjonen din skal kunne generere events må den referere til nugetversjon = 1.2.4.\rSe hvordan du oppdaterer nugetreferanser for applikasjonen din [her](../update/#nuget-pakker).\r\rGenerering og lagring av events er ikke enablet som default i applikasjonene per 22.10.2020. Det må derfor et manuelt steg til for at applikasjonen din skal generere events.\nI filen appsettings.json i mappen App må følgende legges til i seksjonen AppSettings\n\u0026#34;RegisterEventsWithEventsComponent\u0026#34;: true Pushe egendefinerte events i applikasjonen din Servicen IEvents er eksponert i applikasjonen og kan dependency injectes i den klassen der du har behov for å generere et egendefinert event.\nMetoden AddEvent krever navnet på eventypen og instansen som input.\nKodeeksempel I denne seksjonen finner du et eksempel på hvordan man kan generere et egendefinert event ved instansiering av applikasjonen.\nLogikken er implementert i InstantiationHandler.cs\nusing Altinn.App.Services.Interface; using Altinn.App.PlatformServices.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; using System.Threading.Tasks; // using Altinn.App.Models; // Uncomment this line to refer to app model(s)  namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; private IEvents _eventsService; /// \u0026lt;summary\u0026gt;  /// Set up access to profile and register services  /// \u0026lt;/summary\u0026gt;  public InstantiationHandler(IProfile profileService, IRegister registerService, IEvents eventsService) { _profileService = profileService; _registerService = registerService; _eventsService = eventsService; } /// \u0026lt;summary\u0026gt;  /// Run validations related to instantiation  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;example\u0026gt;  /// if ([some condition])  /// {  /// return new ValidationResult(\u0026#34;[error message]\u0026#34;);  /// }  /// return null;  /// \u0026lt;/example\u0026gt;  /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;validationResults\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;The validation result object (null if no errors) \u0026lt;/returns\u0026gt;  public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { return await Task.FromResult((InstantiationValidationResult)null); } /// \u0026lt;summary\u0026gt;  /// Run events related to instantiation  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;remarks\u0026gt;  /// For example custom prefill.  /// \u0026lt;/remarks\u0026gt;  /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;Instance information\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data object created\u0026lt;/param\u0026gt;  public async Task DataCreation(Instance instance, object data) { await _eventsService.AddEvent(\u0026#34;app.test.event\u0026#34;, instance); await Task.CompletedTask; } } }   Den private variabelen for servicen inkluderes i klassen\nprivate IEvents _eventsService;   Namespce for IEvents må inkluderes i klassen. Legg til linjen nedenfor blant de andre using-statements øverst i filen.\nusing Altinn.App.PlatformServices.Interface;   IEvents servicen dependency injectes inn i klassen. Og den private variabelen blir assignet en verdi.\npublic InstantiationHandler(IProfile profileService, IRegister registerService, IEvents eventsService) { _profileService = profileService; _registerService = registerService; _eventsService = eventsService; }   I metoden der man har behov for å genere et event kaller man på servicen.\nHer har det egendefinerte eventet fått navnet app.test.event, i tillegg sendes instansen med. Denne brukes til å populere resterende metadata om eventet.\nawait _eventsService.AddEvent(\u0026#34;app.test.event\u0026#34;, instance);   Dersom du prøver å bygge løsningen nå vil det feile.\nIEvents vil mangle der InstantiationHandler instansieres. Naviger til App.cs og dependency inject servicen inn i konstruktøren til App.\nVidere må tjenesten legges til i kallet der InstantiationHandler instansieres som vist nedenfor.\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IEvents eventsService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService, eventsService); }   Applikasjonen din er nå klar til å generere et egendefinert event under instansiering. Dette er mulig å teste lokalt før det evt. deployes til et testmiljø.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/attachments/",
	"title": "Vedlegg",
	"tags": [],
	"description": "I en applikasjon kan man legge til rette for opplasting av filvedlegg både via GUI og API.",
	"content": "Metoder for opplasting av vedlegg I en Altinn app har man to alternativer for opplasting av vedlegg:\n vedleggskomponent i skjema API-kall mot app backend  Førstnevnte vil være et godt alternativ for all data er det forventet at en sluttbruker vil laste opp via brukergrensesnitt i skjema. Sistnevnte anbefales brukt dersom det kun er forventet at systemer skal laste opp vedlegget. Det er ingen begrensning på hvor mange vedlegg som kan inkluderes i en applikasjon og begge opplastingsmetoder kan brukes innad i samme applikasjon.\nNedenfor følger en enkel beskrivelse av hvordan du kan legge til rette for at applikasjonen din kan ta imot vedlegg.\nInnsending av vedlegg med vedleggskomponent i skjema Når man setter sammen skjemaet sitt i Altinn Studio har man en vedleggskomponent tilgjengelig. Det er mulig å laste opp flere vedlegg på en enkelt komponent, og hvor mange vedleggskomponenter du benytter i din applikasjon vil avgjøres av egenskapene til dokumentene du forventer at skal lastes opp og eventuelle begrensninger du selv ønsker å sette (se konfigurasjon av vedlegg for mer informasjon om dette).\nNB! Det vil også være mulig å laste opp vedlegg av typen definert i vedleggkomponenten via API.\nBildet over viser vedleggskomponenten i Altinn Studio. Det er mulig å sette en del av konfigurasjonenen for vedleggene som lastes opp alledere her.\n Egendefinerte filtyper kan spesifiseres dersom man vil begrense filtypene som kan sendes inn. En bruker vil i så fall hindres under opplastning dersom filtypen ikke er blant den godkjente listen. Minst/maks antall filvedlegg kan spesifiseres dersom man ønsker et bestemt antall vedlegg lastet opp via komponenten. Ved å sette \u0026lsquo;0\u0026rsquo; på minst antall filvedlegg vil det ikke være påkrevd å laste opp en fil. Maks filstørrelse spesifiseres i MB.  Ytterligere konfigurasjoner som kan settes for vedlegg inkluderer: tillatte bidragsytere og beskrivelse. Dette gjøres i applicationMetadata.json som ligger under App/config i applikasjonsrepoet.\nInnsending av vedlegg med API-kall For å legge til rette for å kunne sende inn vedlegg uten å ha støtte for dette i GUI må man legge inn et datatype-objekt i applicationMetadata.json (filen ligger under App/config i applikasjonsrepoet). Det vil da kun være mulig å sende inn vedlegg av denne typen via API-kall. For en nærmere beskrivelse av de tilgjengelige feltene se konfigurasjon av vedlegg.\nKonfigurasjon for vedlegg I applicationMetadata.json (ligger under App/config i applikasjonsrepoet) vil man finne en property som heter dataTypes. Her er ligger konfigurasjonen for alle datatyper knyttet til applikasjonen, både skjemadata (app model data) og vedlegg. Feltet appLogic som man også vil se blant noen av objektene i listen skal kun brukes for skjemadata.\nNedenfor er det to eksempler på dataTypes-instanser i en applikasjon fra en deployet applikasjon.\n\u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;53a50f0d-2345-448d-9fba-f18e6bbe71f8\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;allowedContentTypes\u0026#34;:[\u0026#34;application/pdf\u0026#34;] }, { \u0026#34;id\u0026#34;: \u0026#34;attest\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 0, \u0026#34;allowedContributers\u0026#34;: [\u0026#34;org:nav\u0026#34;, \u0026#34;orgNo:XXXXXXXXXX\u0026#34;], \u0026#34;grouping\u0026#34;: \u0026#34;Attester\u0026#34;, } ]   Id på vedleggstypen. Denne vil settes som en GUID dersom man bruker vedleggskomponent fra Altinn Studio slik man ser i det første elementet i dataTypes-listen. Skulle det være ønskelig å endre verdien til et mer fornuftig navn må man også være obs på at denne endringen må gjøres to steder: applicationMetadata.json og FormLayout.json. (Kun relevant dersom man bruker filopplaster i GUI)\n  taskId betegner hvilket steg i prosessen det er forventet at dette vedlegget skal lastes opp på. Denne verdien må tilsvare en id på en av taskene i process.bpmn.\n  maxSize betegner maks tillat størrelse på vedlegget.\n  maxCount betegner en øvre grensen for hvor mange vedlegg av denne typen som skal lastet opp i tilknytning til en instans.\n  minCount betegner en nedre grensen for hvor mange vedlegg av denne typen som skal lastet opp i tilknytning til en instans. Dersom verdien er 0 er det ikke påkrevt å laste opp vedlegg av denne typen.\n  allowedContributers spesifiserer hvem som får lov til å lage og/eller endre vedlegg av denne typen. Dette spesifiseres på formatet {nøkkelord}:{verdi}. Tillatte nøkkelord inkluderer: \u0026lsquo;org\u0026rsquo;; trebokstavsforkortelse på organisasjon og \u0026lsquo;orgNo\u0026rsquo;; organisasjonsnummer. Det er per nå ikke mulig å spesifisere en organisasjon som ikke er registrert som tjenesteeier.\n  allowedContentTypes spefisiserer hvilke vedleggstyper man tillater. De hyppigst brukte inkluderer: application/pdf, text/xml, image/jpeg. Dersom man ikke ønsker å sette begrensning på typen vedlegg trenger man ikke definere denne parameteren. Les mer om mime types her.\n  grouping betegner gruppen som vedleggene i av denne typen skal grupperes etter. Dette er en valgfri egenskap, hvor vedlegg med samme grouping vil havne i samme liste. Grouping kan både være en streng (f.eks \u0026ldquo;Attester\u0026rdquo;) eller en tekstnøkkel om man ønsker å støtte flere språk (f.eks \u0026ldquo;skjema.vedleggsgruppering). Her er et eksempel hvor grouping \u0026ldquo;Demogruppe\u0026rdquo; satt på en vedleggstype:\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/settings/",
	"title": "Settings og miljøvariabler",
	"tags": [],
	"description": "Hvordan legge inn konfigurasjon- og miljøspesifikke verdier slik at de er tilgjengelig fra app-koden.",
	"content": "Standard .NET konfigurasjon Altinn 3 sin App template baserer seg på en ASP.Net Core applikasjon og har med dette en rekke muligheter for å styre konfigurasjon av en App. Denne dokumentasjonen er derfor i stor grad utdrag fra eller linker til Microsoft sin egen dokumentasjon. Det er derimot ikke alt som er mulig i en App da det er litt begrenset hva Altinn 3 gir av tilganger til miljøet en App kjører i.\nappsettings.json Første og enkleste kilde til konfigurasjonsinformasjon er appsettings filene. En hver ny app som blir laget vil komme med en eksisterende appsettings.json fil. Denne filen blir lest inn av en App under oppstart uavhengig av hvilke miljø Appen kjører i. Det vil si at den bør inneholde standarinnstillinger og innstillinger som er lik i alle miljøer. Filen har allerede en del innstillinger som er i bruk og verdiene er i stor grad beregnet for et utviklingsmiljø hvor man kjører LocalTest.\nI appsettings.json filene organiseres verdier i ulike seksjoner. Det anbefales å ikke legge til nye verdier i de eksisterende seksjonene, men isteden lage nye seksjoner. Følgende seksjoner er reservert for å unngå kollisjoner: Kestrel, AppSettings, GeneralSettings, PlatformSettings, PEPSettings, ApplicationInsights, kvSettings.\n{ \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn i alle miljøer, men kanskje overstyrt av miljøspesifikke kilder\u0026#34; }, \u0026#34;AppSettings\u0026#34;: { ... }, \u0026#34;GeneralSettings\u0026#34;: { ... }, \u0026#34;PlatformSettings\u0026#34;: { \u0026#34;ApiStorageEndpoint\u0026#34;: \u0026#34;http://localhost:5101/storage/api/v1/\u0026#34;, \u0026#34;ApiRegisterEndpoint\u0026#34;: \u0026#34;http://localhost:5101/register/api/v1/\u0026#34;, ... }, \u0026#34;ApplicationInsights\u0026#34;: { \u0026#34;InstrumentationKey\u0026#34;: \u0026#34;retrieved from environment at runtime\u0026#34; } } I fremtiden vil en ny App få med en egen seksjon som det skal være enkelt å utvide. I mellomtiden refereres det til Microsoft sin dokumentasjon for hvordan dette kan gjøres.\nMiljøspesifikke appsettings En ny app vil også inneholde et set med miljøspesifikke appsettings filer: appsettings.Development.json, appsettings.Staging.json og appsettings.Production.json. Disse filene blir lest inn kun i det aktuelle miljøet. TT02-miljøet er definert som Staging og produksjonsmiljøet er definert som Production.\nHver fil skal altså ha verdier som er unike eller anderledes i minst ett annet miljø. Et eksempel på en type verdi som kan variere fra miljø til miljø er \u0026ldquo;timeout\u0026rdquo; verdier. Hvis man ønsker at en App skal vente lengre på respons fra et eksternt API under utvikling enn det man ønsker å tillate i produksjon.\nappsettings.Development.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for utviklingsmiljø\u0026#34; } } appsettings.Staging.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for TT02\u0026#34; } } appsettings.Production.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for produksjon\u0026#34; } } Miljøvariabler Standard oppførsel til en ASP.Net applikasjon er å lese inn miljøvariabler. Dette gjøres også for en App, men det er ikke mulig for en Apputvikler å lage eller endre noen verdier per i dag. Altinn 3 mener at denne måten å styre miljøspesifikke verdier på dekkes av appsettings og KeyVault.\nKommandolinjeargumenter Det er teknisk mulig å overstyre alle andre data kilder ved hjelp av kommandolinjeargumenter. Det er derimot ikke mulig å bruke dette til å endre verdier fra et miljø til et annet.\nAzure KeyVault Hver applikasjonseier skal få tilgang til sitt eget Azure KeyVault for lagring av sensitive verdier. Altså verdier man ikke ønsker å ha synlig i kode eller konfigurasjonsfiler. Noen naturlig eksempler på dette er ting som brukernavn og passord for eksterne APIer en App skal benytte. Et sertifikat, privat nøkkel eller lignende.\nPer i dag blir ikke verdier fra KeyVault lest inn i konfigurasjonsstyringen av en App. Isteden må man benytte Secrets komponenten. Dette er dokumentert under hemmeligheter.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/stateless/",
	"title": "Stateless applikasjon (innsynstjeneste)",
	"tags": [],
	"description": "Hvordan legge inn konfigurasjon for å styre oppførsel ved applikasjonens oppstart",
	"content": "Introduksjon til stateless applikasjoner En stateless, eller tilstandsløs, applikasjon skiller ser fra standard applikasjoner ved at den ikke lagrer noe data, verken skjemadata eller metadata om instanser av applikasjonen. Derfor passer stateless applikasjoner godt som innsynstjenester der en sluttbruker eller et system gjør et oppslag mot en eller annen ressurs evt. presenterer data fra en tredjepart basert på hvem brukeren er.\nKonfigurasjon Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre.\nMERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.5.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\n\rI applikasjonsmetadataen er det mulig styre oppførselen en applikasjonen har under oppstart. Om man ønsker at applikasjonen skal oppføre seg som en tilstandsløs applikasjon vil det nå være mulig. For en slik applikasjon vil det ikke bli lagret noe data eller metadata, og applikasjonen vil heller ikke havne i meldingsboksen til sluttbruker. Dette tilsvarer en innsynstjeneste i Altinn 2.\nKonfigurasjonen av dette gjøres i applicationmetadata.json. Eksempel:\n{\r\u0026quot;id\u0026quot;: \u0026quot;ttd/stateless-app-demo\u0026quot;,\r\u0026quot;org\u0026quot;: \u0026quot;ttd\u0026quot;,\r\u0026quot;title\u0026quot;: {\r\u0026quot;nb\u0026quot;: \u0026quot;Stateless App Demo\u0026quot;\r},\r\u0026quot;dataTypes\u0026quot;: [\r{\r\u0026quot;id\u0026quot;: \u0026quot;ref-data-as-pdf\u0026quot;,\r\u0026quot;allowedContentTypes\u0026quot;: [\r\u0026quot;application/pdf\u0026quot;\r],\r\u0026quot;maxCount\u0026quot;: 0,\r\u0026quot;minCount\u0026quot;: 0\r},\r{\r\u0026quot;id\u0026quot;: \u0026quot;Stateless\u0026quot;,\r\u0026quot;allowedContentTypes\u0026quot;: [\r\u0026quot;application/xml\u0026quot;\r],\r\u0026quot;appLogic\u0026quot;: {\r\u0026quot;autoCreate\u0026quot;: true,\r\u0026quot;classRef\u0026quot;: \u0026quot;Altinn.App.Models.StatelessV1\u0026quot;\r},\r\u0026quot;taskId\u0026quot;: \u0026quot;Task_1\u0026quot;,\r\u0026quot;maxCount\u0026quot;: 1,\r\u0026quot;minCount\u0026quot;: 1\r}\r],\r...\r\u0026quot;onEntry\u0026quot;: { \u0026quot;show\u0026quot;: \u0026quot;stateless\u0026quot; } // legg til denne linjen\r}\rI feltet onEntry.show har man mulighet til nå å referere til et layout-set som man ønsker skal vises under oppstarten av applkasjonen. Les mer om layout-sets her.\nLayout-settet man referer til her blir så benyttet som visningen brukeren blir presentert for i det man navigerer til applikasjonen.\nKonfigurasjonsfilen layout-sets.json kan opprettes dersom den ikke finnes fra før av. Den skal ligge i mappen App/ui. I layout-sets.json legger man så inn det aktuelle settet man referer til fra applicationmetadata.json, eksempel:\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;stateless\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Stateless\u0026#34; } ] } I eksempelet over så referer layout-settet stateless til datamodellen Stateless. Eksempel app-struktur på en applikasjon som har satt opp på denne måten:\n├───App ├───config ├───logic ├───models │ Stateless.cs │ Stateless.metadata.json │ Stateless.schema.json │ Stateless.xsd ├───ui │ layout-sets.json │ └───stateless | RuleConfiguration.json │ RuleHandler.js │ Settings.json │ └───layouts FormLayout.json FormLayout.json vil så kunne settes opp på samme måte som en vanlig applikasjon, og vil støtte samtlige komponenter som er mulig å sette opp i en vanlig app, med unntak av:\n Filopplaster Knapp  App frontend vil så skjønne ut fra konfigurasjonen i applicationmetadata.json at den ikke skal instansiere, og hente ned de aktuelle layout-filene og den tilkoblede datamodellen og presentere dette til sluttbrukeren.\nDatapopulering Når man benytter en stateless datatype så vil man kunne populere datamodellen i det app-frontend spør om skjemadataen.\nDatapopuleringen skjer i to steg på det initielle kallet fra frontend (GET):\n Prefill, les mer om dette her. Dataprossesering, les mer om dette her.  På påfølgende oppdateringer på samme skjemadata (POST) så vil man ikke kjøre prefill en gang til, men kalkuleringen trigges. Dette muligjør manipulering av dataen basert på brukerens input selv i en stateless tilstand.\nEksempel på en kalkulering som populerer datamodellen nevnt i eksempelet over:\npublic async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data) { if (instance.GetType() == typeof(StatelessV1)) { StatelessV1 form = (StatelessV1) data; // Her kan du gjøre det du ønsker, f.eks et API-kall  // om tjenesten skal oppføre seg som en innsynstjeneste.  form.Fornavn = \u0026#34;Test\u0026#34;; form.Etternavn = \u0026#34;Testesten\u0026#34;; return true } return false; } Autorisasjon med tredjepartsløsninger Tilgangsstyring for stateless applikasjoner kan løses med standard app-autorisasjon der man hved hjelp av Altinn-roller definerer hvem som har tilgang til å benytte tjenesten. Dersom man har behov for ytteligere sikring av tjenesten kan man implementere logikk for autorisasjon av brukere med tredjepartløsninger. Dette kan være API-er som er eksponert innenfor egen virksomhet eller åpne API fra andre tilbydere.\nI eksempelet nedenfor benyttes Finanstilsynets API til å fastslå om virksomheten som repesenteres av en bruker i Altinn har tilstrekkelige lisenser til å benytte tjenesten.\nKildekoden til applikasjonen som eksempelet er basert på finnes her. (Krever bruker i Altinn Studio.)\nVidere i eksempelet vil betegnelsen bruker være synonymt med en virksomhet representert ved en person i Altinn.\n  Utvid datamodellen med felter for autorisasjon\nI tillegg til et felt for å ta input fra bruker og et felt for å vise fram resultatet, har vi i dette eksempelet et felt for å holde på infomasjon om hvorvidt brukeren er autentisert og et felt for å holde på en dynamisk feilmelding.\n\u0026lt;xs:sequence\u0026gt; \u0026lt;xs:element name=\u0026#34;searchString\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;result\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;userAuthorized\u0026#34; type=\u0026#34;xs:boolean\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;errorMessage\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;/xs:sequence\u0026gt; Hopp til steg 4 dersom applikasjonen kun skal benyttes via API.\n  Legg til felt for å vise feilmelding i brukergrensesnittet\nI brukergrensesnittet til applikasjonen er det tre komponenter. Et søkefelt for brukerinput, et tekstfelt dedikert til å vise fram søkeresultatet og en paragraf som er reservert for feilmeldinger.\nKomponentene er koblet til datamodell og tekstressurs på følgende måte i FormLayout.json\n\u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;sokeBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;SearchString\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;searchString\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: false }, { \u0026#34;id\u0026#34;: \u0026#34;resultatBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Result\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;result\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: true }, { \u0026#34;id\u0026#34;: \u0026#34;errorBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;ErrorMessage\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: true } ]   Legg inn dynamikkregler for å vise/skjule felter\nVi bruker dynamikkregler til å vise/skjule felter avhengig av om en bruker en autorisert eller ikke.\nDet er lagt inn en dynamikkregel i RuleHandler.js som sjekker om et felt i datamodellen har verdien false. Konfigurasjon av regler er beskrevet nærmere her.\nI RuleConfiguration.json ser man hvordan regelen benyttes. Dersom inputverdien fra datamodellen userAuthorized er false, så vises errorBoks-komponenten, mens det motsatte skjer med søke- og resultatfeltene, disse skjules.\nDefault oppførsel vil være det motsatte, altså at søk og resultat er synlig, mens error feltet er skjult.\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;e2dd8ff0-f8f1-11eb-b2bc-5b40a942c260\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;isFalse\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;userAuthorized\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Show\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c260\u0026#34;: \u0026#34;errorBoks\u0026#34; } }, \u0026#34;e2dd8ff0-f8f1-11eb-b2bc-5b40a942c261\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;isFalse\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;userAuthorized\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Hide\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c261\u0026#34;: \u0026#34;sokeBoks\u0026#34;, \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c262\u0026#34;: \u0026#34;resultatBoks\u0026#34; } } } } }   Legg til tekstressurser\nI tillegg til navnet på tjenesten er det lagt inn tre tekstressurser.\nTekstressursen for feilmelding inneholder en placeholder for navnet på brukeren. Variabelen errorMessage vil populeres i datamodellen når det registreres at en bruker ikke er autorisert til å bruke tjenesten.\n{ \u0026#34;id\u0026#34;: \u0026#34;ErrorMessage\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;{0} mangler rettigheter til å bruke denne tjenesten.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;errorMessage\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.lookup\u0026#34; } ] }, { \u0026#34;id\u0026#34;: \u0026#34;Result\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Resultat\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;SearchString\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Legg inn søkeord her:\u0026#34; },   Implementér autorisasjonslogikk\nAlt av dataprosessering for stateless applikasjoner ligger i filen App\\logic\\DataProcessing\\DataProcessingHandler.cs, og det er her autorisasjonslogikken skal plasseres.\nLogikk for å slå opp data og autorisere brukeren ligger i metoden ProcessDataRead. Denne kalles hver gang en bruker åpner applikasjonen eller sendes inn noe input data.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data)\r{\rlookup lookup = (lookup)data;\r// Check if user is authorized to use service\rParty party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)); if (string.IsNullOrEmpty(party.OrgNumber) || !await _finanstilsynet.HasReqiuiredLicence(_settings.LicenseCode, party.OrgNumber))\r{\rlookup.userAuthorized = false;\rlookup.errorMessage = $\u0026quot;{party.Name}\u0026quot;;\rreturn true;\r} // logic for looking up data\rif (!string.IsNullOrEmpty(lookup.searchString))\r{\rlookup.result = $\u0026quot;You typed \\\u0026quot;{lookup.searchString}\\\u0026quot;. This is the result.\u0026quot;;\rreturn true;\r}\rreturn false;\r}\rMetoden starter med logikk for å hente ut skjemadataen slik at denne kan benyttes videre i metoden.\nlookup lookup = (lookup)data Videre kommer logikken for å sjekke om brukeren er autorisert.\n// Check if user is authorized to use service Party party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)) if (string.IsNullOrEmpty(party.OrgNumber) || !await _finanstilsynet.HasReqiuiredLicence(_settings.LicenseCode, party.OrgNumber)) { lookup.userAuthorized = false; lookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;; return true; } For å vite hvem brukeren er, benyttes identifikatoren instance.InstanceOwner.PartyId, denne får vi som input til metoden. Vi slår opp i Altinn sitt register for å hente ut party-objektet som representerer brukeren. Dette kan inneholde en organisasjon eller en person.\nParty party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)) Det gjøres to sjekker for å avgjøre om en bruker er autorisert eller ikke. Først verifiseres det at party-objektet har definert et organisasjonsnummer, dersom dette ikke er tilfellet er brukeren en person, og dermed ikke autorisert.\nDen andre sjekken kaller _finanstilsynet.HasReqiuiredLicence(), en metode som slår opp i finanstilsynets API for å avgjøre om en organisasjonen har en gitt lisens. Implementasjonen av servicen er tilgjengelig her.\nDersom ingen av sjekkene er vellykkede populeres to felter i datamodellen;\n en indikator på at brukeren ikke er autorisert en feilmelding, her kun navnet til brukeren  og true returneres for å indikere at dataverdier har blitt oppdatert.\nlookup.userAuthorized = false; lookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;; return true; Helt til slutt kommer logikken for å vise fram et resultat basert på søkestrengen.\n// logic for looking up data if (!string.IsNullOrEmpty(lookup.searchString)) { lookup.result = $\u0026#34;You typed \\\u0026#34;{lookup.searchString}\\\u0026#34;. This is the result.\u0026#34;; return true; } return false; lookup.result populeres med verdien av oppslaget, i dette tilfellet skriver vi bare søkestrenger tilbake til bruker. Igjen returneres true for å indikere at en dataverdi er blitt endret, og false dersom dette ikke er tilfellet.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/deployment/",
	"title": "Produksjonssetting av apper",
	"tags": [],
	"description": "Tjenesteeier kan selv produksjonssette sine applikasjoner, og gjøre vedlikehold av kode og avhengigheter.",
	"content": "Få tilgang til et produksjonsmiljø Første gang man skal gjøre deploy av en applikasjon til produksjonsmiljøet er det behov for at det er satt opp et eget tjenesteeier-cluster. For å få dette gjelder følgende prosess:\n Send en e-post til produkteier med en beskjed om hvilken/hvilke apps du har klar til produksjonssetting. Bekreft at tjenesteeier godtar bruksvilkårene Vent på beskjed om at cluster er opprettet.  Denne rutinen trenger bare å følges en gang. Når clusteret er satt opp, er løsningen selvbetjent etterpå.\nProduksjonssette en app Produksjonssetting av applikasjonen gjøres på samme måte som for testmiljøer.\nBestille Om skjema-side Altinn vedlikeholder en oversikt over alle tjenester i løsningen. For at Altinn brukerservice skal kunne hjelpe brukerne med en tjeneste, må informasjon legges inn her. Bestillingsskjemaet heter \u0026ldquo;Publiser informasjon om tjeneste på Altinn PROD og TT02\u0026rdquo;, og finnes etter innlogging på altinndigtal.no.\nMerk! Bestillingsskjemaet er inntil videre optimalisert for Altinn II-tjenester. Gjør derfor følgende:\n I feltet \u0026ldquo;Tjenestekode\u0026rdquo;, oppgi 9999 og i feltet \u0026ldquo;Utgavekode\u0026rdquo; oppgi 9999 I feltet \u0026ldquo;Hvem skal bruke skjemaet\u0026rdquo; husk å angi hvilke roller som er satt på tjenesten i tillegg til beskrivelsen av hvem tjenesten er for.  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/scenarios/",
	"title": "Scenarier",
	"tags": [],
	"description": "Forskjellige API-bruksscenarier.",
	"content": "\rAutentisering\rHvordan autentisere ved å bruke APIene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/maintainance/",
	"title": "Vedlikehold av app i produksjon",
	"tags": [],
	"description": "Applikasjoner i produksjon krever jevnlig vedlikehold og oppdateringer.",
	"content": "Når applikasjonen er satt i produksjon, vil det oppstå behov for å vedlikeholde applikasjonen. Den vanligste vedlikeholdstypen vil være å oppdatere avhengigheter.\nFor å gjøre en ny versjon av applikasjonen tilgjengelig, produksjonssetter man den på samme måte som vanlig.\nInstanser av appen i brukers innboks vil automatisk oppdateres til å bruke siste versjon av applikasjonen, så det er viktig at man ikke innfører endringer som knekker eksisterende instanser.\n\rOppdatere avhengigheter i app\rHvordan oppdatere avhengigheter i en app.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/",
	"title": "Lanserte tjenester",
	"tags": [],
	"description": "Oversikt over hvilke tjenester som allerede er i produksjon, til informasjon og inspirasjon",
	"content": "Juni 2021  Forhåndsgodkjenning av innreise for kjærestebesøk (UDI).\nInfo | Repo | Kjørende tjeneste  Mai 2021  Søknad for unntak om opphold på karantenehotell ved sterke velferdsgrunner når du reiser til Norge fra utlandet (UDI).\nInfo | Repo | Kjørende tjeneste  April 2021  Skattemelding med næringsspesifikasjon - pilot (Sirius) (Skatteetaten).\nInfo | Repo | Kjørende tjeneste  Februar 2021  Søknad om forhåndsgodkjenning av innkvartering i forbindelse med innreisekarantene (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste Digital pliktavlevering (Nasjonalbiblioteket).\nInfo | Repo | Kjørende tjeneste  Desember 2020  Søknad om autorisasjon som landmåler (Kartverket).\nInfo | Repo | Kjørende tjeneste Vedlegg til søknad om autorisasjon som landmåler (Kartverket).\nInfo | Repo | Kjørende tjeneste  Juni 2020  Ledige stillinger (RA0678) (SSB).\nInfo | Repo | Kjørende tjeneste Bestill tilgang til REST API (Digdir).\nInfo | Repo | Kjørende tjeneste Be om å bli tjenesteeier (Digdir).\nInfo | Repo | Kjørende tjeneste Godkjenning av bruksvilkår for skytjenester fra Altinn (Digdir).\nInfo | Repo | Kjørende tjeneste  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/",
	"title": "Modeller",
	"tags": [],
	"description": "Dette er en oversikt over de fleste modellene brukt av de forskjellige APIen. Den forklarer ikke hver eneste property i alle modeller, men vil forsøke å gi en solid introduksjon til de viktigste delene.",
	"content": "\rApp metadata\rThe application metadata document holds technical information about the app and the data type requirements.\n\r\rInstance\rAn instance is a metadata container that is used to track the status and progress of one interaction between an app user and owner.\n\r\rDataElement\rEt DataElement er en metadatabeholder som brukes til å spore statusen til faktiske data blobs.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/",
	"title": "Roadmap for Altinn",
	"tags": [],
	"description": "Høynivå roadmap og funksjonell beskrivelse for Altinn.",
	"content": "Altinn er under kontinuerlig videreutvikling. Du får vite mer om hva vi har gjort og hva vi planlegger å gjøre her. Enn så lenge er det kun roadmap for Altinn Studio og relatert funksjonalitet som er tilgjengelig her. All annen funksjonalitet har en egen roadmap.\n\rRoadmap for Altinn Studio\rHøynivå roadmap og funskjonelle beskrivelser for Altinn Studio og funksjonalitet som understøtter apper utviklet der.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/",
	"title": "Roadmap for Altinn Studio",
	"tags": [],
	"description": "Høynivå roadmap og funskjonelle beskrivelser for Altinn Studio og funksjonalitet som understøtter apper utviklet der.",
	"content": "\rFor informasjon om hvordan man bruker funksjonalitetene beskrevet her, se seksjonene om apper og API.\n\r\r\rApplikasjonseierfunksjonalitet in Altinn 3\rDette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.\n\r\rSluttbrukerfunksjonalitet i Altinn 3\rDette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/",
	"title": "Altinn Studio docs",
	"tags": [],
	"description": "Lær om Altinn Studio",
	"content": "Altinn Studio docs "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/api/",
	"title": "api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/",
	"title": "Testing av app API-er lokalt",
	"tags": [],
	"description": "Hvordan teste app-APIer lokalt.",
	"content": "\rAPI test org\rNår man kjører applikasjonene lokalt sammen med den lokale testplattformen kan man teste API som applikasjon eksponerer.\n\r\rAPI bruk som sluttbruker\rNår man kjører applikasjonen lokalt så kan man teste API beregnet for sluttbruker.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/appowner/",
	"title": "Applikasjonseierfunksjonalitet in Altinn 3",
	"tags": [],
	"description": "Dette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.",
	"content": "Lansert funksjonalitet For informasjon om hvordan man bruker funksjonalitetene som er beskrevet her, se brukerdokumentasjonen for Altinn Studio og API.\n\r\rTjenesteutvikling i GUI I brukergrensesnittet til Altinn Studio kan du gjøre følgende:\n Opprette (og finne igjen) en app Laste opp datamodell Legge inn tekster Lage et enkelt skjema (en eller flere sider), med kobling mellom elementer, tekster og datamodell Legge inn dynamikkregler (NB! Kodes i JavaScript) Deploye app til test- og produksjonsmiljø  Tjenesteutvikling via kode Ved å hente ned applikasjonskoden (via Git) lokalt (eller ved å redigere på app-filene i repository-visning) kan du gjøre alle mulige endringer av appen. Dette inkluderer blant annet standardfunksjonalitet for å:\n Lage kalkulerings- og valideringsregler Koble på forhåndsutfylling Legge inn API-oppslag Redigere på prosessen/arbeidsflyten i appen Redigere på autorisasjonsreglene for appen, samt lage egendefinert instansieringslogikk Lage egendefinerte hendelser/events  Teste lokalt Når du har applikasjonskoden lokalt, kan du også benytte deg av muligheten til å ha et lokalt testmiljø for å gjøre de fleste typer testing.\nIntegrasjon med tjenesteeier Altinn 3 har standardiserte API-er som tjenesteeier kan bruke for å hente og laste opp data. For nedlasting bygger Altinn 3 på at tjenesteeier gjør spørringer og laster ned data (pull). I tillegg kan tjenesteeier benytte app-enes API-er for å instansiere eller gjøre endringer på instanser.\nMan kan redusere mengden spørringer ved bruk av push av events - at tjenesteeier varsles når det er data til nedlasting (Q2 2021) (#4728) ✔️\nFor å benytte API-ene som tjenesteeier må man autentisere seg med Maskinporten.\nForvaltning av apper Det er lagt opp til tilgang til overvåking av egne applikasjoner, slik at man kan ha oversikt over hvordan appene fungerer. Se også sidene om vedlikehold av apps.\n Mulighet for å lage en ny app som kopi av en tidligere (Q3 2021) (#5923) ✔️  Kommende funksjonalitet Altinn 3 er i stadig videreutvikling, og funksjonalitet lanseres løpende. Backlogg revideres åtte ganger i året, og mindre endringer kan også forekomme mellom revisjonene. Generelt kan man si at jo lenger frem i tid leveranse er planlagt jo mer usikkert er angitt leveransetidspunkt.\nEndringer beskrevet i kursiv er å regne som på idéstadiet, og er ikke besluttet at skal utvikles.\nTjenesteutvikling i GUI For all kommende funksjonalitet gjør vi vurderinger av om det er egnet å løse det i GUI. På et senere tidspunkt (2023 eller senere) vil vi gjøre et løft for at mer funksjonalitet skal være tilgjengelig via GUI.\n Støtte for branching i Altinn Studio (Q4 2021) (#985)  Datamodellering Den avhengigheten vi i dag har til at datamodellering skal gjøres i et eksternt system vil forsvinne. Noen høydepunkter i planene for datamodellering i Altinn 3 er:\n Å kunne jobbe med en datamodell i et GUI (Q4 2021) (#5551) Integrasjoner med Felles datakatalog (Q1 2022) (#3811) Å kunne få automatisk generert datamodell fra det man bygger av brukergrensesnitt Å kunne få automatisk generert forslag til brukergrensesnitt ut fra datamodellen  Forvaltning av tjenester Vi ønsker å gjøre tjenesteeiere i stand til å selv forvalte sine applikasjoner i Altinn 3. For å få til dette kommer blant annet:\n Mulighet for å avpublisere en applikasjon (Q4 2021) (#3717) Webanalyse for applikasjonene  Integrasjon med tjenesteeier Pull av data vil fortsatt være grunnmønsteret for at tjenesteeier får tilgang til data, men det kommer et par unntak:\n Mulighet for å bruke eFormidling som grensesnitt for å få data direkte fra en Altinn 3-app til tjenesteeiers systemer (Q4 2021) (#4788) Splitt av data - flere tjenesteeiere kan motta data fra samme tjeneste (Q3 2022) (#4274)  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/authentication/",
	"title": "Authentication (Autentisering)",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform Authentication.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/authorization/",
	"title": "Authorization (Autorisasjon)",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform Authorization.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/auto-delete/",
	"title": "Automatisk sletting",
	"tags": [],
	"description": "En applikasjon kan konfigureres til å slette alle spor når prosessen er slutt.",
	"content": "For enkelte applikasjoner vil det være problematisk at det er spor av instanser i arkiv osv. på grunn av sikkerhetshensyn.\nDerfor er det mulig å sette ett flagg i applicationmetadata.json som sørger for at instansen blir fysisk slettet når tjenesteeier bekrefter at det er mottatt. Ved å sette autoDeleteOnProcessEnd til true vil man trigge denne funksjonaliteten.\nEksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/apps-test-prod\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;apps-test-prod\u0026#34; }, \u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.Skjema\u0026#34; }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;6aa7d237-f20f-4d42-9361-0c84cf1a8ed0\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [], \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 1, \u0026#34;maxCount\u0026#34;: 3, \u0026#34;minCount\u0026#34;: 1 } ], \u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: false, \u0026#34;organisation\u0026#34;: false, \u0026#34;person\u0026#34;: false, \u0026#34;subUnit\u0026#34;: false }, \u0026#34;created\u0026#34;: \u0026#34;2020-06-04T12:11:36.9601284Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;someone\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-06-04T12:11:36.9601305Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;someone\u0026#34;, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: true } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/maintainance/dependencies/",
	"title": "Oppdatere avhengigheter i app",
	"tags": [],
	"description": "Hvordan oppdatere avhengigheter i en app.",
	"content": "Appen er avhengig av flere ressurser som ligger utenfor selve appen. Dette inkluderer støttebiblioteker med felles funksjonalitet for alle apper og referanse til appen sin frontend.\nDisse avhengighetene er definert noen forskjellige steder i appen, og hver avhengighet refereres til med en spesifikk versjon. Når ressursene oppdateres, publiseres de på nytt som en ny versjon. En ny versjon kommer ofte med ny funksjonalitet eller forbedringer. For at appen skal kunne ta dette i bruk, må man oppdatere hvilken versjon av ressursene appen henter.\nNuget Nuget er .NET sin package manager, hvor vi publiserer kodebibliotek som brukes av alle appene.\nAppen bruker flere støttebiblioteker, som oppdateres fortløpende med forbedringer og ny funksjonalitet. En app refererer til konkrete versjoner av de forskjellige bibliotekene, og disse referansene må oppdateres for å hente inn siste versjon.\nOppgradere til nyeste versjon Tips: Installer Version Lens-utvidelsen for Visual Studio Code.\nDa kan du automatisk se hva som er nyeste versjon av alle pakker når du åpner App.csproj. Støtter også npm.\n\r\r Finn fram referansene til bibliotekene i appen. Referansene til biblioteker ligger i filen App/App.csproj i appens repo.  F.eks.:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.Extensions.Logging.Debug\u0026#34; Version=\u0026#34;3.1.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;3.1.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt;  Sjekk om det har kommet en oppdatert versjon av bibliotekene:  Altinn.App.Api Altinn.App.Common Altinn.App.PlatformServices   Oppdater de aktuelle referansene til den siste versjonen og lagre filen. Sjekk om det er noen breaking changes ifm endringer i bibliotekene, og gjør ev. endringer som beskrives for å løse ev. problemer. Bygg og deploy appen på nytt.  App frontend App frontend lastes inn av appen runtime, via en lenke til javascript-filen som er app frontend. Denne javascript-filen versjoneres ihht. Semantic Versioning:\n Given a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n App\u0026rsquo;en refererer som standard til en major versjon av app frontend, f.eks. versjon 1.x.y. Med mindre det kommer en ny major versjon vil alle oppdateringer med ny minor eller patch versjoner komme med automatisk. Om det kommer en ny major versjon må man eksplisitt oppdatere appen til å referere til denne.\nDersom man ønsker å referere til en spesifikk versjon av app frontend (f.eks. 1.2.3) så kan dette spesifiseres direkte i url\u0026rsquo;en som peker på app frontend.\nOppgradere til nyeste versjon / spesifisere versjon Referansen til app frontend ligger i App/views/Home/Index.cshtml.\nDet er 2 referanser som må oppdateres:\n Referansen til altinn-app-frontend.js-filen som er app frontend koden.  \u0026lt;script src=\u0026#34;https://altinncdn.no/toolkits/altinn-app-frontend/\u0026lt;VERSJONSNUMMER\u0026gt;/altinn-app-frontend.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  Referansen til altinn-app-frontend.css som inneholder styling for app frontend.  \u0026lt;script src=\u0026#34;https://altinncdn.no/toolkits/altinn-app-frontend/\u0026lt;VERSJONSNUMMER\u0026gt;/altinn-app-frontend.css\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Søk etter filnavnet (altinn-app-frontend.js eller altinn-app-frontend.css) og erstatt versjonsnummeret (f.eks. 1) med ønsket versjonsnummer (f.eks. 2).\nHusk: Dersom man setter kun major versjon (f.eks. 2), så vil alle oppdateringer innenfor denne major versjoner (bugfix, ny funksjonalitet som ikke er breaking) komme med automatisk. Dersom man setter en spesifikk versjon (f.eks. 2.0.0) så vil appen hente akkurat denne versjonen, helt til referansen evt. oppdateres til å bruke en annen versjon.\nDeployment Deployment utføres ved hjelp av helm charts. Standard deployment oppsett for apps hentes fra altinn-studio sitt helm repository.\nEr du i tvil om du benytter siste deployment strategi kan du følge migreringsguiden her\nFor å finne siste versjon av helm-charten kan du enten sjekke releases av charten deployment her eller legge inn helm repoet lokalt og søke i dette på følgende måte:\n# Legg til helm altinn-studio helm repo helm repo add altinn-studio https://charts.altinn.studio # Søk for versjoner av altinn-studio/deployment charten helm search repo -l altinn-studio/deployment Hvis det er ny versjon av helm charten sjekk changelog for å se hva som er oppdatert i versjonen.\nFor å ta i bruk en ny versjon oppdater versjon under dependencies i deployment/Chart.yaml\napiVersion: v1 description: A Helm chart for Kubernetes name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 \u0026lt;--- Oppdater her "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i app frontend i v3.0.0",
	"content": "As of v3.0.0 of app frontend, the font Altinn-DIN replaces the Roboto font that was used previously.\nOnce an app is upgraded to use v3 of the app frontend, all CSS expects the Altinn-DIN font to be loaded. In order for the app to display fonts as expected, the font that is loaded with the app must be updated.\nIn App/views/Home/Index.cshtml, replace the line\n\u0026lt;link href=\u0026#34;https://altinncdn.no/fonts/roboto/latin/roboto.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; with\n\u0026lt;link href=\u0026#34;https://altinncdn.no/fonts/altinn-din/altinn-din.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; The updated file, referring to v3 of app frontend, should reflect the changes of the file on the right:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v3.0.0.",
	"content": "We have added a new PDF handler to make it possible to hide pages and components in PDF.\nThe new version of the Altinn.App.* packages have breaking changes:\nUpdating to this version will require changes in multiple files.\n Updated package dependencies\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate nuget dependencies in App.csproj to version 3.0.0. \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt;  Create a new file for a new class called PdfHandler in the logic/Print folder File from template using System.Threading.Tasks; using Altinn.App.Common.Models; namespace Altinn.App.AppLogic.Print { /// \u0026lt;summary\u0026gt;  /// Handler for formatting PDF.  /// \u0026lt;/summary\u0026gt;  public class PdfHandler { /// \u0026lt;summary\u0026gt;  /// Method to format PDF dynamic  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;the layoutsettings\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;data object\u0026lt;/param\u0026gt;  public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await Task.FromResult(layoutSettings); } } }  Changes to the App.cs file\nAdd using using Altinn.App.AppLogic.Print; using Microsoft.Extensions.Options; using Microsoft.AspNetCore.Http; using Altinn.App.Services.Configuration; Add a new private field below InstantiationHandler\nprivate readonly PdfHandler _pdfHandler; Change constructor from:\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService, instanceService) to:\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService, IOptions\u0026lt;GeneralSettings\u0026gt; settings, IText textService, IHttpContextAccessor httpContextAccessor) : base( appResourcesService, logger, dataService, processService, pdfService, prefillService, instanceService, registerService, settings, profileService, textService, httpContextAccessor) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService); _pdfHandler = new PdfHandler(); } Add method\n/// \u0026lt;summary\u0026gt; /// Hook to run logic to hide pages or components when generatring PDF /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;The layoutsettings. Can be null and need to be created in method\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data that there is generated PDF from\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;Layoutsetting with possible hidden fields or pages\u0026lt;/returns\u0026gt; public override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); }   "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v4.0.0.",
	"content": "Altinn.App.* librarires target .Net 5 now, which requires that the application does the same.\nIn addition, all references to app and platform services have been moved from Startup.cs and should be replaced with two method calls.\nFollow the instructions below to ensure that the app is compatible with version 4 of the Altinn.App.* packages.\n  Update target framework and package dependencies\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate target framework to .Net 5 by replacing\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; with\n\u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; In the same file, update the Altinn.App.* package references to version 4.0.0.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;4.0.0\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;4.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;4.0.0\u0026#34; /\u0026gt; The changes in the file should match the image below:\n  Update Dockerfile to use .Net 5 images\nThe Dockerfile can be found in the root folder of the application repository.\nUpdate build image by replacing\nFROMmcr.microsoft.com/dotnet/core/sdk:3.1-alpine AS build with\nFROMmcr.microsoft.com/dotnet/sdk:5.0-alpine AS build And update the runtime image by replacing\nFROMmcr.microsoft.com/dotnet/core/aspnet:3.1-alpine AS final with\nFROMmcr.microsoft.com/dotnet/aspnet:5.0-alpine AS final The changes in the file should match the image below:\n  Replace references to services with call to extension method\nIn the App folder you will also find Startup.cs\nSeveral lines of code will be removed and replaced with the two lines below.\nservices.AddAppServices(Configuration, _env); services.AddPlatformServices(Configuration, _env); The code that should be removed from the file is marked in pink in the pictures below, which cover one section of the file each.\nDepending on how many custom changes you have made in your file the line numbers might not match. Do not worry, the services should still be grouped togheter roughly as shown in the picture. The application will run even if not all services are removed, so just do your best.\nStart by removing referenes to the Altinn App services.\nRemove references to all the Altinn Platform services.\nRemove all loading of configuration files.\nRemove logic to configure Application insights.\nRemove private method for retrieving the key for Application Insights.\nAs previously stated the removed references are now replaced by calls to two new methods that will load all existing and future platform and app services into your application.\nservices.AddPlatformServices(Configuration, _env); loads all configurations and services that the app requires to use Altinn Platform functionality, and services.AddAppServices(Configuration, _env); loads all remaining configurations and services that the app requires such as Authorization and Prefill services.\nEnsure that these lines are added withing the ConfigureServices fuction.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/breaking-changes/",
	"title": "Breaking changes",
	"tags": [],
	"description": "Oversikt over breaking changes introdusert i deployment i v1.1.0",
	"content": "Helm chart flyttet til eksternt repository. Følg migreringsguiden\n"
},
{
	"uri": "https://docs.altinn.studio/nb/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/dataprocessing/",
	"title": "Dataprosessering",
	"tags": [],
	"description": "Hvordan legge til kalkuleringer og annen dataprosessering?",
	"content": "Dataprosessering kjøres på serveren, og er basert på input fra sluttbruker/skjemadata. Dataprossering kan være kan være rent matematiske kalkuleringer, det kan også være å overføre verdier mellom felter, resultater av API-kall, osv.\nDataprossering kodes i C#, i filen DataProsessingHandler.cs. Denne filen kan redigeres enklest ved å laste ned kildekoden til app\u0026rsquo;en og redigere på egen maskin, f.eks. i Visual Studio Code. Datamodellen med skjemadata er tilgjengelig og kan redigeres/oppdateres etter ønske/behov.\nDataprossering kjøres hver gang data lagres og når data hentes ut fra API. Med auto-lagring på (dette er standard) vil dataprossering kjøres hver gang en bruker har gjort en endring og hopper ut av et felt.\nFor å sikre optimal opplevelse og kontroll er applikasjonstemplaten to forskjellige hendelser hvor logikk kan plasseres.\n ProcessDataWrite kjøres når data lagres ProcessDataRead kjøres når data leses fra databasen  VIKTIG: Når en dataprossering er kjørt som har oppdatert dataene på server, må front-end få beskjed om dette, sånn at de oppdaterte dataene kan lastes inn.\rFor å gjøre dette, må `ProcessDataWrite`-metoden returnere `true` om det er noen av dataene som har blitt oppdatert.\rHvis dette ikke gjøres, vil de oppdaterte dataen ikke være synlig for sluttbruker før de ev. laster inn siden på nytt.\r\rEksempel på kode fra app som prosesserer og populerer forskjellige data under lagring.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite(Instance instance, Guid? dataId, object data) { bool edited = false; if (data.GetType() == typeof(SoknadUnntakKaranteneHotellVelferd)) { SoknadUnntakKaranteneHotellVelferd model = (SoknadUnntakKaranteneHotellVelferd)data; HttpContext ctxt = _httpContextAccessor.HttpContext; string org = instance.Org; string app = instance.AppId.Split(\u0026#34;/\u0026#34;)[1]; int partyId = int.Parse(instance.InstanceOwner.PartyId); Guid instanceGuid = Guid.Parse(instance.Id.Split(\u0026#34;/\u0026#34;)[1]); // handling mapping of multiple choice velferdsgrunner  if (!string.IsNullOrEmpty(model.velferdsgrunner?.sammenstilling)) { model.velferdsgrunner.helseproblemer = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;helseproblemer\u0026#34;) ? true : false; model.velferdsgrunner.barnefodsel = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnefodsel\u0026#34;) ? true : false; model.velferdsgrunner.begravelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;begravelse\u0026#34;) ? true : false; model.velferdsgrunner.naerstaaende = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;naerstaaende\u0026#34;) ? true : false;  model.velferdsgrunner.adopsjon = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;adopsjon\u0026#34;) ? true : false; model.velferdsgrunner.sarligeOmsorg = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;sarligeOmsorg\u0026#34;) ? true : false; model.velferdsgrunner.barnAlene = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnAlene\u0026#34;) ? true : false; model.velferdsgrunner.hjemmeeksamen = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;hjemmeeksamen\u0026#34;) ? true : false; model.velferdsgrunner.arbeidunntak = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;arbeidunntak\u0026#34;) ? true : false; model.velferdsgrunner.andreVelferdshensyn = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;) ? true : false; model.velferdsgrunner.andreVelferdshensynBeskrivelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;) ? model.velferdsgrunner.andreVelferdshensynBeskrivelse : null; edited = true; } else { model.velferdsgrunner = null; } // set data for receipt if not set  if (string.IsNullOrEmpty(model.applogic?.altinnRef)) { model.applogic ??= new Applogic(); Party party = await _registerService.GetParty(int.Parse(instance.InstanceOwner.PartyId)); model.applogic.avsender = $\u0026#34;{instance.InstanceOwner.PersonNumber}-{party.Name}\u0026#34;; model.applogic.altinnRef = instance.Id.Split(\u0026#34;-\u0026#34;)[4]; } } return await Task.FromResult(edited); } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/debug/",
	"title": "Debugging av app",
	"tags": [],
	"description": "Når man kjører appene lokalt kan man debugge ved hjelp av ulike verktøy.",
	"content": "Følgende beskrivelse forutsetter at du har clonet applikasjonen fra Altinn Studio Repositories og har filene liggende på lokal harddisk.\nDebugging i Visual Studio Code For å debugge applikasjonen lokalt må du åpne applikasjonsprosjektet i Visual Studio Code. Velg åpne folder og bla deg frem til hvor repostoriet er lagret på din maskin.\nVelg debugging knappen til venstre i vertikal meny.\nDet er to måter å starte debugging av en applikasjon lokalt:\nStarte appen fra Visual Studio Code (.NET Core Launch) Denne metoden er den enkleste. Her vil Visual Studio Code starte applikasjonen og koble seg til i en og samme prosess\nVelg .NET Core Launch og trykk på den grønne \u0026ldquo;play\u0026rdquo; knappen.\nApplikasjonen vil da starte og han vil spørre om du skal starte en browser. Velg bare close.\nÅpne et browservindu og gå til http://altinn3local.no (forutsetter at du har startet lokal utviklingsplattform).\nStarte appen fra commando vindu Dette forutsetter at du har startet applikasjonen allerede. Gå til folderen hvor applikasjonen ligger og kjør kommando for å starte dotnet prosessen.\nI Visual Studio Code ha åpnet folderen med applikasjonsprosjektet. Attach deg til prosessen som heter Altinn.App.exe\nLegg til Breakpoints og analysere kode Sett breakpoints i code der du vil at debugger skal stoppe\nDer debugger stopper kan du analysere lokale verdier på objekter for å finne ut hvordan kode fungerer og eventuelt finne feil.\nLes mer om debugging i Visual Studio Code i dokumentasjonen til code.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/delegate-scopes/",
	"title": "Delegere API-tilganger til en leverandør",
	"tags": [],
	"description": "Beskrivelse av hvordan tjenesteier kan delegere API-tilganger (scopes) til en underleverandør.",
	"content": "Enkelte tjenesteeiere ønsker at en underleverandør skal kunne agere på vegne av dem, f.eks. leverandører av fagsystemer. For å få til det, så må disse API-tilgangene delegeres til leverandøren ved bruk av Altinn.\nDet er tjenesteeiers ansvar å selv fjerne delegeringene om behovet for tilgang hos leverandør forsvinner.\nDelegering av API-tilganger til leverandør Som en bruker som er nøkkelrolleinnehaver for tjenesteeier (typisk daglig leder aka DAGL), åpne \u0026ldquo;Andre med rettigheter til virksomheten\u0026rdquo;.\nSå må de nødvendige rettighetene gis.\n Altinn tjenesteeier-API: Appinstanser (full tilgang) - gir tilgang til scopes for både read og write. Altinn tjenesteeier-API: Appinstanser (lesetilgang) - gir kun tilgang til read.  Fjerning av delegering Delegeringer som er gjort kan også fjernes. Om en leverandør ikke lenger har behov for API-tilganger så er det tjenesteeier sitt ansvar å fjerne disse.\nScopes Delegering gir tilgang til disse scopene for leverandør:\naltinn:serviceowner/instances.read altinn:serviceowner/instances.write "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/development/",
	"title": "development",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/dynamic/",
	"title": "Dynamikk",
	"tags": [],
	"description": "Hvordan legge til dynamikk?",
	"content": "Introduksjon Dynamikk er hendelser som skjer på klient-siden. Disse kan deles opp i to kategorier:\n Beregning - kjøre beregninger på klient-side, og oppdatere felter med ny verdi Vis/skjul felter - bestemme om felter skal vises eller skjules basert på verdier i skjema.  All dynamikk skrives som funksjoner i javascript, i filen RuleHandler.js. Denne filen finner man under App/ui-mappen i appen, og kan også redigeres direkte i Lage- visningen i Altinn Studio, ved å velge Rediger dynamikk i høyre-menyen. Funksjonene som er definert i denne filen kan da configurere til å kjøres for feltene i skjemaet.\nKoden som definerer beregninger eller regler for vis/skjul bør settes opp sånn at den håndterer ev. feil i input. F.eks. bør de takle\rå motta tom input, eller å motta en tekst selv om de forventer et tall, uten å kræsje. Om dynamikken ikke fungerer som forventet, ta en titt på koden som definerer\rberegninger eller regler for vis/skjul for å se om det er noe feilhåndtering som mangler.\r\r**MERK**: for å støtte beregning/vis-skjul felter på eldre nettlesere så må man skrive javascript koden man legger i `RuleHandler.js` i den versjonen av ECMA-script som den aktuelle nettleseren støtter. For IE11 vil dette være ECMA-script 5. \rLegg til/rediger funksjoner for beregninger eller vis/skjul I filen RuleHandler.js er det satt opp 2 javascript-objekter:\n ruleHandlerObject - funksjoner for beregninger conditionalRuleHandlerObject - funksjoner med regler for vis/skjul  Det er inne i disse at de forskjellige funksjonene skal defineres. I tillegg er det satt opp to hjelpe-objekter (ruleHandlerHelper og conditionalRuleHandlerHelper), hvor man skal sette opp hva slags input de forskjellige funksjonene forventer å få inn. Dette gjør det mulig å konfigurere opp reglene i Altinn Studio senere. For at en funksjon skal være tilgjengelig for å konfigureres som dynamikk, må selve funksjonen være definert i hoved-objektet (ruleHandlerObject eller conditionalRuleHandlerObject), og parametrene den forventer å få inn må være satt opp i det tilhørende hjelpe-objektet.\nStrukturen på hjelpe-objektet vises under:\nvar ruleHandlerHelper = { \u0026lt;name_of_rule\u0026gt;: () =\u0026gt; { return { \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34;, \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34;, \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34; ... }; } } Strukturen på hoved-objektet, som inneholder funksjoner som brukes i dynamikk, vises under:\nvar ruleHandlerObject = { \u0026lt;name_of_rule\u0026gt;: (\u0026lt;input_variable_name\u0026gt;) =\u0026gt; { // Do something here  // Values from input parameters defined in  // helper can be accessed through the object passed  // into the rule, f.ex.  // \u0026lt;input_variable_name\u0026gt;.\u0026lt;input_param\u0026gt;  } } For eksempel, for å lage en regel som returnerer summen av to tall (beregning), vil man trenge følgende kode:\nvar ruleHandlerHelper = { sum: () =\u0026gt; { return { field1: \u0026#34;Field 1 in sum\u0026#34;, field2: \u0026#34;Field 2 in sum\u0026#34; }; } } var ruleHandlerObject = { sum: (data) =\u0026gt; { // Check if data is available  if (!data) return; // Check if value from input fields are available  // If not, use value 0 in sum  data.field1 = data.field1 ? data.field1 : 0; data.field2 = data.field2 ? data.field2 : 0; // return the sum  return data.field1 + data.field2; } } Noen standard-metoder for beregniner, med hjelpe-objekt, er satt opp automatisk når app\u0026rsquo;en lages i Altinn Studio. Noen av disse er vist i eksempelet under.\n   Method name Description Parameters Defined in object/helper     sum Returnerer summen av 2 verdier value1, value2 ruleHandlerObject/ruleHandlerHelper   fullName Returnerer to tekster (fornavn og etternavn) satt sammen med mellomrom mellom. firstName, lastName ruleHandlerObject/ruleHandlerHelper   lengthGreaterThan4 Returnerer true dersom verdien den får inn er lengre enn 4 karakterer lang. value conditionalRuleHandlerObject/conditionalRuleHandlerHelper    Regler for dynamikk kjøres dersom det har skjedd en endring i input-parametrene til de forskjellige reglene. Funksjonene som da kjøres må kunne håndtere dersom det f.eks. har kommet inn kun 1 av 2 parametre eller lignende.\nEt eksempel på hvordan dette kan gjøres er vist i sum-funksjonen under, hvor man tester hvilke parametre man har fått inn, og setter verdi til 0 på den/de parametre som mangler, sånn at regelen fortsatt fungerer.\nvar ruleHandlerObject = { sum: (obj) =\u0026gt; { obj.value1 = obj.value1 ? +obj.value1 : 0; obj.value2 = obj.value2 ? +obj.value2 : 0; return obj.value1 + obj.value2; }, fullName: (obj) =\u0026gt; { return obj.firstName + \u0026#39; \u0026#39; + obj.lastName; } } var ruleHandlerHelper = { sum: () =\u0026gt; { return { value1: \u0026#34;Value 1\u0026#34;, value2: \u0026#34;Value 2\u0026#34; } }, fullName: () =\u0026gt; { return { firstName: \u0026#34;First name\u0026#34;, lastName: \u0026#34;Last name\u0026#34; }; } } var conditionalRuleHandlerObject = { lengthBiggerThan4: (obj) =\u0026gt; { if (obj.value == null) return false; return obj.value.length \u0026gt;= 4; } } var conditionalRuleHandlerHelper = { lengthBiggerThan4: () =\u0026gt; { return { value: \u0026#34;value\u0026#34; } } } Konfigurere dynamikk for skjema-komponenter  Legg til de skjema-komponentene som ønskes i layout. I høyre-menyen, velg å legge til Regler for beregninger eller Regler for vis/skjul felt. Velg en tilgjengelig funksjon som gjør det du ønsker. Legg evt. til en ny funksjon, se beskrivelse over. Sett opp hvilke(t) felt som skal fungere som input til funksjonen - her er det felt i datamodellen som gjelder. Sett opp hvilke(t) fom skal påvirkes av regelen (skal motta beregnet verdi, eller skal vises/skjules) - her er det skjemakomponent som gjelder.   For regler for vis/skjul felt kan man velge flere felter som skal vises/skjules basert på samme regel.  Lagre konfigurasjonen. Test at det fungerer som forventet.  Eksisterende oppsett ligger synlig i høyre-menyen og kan redigeres/slettes.\nKonfigurasjonen legges i filen App/ui/RuleConfiguration.json. Denne kan også redigeres manuelt ved behov.\nEksempel på bruk av dynamikk i skjema Scenario:\nEn app med skjema som har flere felter for input. En av disse er en radioknapp-gruppe, med valgene \u0026ldquo;Ja\u0026rdquo; og \u0026ldquo;Nei\u0026rdquo;. Avhengig av hva sluttbruker velger her, skal forskjellig innhold vises i skjemaet:\n Ja: Et nytt input-felt vises, sammen med ekstra informasjon om hvordan feltet skal fylles ut. Nei: En annen informasjons-tekst vises.  Dette kan gjøres ved å legge inn følgende i RuleHandler.js, enten via Rediger dynamikk i Altinn Studio, eller ved å laste ned kildekoden til appen og redigere lokalt.\nvar conditionalRuleHandlerObject = { sjekkVirksomhetIDrift: (obj) =\u0026gt; { return (obj.value \u0026amp;\u0026amp; obj.value === \u0026#34;Ja\u0026#34;); }, sjekkVirksomhetIkkeIDrift: (obj) =\u0026gt; { return (!obj.value || obj.value != \u0026#34;Ja\u0026#34;); } } var conditionalRuleHandlerHelper = { sjekkVirksomhetIDrift: () =\u0026gt; { return { value: \u0026#34;Verdi\u0026#34; } }, sjekkVirksomhetIkkeIDrift: () =\u0026gt; { return { value: \u0026#34;Verdi\u0026#34; } } } Her har to funksjoner blitt opprettet, som sjekker om verdien er henholdsvis \u0026ldquo;Ja\u0026rdquo; eller ikke. Etter at denne koden er lagt til, kan regelen konfigureres i Altinn Studio. Resultatet vises under.\nDynamikk i repeterende gruppe Det er også mulig å sette opp dynamikk innad i en repeterende gruppe. Dette krever at man først setter opp regelen som vanlig, og så redigerer på oppsettet App/ui/RuleConfiguration.json manuelt. Helt konkret, er det følgende som må endres:\n For alle inputParams, må man legge til {0} etter gruppe-delen av data-modellen. F.eks. Datamodell.gruppe{0}.felt. Dette erstattes i koden av indeksen til hvert enkelt innslag av den repeterende gruppen. For alle selectedFields (altså feltene som påvirkes av reglen), må man legge til {0} bak felt-id\u0026rsquo;en. F.eks. skjemaFelt1{0} I tillegg må man legge enn en ny egenskap på regelen, repeatingGroups. Denne skal inneholde id\u0026rsquo;en til gruppen i layout-filen.  Et eksempel på en regel som er satt opp for repeterende grupper vises under:\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;9f9f2a50-360b-11ea-b69a-8510e2e248b9\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;lengthBiggerThan4\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;Skjemainnhold.personalia.arbeidserfaring{0}.stilling\u0026#34;  }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Show\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;962e2f60-3797-11ea-bfa5-9922024b4738\u0026#34;: \u0026#34;a-e-4{0}\u0026#34;,  \u0026#34;something\u0026#34;: \u0026#34;arbeidsgiver-adresse{0}\u0026#34; }, \u0026#34;repeatingGroup\u0026#34;: {  \u0026#34;groupId\u0026#34;: \u0026#34;arbeidserfaring-group\u0026#34;, } } } } } Eksempel med mer kompleks dynamikk Example with more complex dynamics\nScenario: Et skjema med to sett med radioknapper (ja/nei) og en avkrysningsboks.\n Når skjema lastes, er kun det første settet med radioknapper synlig. Hvis brukeren velder Ja, vises det andre settet med radioknapper.  Hvis brukeren velger Ja i det andre settet, blir avkrysningsboksen synlig. Hvis brukeren går tilbake til det første settet med radioknapper og velger nei, blir både det andre settet med radioknapper og avkrysningsboksen ikke lenger synlig.    Alternativ 1 Dette kan settes opp ved å lage 2 forskjellige betingelser for når feltene skal vises:\n En betingelse for det andre settet med radioknapper  Vises dersom Ja er valgt i det første settet   En betingelse for avkrysningsboksen  Vises når Ja er valgt i begge sett med radioknapper.    Koden for å løse dette kan være:\nvar conditionalRuleHandlerObject = { showField2: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.field1 \u0026amp;\u0026amp; obj.field1=== \u0026#34;yes\u0026#34;) { return true; } return false; }, showField3: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.field1 \u0026amp;\u0026amp; obj.field1 === \u0026#34;yes\u0026#34; \u0026amp;\u0026amp; obj.field2 \u0026amp;\u0026amp; obj.field2 === \u0026#34;yes\u0026#34;) { return true; } return false; } } var conditionalRuleHandlerHelper = { showField2: () =\u0026gt; { return { field1: \u0026#34;Field 1\u0026#34; }; }, showField3: () =\u0026gt; { return { field1: \u0026#34;Field 1\u0026#34;, field2: \u0026#34;Field 2\u0026#34; }; } } Alternativ 2 Dette kan også settes opp ved å bruke den samme betingelsen for å vise både det andre settet med radionkapper og avkrusningsboksen. I tillegg må man da ha en regel som sletter verdien i det andre settet med radioknapper dersom verdien i det første settet settes til Nei:\nvar ruleHandlerObject = { clearField: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.checkValue === \u0026#34;no\u0026#34;) { return \u0026#34;\u0026#34;; } return obj.currentValue; } } var ruleHandlerHelper = { clearField: () =\u0026gt; { return { checkValue: \u0026#34;check against this value\u0026#34;, currentValue: \u0026#34;the current value\u0026#34; } } } var conditionalRuleHandlerObject = { showField: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.checkField \u0026amp;\u0026amp; obj.checkField === \u0026#34;yes\u0026#34;) { return true; } return false; } } var conditionalRuleHandlerHelper = { showField: () =\u0026gt; { return { checkField: \u0026#34;check against this value\u0026#34; }; } } Dynamikk i PDF Fra versjon 3.0.0 er det også mulig å legge inn dynamikk for PDF. Dette gjøres i PDF Handler. Her kan man ved hjelp av logikk velge å skjulte felter eller sider i print.\nAppen må inkludere layout/ui/Settings.json filen som her.\nTeknisk er det veldlig likt hvordan man gjør det for validering.\nEksempel nedenfor som skjuler et gitt felt basert på innhold. Komponentene er basert på ID som man finner i layouts filene til skjema.\npublic async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data is Skjema) { Skjema skjema = (Skjema)data; if (skjema?.Innledninggrp9342?.Kontaktinformasjongrp9344?.KontaktpersonNavndatadef2?.value.Contains(\u0026#34;tulling\u0026#34;) == true) { layoutSettings.Components = new Components(); layoutSettings.Components.ExcludeFromPdf = new System.Collections.Generic.List\u0026lt;string\u0026gt;(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;079f205b-c9ea-414d-9983-0d158e833e8a\u0026#34;); } } return await Task.FromResult(layoutSettings); } ``` "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/expose/",
	"title": "Eksponere APIer fra en app",
	"tags": [],
	"description": "Man kan legge til flere API enn det som er definert som standard API for applikasjoner utviklet i Altinn Studio.",
	"content": "Applikasjonene som utvikles i Altinn Studio baserer seg i dag på ASP.NET Core for back-end. Dette gir høy fleksibiltet til å endre og modifisere applikasjonene.\nLegge til API kontroller For å kunne eksponere et nytt API i applikasjonen må det legges til en eller flere API kontrollere.\nNedenfor vises et eksempel fra en API controller som er lagt til i en gitt app. Her settes det opp hvilken path API skal lytte på og logikken.\nusing System; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; namespace Altinn.App.Api.Controllers { [ApiController] [Route(\u0026#34;{org}/{app}/CustomApi\u0026#34;)]  public class CustomApiController : ControllerBase { [HttpGet(\u0026#34;TimeInfo\u0026#34;)]  public async Task\u0026lt;ActionResult\u0026gt; Get() { return Ok(DateTime.Now); } } } Koden kan ses i dette repositoriet.\nI dokumentasjonen til ASP.NET kan du lese flere detaljer om mulighetene for å eksponere API.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/events/",
	"title": "Events (Hendelser)",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform Events.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/",
	"title": "Gruppering av felter",
	"tags": [],
	"description": "Hvordan gruppere felter i skjema.",
	"content": "\rOppsett for gruppering av felter\rGenerelt oppsett for gruppering av felter i skjema.\n\r\rRepeterende grupper\rOppsett for repeterende grupper.\n\r\rInnstillinger\rInnstillinger for visning.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/whats-new/",
	"title": "Hva er nytt",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v1 av deployment.",
	"content": "1.1.0 Første versjon i remote repository. Templates kopiert fra apps template\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i v3 av app frontend.",
	"content": "3.12.2 (2021-10-04) - Fiks for design av readonly datovelger Readonly datovelger nå har samme design som andre readonly komponenter. Issue #6253\n3.12.1 (2021-09-30) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u39. Issue #6873.\n3.12.0 (2021-09-29) - Bildekomponent La til bildekomponent for enklere å kunne legge til bilder i applikasjonen. Issue #379.\n3.11.9 (2021-09-29) - Støtte for JSON Schema 2020-12 i app frontend Fikset bug hvor JSON Schema 2020-12 ikke var støttet i app frontend. Tilhørende issues: #6703 #6812.\n3.11.8 (2021-09-27) - Lagt til mellomrom mellom valgfri tekst og titteltekst Lagt til mellomrom mellom valgfri tekst og titteltekst i radioknapp, avkrysningsboks og adresse komponenter. Issue #6893.\n3.11.7 (2021-09-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u38. Issue #6873.\n3.11.6 (20201-09-21) - Fokus indikator for input-felt Fikset bug hvor fokus indikator ikke var synlig for input-felter. Issue #6801.\n3.11.5 (2021-09-21) - Content loader visning på mobil Fikset bug hvor content loader gikk over tildelt bredde for små skjermer. Issue #6876.\n3.11.4 (2021-09-20) - Fiks for tekst parse feil Fikset tekst parse feil i confirm steget av en app. Issue #6775.\n3.11.3 (2021-09-17) - Forhåndsvalgt nedtrekksliste Nedtrekksliste støtter forhåndsvalgt (preselectedOptionIndex) verdi. Issue #5255.\n3.11.2 (2021-09-16) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u37. Issue #6794.\n3.11.1 (2021-09-09) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u36. Issue #6794.\n3.11.0 (2021-09-08) - Aktør valg i stateless app Stateless appene støtter aktør valg basert på innstillinger i app metadata. Issue #6443.\n3.10.3 (2021-08-23) - Added some IDs used by automated tests Non functional change. Not connected to an issue.\n3.10.2 (2021-08-19) - Dependency patching Patching of external dependencies for w33. Issue #6600\n3.10.1 (2021-08-16) - App frontend includes partyID for stateless apps App frontend includes partyID in calls for fetching stateless data. Issue #6609\n3.10.0 (2021-08-13) - Log out functionality Added functionality for log out from app frontend. Issue #6620\n3.9.9 (2021-08-12) - Dependency patching Patching of external dependencies for w32. Issue #6600.\n3.9.8 (2021-08-05) - Dependency patching Patching of external dependenecies for w31. Issue #6571.\n3.9.7 (2021-08-03) - Bugfix print view Fixed a bug where the print view for Altinn Apps would display an empty container. Issue #6578.\n3.9.6 (2021-08-02) - Dependency patching Patching of external dependenecies for w30. Issue #6571.\n3.9.5 (2021-07-28) - Bugfix for mobile view during app startup Fixed a bug where the app modal would behave inconsistent during app startup on mobile devices. Issue #6558.\n3.9.4 (2021-07-23) - Bugfix validation trigger for groups. Fix a bug where validations would not be triggered when closing a repeating group by clicking Edit button when trigger was present. Issue #6427.\n3.9.3 (2021-07-23) - Dependency patching Patching of external dependencies for w29.\n3.9.2 (2021-07-02) - Dependency patching Patching of external dependencies for w26. Issue #6385.\n3.9.1 (2021-07-01) - Support for redirect to require higher authentication level for stateless app Fix for bug that didn\u0026rsquo;t redirect user to login page with allowed authentication levels if logged in with a too low level. Issue #6506.\n3.8.0 (2021-06-29) - Several updates to validation functionality  Support for adding custom error messages to client side validations (JSON schema). Support for specifying single field validation (server) as FIXED to make sure resolved validation error messages are removed. Fixes bug where single field validation that returned empty (no errors/warnings) did not remove existing validation messages. Issue #5747.  3.7.0 (2021-06-29) - Support for posting data from stateless app Issue #6194.\n3.6.14 (2021-06-22) - Bug fix for duplicated validation messages Fixed a bug that caused validation messages on a FileUpload component to be displayed twice. Issue #6400.\n3.6.13 (2021-06-18) - Bugfix for replaceAll with variables in text Fix for bug introduced in 3.6.9, where only the last variable in texts with multiple variables was replaced. The change in 3.6.9 also caused summary page to fail in some cases. Issue #6455.\n3.6.12 (2021-06-18) - Dependency patching Patching of external dependencies. Issue #6385.\n3.6.11 (2021-06-16) - Bugfix for disappearing validation messages Fixed bug for disappearing validation messages. Single field validation response would overwrite all existing validations, causing earlier triggered validation messages to disappear. Issue #5857.\n3.6.10 (2021-06-15) - Bugfix for navigation buttons with multiple triggers Fixed bug for navigation buttons configured with multiple triggers, where only the first one was actually triggered. Issue #6387.\n3.6.9 (2021-06-14) - Bugfix variables in text Fixed bug where only first occurance of a variable in a given text was replaced. Issue #6091\n3.6.8 (2021-06-11) - New endpoints for statless app New endpoints for stateless app. Issue #6227\n3.6.7 (2021-06-10) - Dependency patching Patching of external dependencies. Issue #6385\n3.6.6 (2021-06-09) - Dependency patching Updated to latest major version of react v17. Issue #5072\n3.6.5 (2021-06-02) Bugfix for stateless app Fixed bug where stateless app with onEntry.show set to new-instance would crash. Issue #6321.\n3.6.4 (2021-06-02) Bugfix for simple receipt Fixed bug where simple receipt did not parse markdown if the app overrides defult texts. Issue #6232.\n3.6.3 (2021-06-02) Bufix for content loader Fixed bug where content loader did not scale for whole view. Issue #4888.\n3.6.2 (2021-06-01) Bugfix for summary view of group with multiple pages Fixed bug that caused app frontend to crash when rendering summary component for group when the group was defined with multiple pages in edit mode. Issue #6233.\n3.6.1 (2021-05-28) Dependency patching Patching of external dependencies. Issue #6324.\n3.6.0 (2021-05-28) Support for hiding back button in apps Issue #6193.\n3.5.0 (2021-05-27) Support for number formatting Added support for formatting numbers for Input-components. Issue #5972.\n3.4.2 (2021-05-26) Improve look of summary for checkboxes component Issue #6329.\n3.4.1 (2021-05-20) Dependency patching Patching of external dependencies. Issue #6221.\n3.4.0 (2021-05-18) Support for stateless apps Issue #6124.\n3.3.5 (2021-05-14) - Dependency patching Patching of external dependencies. Issue #6221.\n3.3.4 (2021-05-11) Bugfix for calculation in groups Issue #6235.\n3.3.3 (2021-05-11) Run data validation on page switch, and fix group component mobile view Issue #6236. Issue #5977.\n3.3.2 (2021-05-06) - Dependency patching Patching of external dependencies. Issue #6011.\n3.3.1 (2021-05-06) Support for markdown in validation messages Issue #5137.\n3.3.0 (2021-05-03) Support for multiple views in repeating group edit mode Issue #5869.\n3.2.2 (2021-04-23) - Dependency patching Patching of external dependencies. Issue #6011.\n3.2.1 (2021-04-23) - Bugfix for group validations Fixed a bug where groups with validation trigger would call the instance validation api. Now calls data validation. Issue #6089.\n3.2.0 (2021-04-21) - Validation on group save Added support for running validations on a group when the user tries to save an entry. Issue #5281.\n3.1.6 (2021-04-19) - Bugfix for checkbox values in summary component Fixed bug where summary would display an empty string for checkboxes with multiple selected values. Issue #5993.\n3.1.5 (2021-04-19) - Bugfix for repeating group state on calculation Fixed bug where repeating group state would not be updated if a backend calculation had altered a repeating group. Issue #6006.\n3.1.4 (2021-04-19) - Bugfix for validations on group delete Fixed bug where validations for a given group index would not be removed on delete. Issue #5960.\n3.1.3 (2021-04-16) - Bugfix for validation Fixed bug where single field validation would validate the whole instance and not data. Issue #5885.\n3.1.2 (2021-04-12) - Dependency patching. Patching of external dependencies. Issue #5957.\n3.1.1 (2021-04-09) - Bugfix for slow calculate Fixed bug where a slow backend calculation can overwrite later entered data. Issue #5754.\n3.1.0 (2021-04-07)- Help text for paragraph and header components App now supports help text for paragraph and header components. Issue #5862.\n3.0.16 (2021-04-06) - Dependency patching Patching of external dependencies. Issue #5877.\n3.0.15 (2021-03-22) - Bugix for group component with checkboxes Fixed bug where group component summary would display an empty value for checkboxes that had several selected values. Issue #5907.\n3.0.14 (2021-03-19) - Dependency patching Patching of external dependencies. Issue #5877.\n3.0.13 (2021-03-18) - Internal typings App frontend internal typings updated to fix failing tests. No issue connected.\n3.0.12 (2021-03-17) - Bugfix for markdown support in summary and group titles Fixed bug where app frontend would not render markdown in summary and group titles. Issue #5781.\n3.0.11 (2021-03-17) - Bugfix for page order calculation Fixed bug where app frontend would trigger call to calculate page order even when no calculation trigger was present. Issue #5863.\n3.0.10 (2021-03-12) - Bugfix for page order calculation Fixed bug where app frontend would trigger call to calculate page order for single page applications. Issue #5859.\n3.0.9 (2021-03-12) - Dependency patching Patching of external dependencies. Issue #5771.\n3.0.8 (2021-03-12) - Support for dynamicly getting page order App frontend now supports dynamicly fetching the page order on next page (\u0026ldquo;sporvalg\u0026rdquo;). See docs for more information. Issue #5640.\n3.0.7 (2021-03-09) - Bugfix for page caching Fixed issue where the app would cache the first page in alphabetical order and not respect the order in Settings.json. Issue #5819.\n3.0.6 (2021-03-08) - Caching of last viewed page Introduced caching of the last viewed form page, so user is returned to this page when refreshing or coming back at a later time. Issue #5278.\n3.0.5 (2021-03-05) - Dependency patching Patching of external dependencies. Issue #5770.\n3.0.4 (2021-03-05) - Bugfix for text styling in titles/descriptions Fix issue where label and description texts would get cut off mid word. Issue #5810.\n3.0.3 (2021-03-02) - Bugfix for metadata with layoutsets Fix issue where app-frontend feched wrong metadata when using layoutsets. Issue #5624.\n3.0.2 (2021-02-26) - Dependency patching Patching of external dependencies. Issue #5676.\n3.0.1 (2021-02-25) - Horizontally aligned components \u0026amp; Bugfix for loading options App-frontend now supports horizontally aligned components. See docs for more information. Issue #1515.\nFix issue that only loaded options related to form layout in first data task - for subsequent data tasks options were not loaded. Issue #5619.\n3.0.0 (2021-02-23) - New font for App Frontend This version changes the font for the app frontend from Roboto to Altinn-DIN. For the apps to show fonts as expected, some changes need to be made. See breaking changes for the details.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i versjon 3.",
	"content": "3.5.1 (2021-03-11) - Possible to get ruleconfiguration for apps with layout sets There was a bug resulting in av 404 response whenever it is attepmpted to retrieve the ruleconfiguration for an application while specifying the layout set id in the request. This has now been fixed.\n3.5.0 (2021-03-10) - Added funcionality for pdf generation for application owner Up until now a pdf copy has not been generated for the tasks that are completed by the application owner. This has now been implemented and pdf should be generated after a task regardless if it is an end user of the app owner that completes the task.\n3.4.0 (2021-03-10) - Endpoint and functionality for get page order made available All apps now expose an endpoint for getting the current page order based on the current state of an instance. Default behavior is to return the page order as defined in Settings.json to override, add the function below in Logic/App.cs and include your own logic.\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } 3.3.0 (2021-03-04) - Retrieving certificate from Key Vault now uses name The ISecret service now requires certificate name as input for retrieving a certificate from key vault. Previously this has been the certificate id, but this identificator contains more information that an app developer might have available, so the service has been simplified.\n3.2.3 (2021-02-17) - Fixed duplicate key exception on options When using the same option key in an option result a duplicate key exception was thrown that crashed the app. This is now fixed, and keys that already exist in the option result will not be added.\n3.2.1 (2021-02-10) - Correctly set unread status when instantiated by end user The instance now appears as read in the messagebox if it is instantiated by an end user through api, regardless if they have opened the instance in GUI or downloaded the form data they just posted.\n3.2.0 (2021-02-02) - Options displayed with label in PDF Before this release the selected option was shown with it\u0026rsquo;s value rather than the label that the end user was presented with during form filling. This has now been fixed so the label is diplayed in the pdf.\n3.1.6 (2021-01-29) 3.1.5 (2021-01-27) 3.1.4 (2021-01-26) 3.0.4 (2021-01-26) - Swagger support for Apps We have added Swashbuckle to the App. It is a library that brings Swagger support and this is especially handy when developing an HTTP based API. It creates a form of interactive documentation based on the OpenAPI Specification. To describe the Api\u0026rsquo;s better, we use the xml documentation file.\nThis documentation will be generated automatically when the application is build. Existing api\u0026rsquo;s and new api\u0026rsquo;s created in the app will be documented.\nThe documentation will appear at https://[org].apps.altinn.no/[org]/[app]/swagger/index.html in the app.\nTo enable this, there\u0026rsquo;s some changes.\n  Updated package dependencies, generate xml documentation file and copy xml documentation for Altinn.App.Api Navigate to you application repository and find App.csproj in the App folder.\nUpdate nuget dependencies in App.csproj to version 3.0.4, add new property for Altinn.App.Api.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.4\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml \u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.4\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.4\u0026#34; /\u0026gt; This is new in App.csproj\n\u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;5.6.3\u0026#34; /\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;Target Name=\u0026#34;CopyXMLFromPackagesForBuild\u0026#34; AfterTargets=\u0026#34;Build\u0026#34;\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReferenceFiles Condition=\u0026#34;%(PackageReference.CopyToOutputDirectory) != \u0026#39;\u0026#39;\u0026#34; Include=\u0026#34;$(NugetPackageRoot)$([MSBuild]::Escape(\u0026#39;%(PackageReference.Identity)\u0026#39;).ToLower())/%(PackageReference.Version)/%(PackageReference.CopyToOutputDirectory)\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;Copy SourceFiles=\u0026#34;@(PackageReferenceFiles)\u0026#34; DestinationFolder=\u0026#34;$(OutDir)\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt;   Changes to the Startup.cs file. If you don\u0026rsquo;t have any custom code in this, copy file from here.\nAdd this to the end of the ConfigureServices method\n// Add Swagger support (Swashbuckle)  services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Altinn App Api\u0026#34;, Version = \u0026#34;v1\u0026#34; }); IncludeXmlComments(c); }); Add this before app.UseRouting() in the Configure method\nstring applicationId = GetApplicationId(); if (!string.IsNullOrEmpty(applicationId)) { app.UseSwagger(o =\u0026gt; o.RouteTemplate = applicationId + \u0026#34;/swagger/{documentName}/swagger.json\u0026#34;); app.UseSwaggerUI(c =\u0026gt; { c.SwaggerEndpoint($\u0026#34;/{applicationId}/swagger/v1/swagger.json\u0026#34;, \u0026#34;Altinn App API\u0026#34;); c.RoutePrefix = applicationId + \u0026#34;/swagger\u0026#34;; }); } Add two methods\nprivate void IncludeXmlComments(SwaggerGenOptions options) { try { string fileName = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; string fullFilePath = Path.Combine(AppContext.BaseDirectory, fileName); options.IncludeXmlComments(fullFilePath); string fullFilePathApi = Path.Combine(AppContext.BaseDirectory, \u0026#34;Altinn.App.Api.xml\u0026#34;); options.IncludeXmlComments(fullFilePathApi); } catch { // Swagger will not have the xml-documentation to describe the api\u0026#39;s.  } } private string GetApplicationId() { string appMetaDataString = File.ReadAllText(\u0026#34;config/applicationmetadata.json\u0026#34;); JObject appMetadataJObject = JObject.Parse(appMetaDataString); return appMetadataJObject.SelectToken(\u0026#34;id\u0026#34;).Value\u0026lt;string\u0026gt;(); }   3.0.1 (2021-01-19) 3.0.0 (2021-01-05) - Support for dynamics in PDF We have added a new PDF handler to make it possible to hide pages and components in PDF. See breaking changes for how to update you app to be compatible with this version.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i versjon 4.",
	"content": "4.15.2 (2021-10-04) - Nytt endepunkt for å hente ut aktive instanser' Altinn Apps eksponerer nå et endepunkt for å hente ut aktive instanser for en gitt avgiver. Det nye endepunktet er tilgjengelig på {org}.apps.altinn.no/{org}/{app}/instances/{instanceOwnerPartyId}/active.\nDenne endringen tilhører issue 6767.\n4.14.1 (2021-09-22) - 500 error when retrieving non existing instance fixed There was a bug causing a 500 response when an request is made towards Get/Instances for a non-existing instance. This has now been fixed and the response returned is 403. Swagger for the endpoint is updated to reflect possible response codes.\n4.14.0 (2021-09-13) - Partial support for namespace XML The code that deserializes XML has been updated to support namespace declaration in the root element.\nExample:\n\u0026lt;Skjema xmlns=\u0026#34;urn:no:altinn:skjema:v1\u0026#34;\u0026gt; \u0026lt;Navn\u0026gt;Altinn\u0026lt;/Navn\u0026gt; \u0026lt;/Skjema\u0026gt; Deserialization occurs when an external system uses the app API to submit a new form, when they overwrite an existing form, and when an app retrieves a form from blob storage.\nThe change is not automatically used by all apps that update to this version. For the change to take properly effect the C# class that represents the model must be updated. The class needs to be decorated with an XmlRootAttribute with the Namespace property set to the correct namespace.\nExample:\n[XmlRoot(ElementName = \u0026#34;Skjema\u0026#34;, Namespace = \u0026#34;urn:no:altinn:skjema:v1\u0026#34;)] public class Skjema { [MaxLength(100)] [XmlElement(\u0026#34;Navn\u0026#34;)] public string Navn { get; set; } } This change must be done manually for all old and new models. The model editor in altinn.studio has not be updated to do this automatically.\n4.13.0 (2021-09-03) - Event for changed substatus on instance Changing the substatus of an instance triggers an event app.instance.substatus.changed which can be subscribed to in the event component.\nThis solves issue #6691\n4.12.0 (2021-08-27) - Identity data is included in the request telemetry for all requests In Application Insights we now register the properties listed below enabling linking of an entity to a specific request received by the application.\n partyId authentication level userId organisationNumber  This solves issue #5983\n4.11.1 (2021-08-26) - No longer possible to cache response from stateless apps Caching of the stateless data responses is no longer possible.\nThis solves issue #6532\n4.11.0 (2021-08-03) - Support for disabling reportee selection in Altinn Portal Apps now support adding query parameter DontChooseReportee=true to disable the reportee selection when an unauthorized user accesses an app. The result being that the user will represent themselves and be routed directly to the application after login.\nThis release solves issue #6573.\n4.10.2 (2021-07-15) - Text resources are loaded locally  The app will now load texts from the locally stored text resource files (config/texts/*) instead of retrieving them from Storage. Texts are still uploaded to Storage during deploy. The change is to remove unnecessary calls to Storage and to avoid an issue with caching that prevented new texts from being used immediately. #6466, #6415 Fixed a bug where a filename with space in it could lead to a crash. #6421 New apps created after the v2021.29 release will provide security headers like X-Frame-Options, X-XSS-Protection, X-Content-Type-Options, and Referer-Policy. To activate this in existing apps follow these steps:  Open the App/Startup.cs file. At the top of the file add the namespace reference: using Altinn.App.Api.Middleware; Find the Configure method and add the statement: app.UseDefaultSecurityHeaders(); Add it right before existing app.Use* statements. E.g. before app.UseRouting();    4.9.2 (2021-07-08) - Fixed messages from multipart request validation Validation messages from multipart request validation was misleading. This release solved issue #6418.\n4.9.1 (2021-07-02) - Bugfix for errors in multipart validation Fixed a bug that caused validation messages to show C# type of DataType rather than DataTypeId. Issue #6418\n4.9.0 (2021-06-29) - Support for marking a single field validation error as fixed It is now possible to mark a previous validation error as fixed by using the prefix *FIXED* in front of the original error. documentation on how to implement the functionality (in Norwegian )\n4.8.0 (2021-06-22) - Application version number available in AppSettings During app deployment an environment variable with the app version number/name is added to the app runtime environment. This version information can now be retrieved in any controller or service through the AppSettings configuration object. Just add a dependency on AppSettings into the class and access the new property called AppVersion.\n4.7.1 (2021-06-15) - Adjustments to response headers Some of the controllers exposed by the applications have been modified to not allow caching and/or storage of their responces in the client.\n4.7.0 (2021-06-08) Altinn Apps now authorize access for statless apps.\nAltinn Apps now have two new application events where application developers can add data processing logic. calculation, population, and more.\nIn this update the RunCalculate application event is made obsolete/deprecated. It\u0026rsquo;s recommended that Apps are updated to use RunProcessDataWrite and RunProcessDataRead instead. Calls to the RunCalculate method will be removed in a future update.\nThe process to update is\n Add the DataProcessing folder and DataProcessingHandler class from our app template to your app. Update App.cs. Add a class field for DataProcessingHandler and copy new methods ( RunProcessDataRead and RunProcessDataWrite) from App.cs Move logic from calculation handler to DataProcessinghandler Remove RunCalculation method from App.cs Remove CalculationHandler when code has been moved to DataProcessingHandler. Compile and test your app.  See details about data processing here\n4.6.2 (2021-06-01) - Duplicate keys in options causing crash This release has a fix for a crash related to PDF rendering when an app have options with duplicate entries. #5887\n4.6.1. (2021-05-21) Changed alternative subject Altinn Apps now uses org instead of organization as subject when publishing events.\n4.6.0 (2021-05-11) - Apps now support data fields Altinn Apps now support data fields. Data fields allows for adding data values, from either form fields or a custom source, to the instance object. Form data can be added by configuring data fields in applicationmetadata.json while custom sources require coding. Documentation on how to add data values to an instance can be found here.\n4.5.2 (2021-05-04) - Endpoints for stateless data elements exposed through app. Bug stopping local testing fixed Altinn Apps now expose endpoints for creating, prefilling and running calculations on stateless data elements. A stateless data element entails there is no link to an instance or instance owner, and the data is simply presented to the end user, but not persisted in any database.\nIn addition, a bug breaking apps running with localtest intoduced in 4.4.1 has been fixed.\nInformation on the new endpoints can be found in the swagger exposed by each application https://{org}.apps.altinn.no/{org}{app}/swagger\n4.4.1 (2021-04-30) - Ask user to upgrade security level An app would show the \u0026ldquo;unknown error\u0026rdquo; message if a user were trying to access an instance with a security level that was too low for the instance. This has been fixed. The user is now sent to authentication with the option to pick an authentication method that provides a higher security level. The fix targets the GET instance endpoint specifically.\n4.4.0(2021-04-27) - Performance fix Improved performance.\n4.3.0 (2021-04-28) - Apps now support presentation fields Altinn Apps now support presentation fields. By specifying presentation fields in applicationmetadata.json, speficied data values from the form data will be stored on the instance in order to show them along with the app title in the Altinn messagebox. Further documentation on how to configure presentation fields is found here.\nThis change is related to this epic.\n4.2.0 (2021-04-19) - Possible to integrate an app with eFormidling Altinn Apps now support integration with eFormidling. Documentation on how to set up an application to use eFormidling will be published once an integration point for eFormidling is set up in Altinn Platform.\n4.1.0 (2021-04-07) - Add new property with updated data to response for PUT to DataController During PUT of data to DataController ({org}/{app}/instances/{instanceOwnerPartyId:int}/{instanceGuid:guid}/data), any calculations that are defined by the apps are run, and data is potentially updated before being saved. Previously, the response returned only the metadata for the updated data element, and a GET to fetch the updated data was necessary. In this version, a dictionary of all the fields that have updated data from calculations is returned as a new parameter in the API response (in addition to the data element metadata), so that clients do not need to perform the additional GET request in order to get the updated data.\nThis change is related to this issue.\n4.0.3 (2021-03-23) - Fixed a bug reading filename from Content-Disposition  The specification for Content-Disposition specify that filename should be in quotes. This was not supported by the app backend API, causing requests following the specification to fail. This has been fixed. Added support for filename* (FilenameStar). If Content-Disposition contain both filename and filename*, the value defined by filename* will be used.  4.0.1 (2021-03-15) - Upgraded application to .Net 5 and grouped references of Altinn App and Altinn Platform services in Startup.cs Altinn.App.* librarires target .Net 5 now, which requires that the application does the same. In addition we have created two methods for referencing all app and platform sevices in Startup.cs\nSee breaking changes for how to update you app to be compatible with this version.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/handbook/",
	"title": "Utviklingshåndbok",
	"tags": ["development"],
	"description": "Utviklingshåndbok for bidrag til kodebasen i Altinn.",
	"content": "Håndbok for utvikling er foreløpig kun tilgjengelig på engelsk.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/settings/",
	"title": "Innstillinger for felt",
	"tags": [],
	"description": "Innstillinger for tekster knyttet til et felt.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt direkte i form layout inntil videre.\nMERK: Denne funksjonaliteten krever app-frontend versjon 3. Se denne lenken.\n\rIndikere at felt er valgfritt Det er mulig å styre om et felt er markert som valgfritt eller ikke. Normal oppførsel er at felt som er valgfrie blir markert som valgfrie.\nNormal oppførsel kan overstyres ved hjelp av innstillinger knyttet til feltbeskrivelsen. Dette gjøres via labelSettings på en komponent i form layout.\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;labelSettings\u0026#34;: { \u0026#34;optionalIndicator\u0026#34;: false } } } Ved å sette optionalIndicator til false vil teksten, som indikerer at feltet er valgfritt, ikke bli vist. Det er ikke mulig å tvinge visning av Valgfri teksten på et felt som er obligatorisk. Denne innstillingen styrer ikke feltets faktiske egenskaper.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/instance/",
	"title": "Instans",
	"tags": [],
	"description": "Hvordan gjøre endringer på applikasjonsinstanser",
	"content": "Denne siden er foreløpig ikke fullstendig, mer informasjon vil komme på et senere tidspunkt.\nEn instansiert applikasjon vil ha et tilhørende instans-objekt. Dette objektet inneholder metadata om den spesifikke instansen. Om du ønsker å lære mer om instans og api\u0026rsquo;et rundt så kan du lese teknisk dokumentasjon om dette under API.\nSubstatus Som app-eier kan man sette en substatus på instansen, dette for å kunne gi sluttbruker ytterligere informasjon om hvilken tilstand instansen befinner seg i. Substatus vil vises frem både i meldingsboksen i Altinn og på kvitteringssiden.\nSubstatusen er et objekt som kan settes på instansobjektet. Hvordan dette gjøres står beskrevet under API. Substatus er et enkelt objekt som inneholder label og description. Disse feltene kan enten inneholde ren tekst, eller en tekstnøkkel som referer til applikasjonstekstene. Verdt å merke seg at vi ikke støtter variabler i tekst for disse tekstene. I meldingsboksen er det satt en begrensning på 25 tegn på label, og inneholder label mer enn 25 tegn vil bare de 22 første tegnene bli brukt og \u0026ldquo;\u0026hellip;\u0026rdquo; lagt til på slutten.\nEksempel på et substatus-objekt:\n{ \u0026#34;label\u0026#34;: \u0026#34;some.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beskrivelse i klarteskst\u0026#34; } Under ser du du eksempler på hvordan substatus ser ut i meldingsboksen og i kvitteringen hvor substatusen er satt opp på følgende måte:\n{ \u0026#34;label\u0026#34;: \u0026#34;Godkjent\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Din søknad er godkjent av kongen.\u0026#34; } Automatisert sletting av utkast Som applikasjonseier kan man i noen tilfeller ønske å slette sluttbrukerens utkast av en tjeneste dersom det har gått en viss tid siden instansiering. For å oppnå dette er det tre steg som må tas.\n Applikasjonen må konfigureres slik at tjenesteeier har lov til å slette instanser Identifiser hvilke instanser som ikke er fullført v.h.a. spørring mot storage Slette instans via endepunkt eksponert i applikasjonen  Steg 1: Konfigurasjon av applikasjon Standarden for en applikasjon er at tjenesteeier ikke har lov til å slette instanser. For å få lov til dette må det legges til en ny regel i policy.xml den finnes i App/config/authorization. Regelen kan kopieres fra regelbiblioteket.\nSteg 2: Identifiser hvilke instanser som ikke er fullført v.h.a. spørring mot storage Storage eksponerer et sett med queryparametre som kan brukes når man skal hente ut et sett med instanser. i eksempelet nedenfor får man ut alle instanser som av en gitt applikasjon som er instansiert 30. september 2020 eller tidligere, og som enda står i utfyllingssteget.\nHer kan man prøve seg litt fram for å finne de rette queryparameterene for akkurat deres tjeneste.\nHTTP GET https://platform.altinn.no/storage/api/v1/instances?appId={org}/{app}\u0026amp;created=lte:2020-09-30\u0026amp;process.currentTask=Task_1\nSteg 3: Slette instans via endepunkt eksponert i applikasjone Når man har identifisert instansene som skal slettes er det en smal sak å sende et kall til applikasjonen for å få slettet disse. Da må id på instansen (instanceOwner.partyId/instanceGuid) oppgis.\nHTTP DELETE https://ttd.apps.altinn.no/ttd/apps-test/instances/{instanceOwner.partyId}/{instanceGuid}\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/instantiation/",
	"title": "Instansiering",
	"tags": [],
	"description": "Hvordan legge til logikk som skal kjøres ved instansiering?",
	"content": "Introduksjon Applikasjonslogikk knyttet til instansiering kan defineres i InstantiationHandler.cs. For en helt ny app vil det være to funksjoner implementert i denne klassen:\n RunInstantiationValidation - lag egne sjekker for å avgjøre om en bruker/avgiver får lov til å instansiere. DataCreation - lag tilpasset prefill data.  Egendefinerte valideringsregler for instansiering Som tidligere nevnt, kan sjekker for instansiering defineres i RunInstantiationValidation. Tilgang til Register- og Profile-tjenester er inkludert i InstantiationHandler.cs-filen, som tillater å gjøre sjekker mot disse. Valideringsregler for instansiering kan innebære å validere tidspunkt til spesifikke brukerrestriksjoner og komplekse sjekker som krever eksterne API-kall.\nEksempel 1 - Insansiering kun tillatt før kl 15:00 på en gitt dag public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { DateTime now = DateTime.Now; if (now.Hour \u0026lt; 15)  { return new InstantiationValidationResult() { Valid = false, Message = \u0026#34;ERROR: Instantiation not possible before 3PM.\u0026#34; }; } return null; } Eksempel 2 - Instansiering kun tillatt for applikasjonseier Kodebasen som eksempelet er basert på er tilgjengelig her. (krever innlogging i altinn.studio)\nFor å kunne begrense instansiering til en gitt entitet, i dette tilfellet applikasjonseier, er det to filer som må endres: App.cs og InstantiationHandler.cs.\nI App.cs tilgjengeliggjøres http-konteksten og brukerdata (claims principals) hentes ut fra konteksten ved å kalle _httpContext.User.\nFor å validere instansieringen kan man sjekke ett av to claims i konteksten. Enten organisasjonsen trebokstavsforkortelse eller organisasjonsnummeret. Valideringen skjer i InstantiationHandler.cs og eksempelet nedenfor bruker organisasjonsforkortelsen.\nFor å validere basert på organisasjonsnummer kan du følge eksempelet nedenfor, og bytte ut AltinnCoreClaimTypes.Org med AltinnCoreClaimTypes.OrgNumber.\nom må gjøres i denne file ser du nedenfor.\npublic async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance, ClaimsPrincipal user) { var result = new InstantiationValidationResult(); string org = string.Empty; if (user.HasClaim(c =\u0026gt; c.Type == AltinnCoreClaimTypes.Org)) { Claim orgClaim = user.FindFirst(c =\u0026gt; c.Type == AltinnCoreClaimTypes.Org); if (orgClaim != null) { org = orgClaim.Value; } } if (!string.IsNullOrWhiteSpace(org) \u0026amp;\u0026amp; org.Equals(\u0026#34;ttd\u0026#34;)) { result.Valid = true; } else { result.Valid = false; result.Message = \u0026#34;Only ttd is allowed to instantiate this application.\u0026#34;; } return await Task.FromResult(result); } Eksempel 3 - Instansiering kun tillatt mellom gitte datoer For å kunne begrense instansiering til en gitt tidsrom, i dette eksempelet januar 2021, er det én fil som må endres:InstantiationHandler.cs.\nMetoden RunInstantiationValidation vil kjøre hver gang noen prøver å instansiere applikasjonen, så her plasseres logikk for å verifiere at tidspunktet er innenfor den tillatte rammen.\npublic async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { InstantiationValidationResult result = null; DateTime now = TimeZoneInfo.ConvertTime(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById(\u0026#34;Central European Standard Time\u0026#34;)); if (now \u0026lt; new DateTime(2021, 01, 01)) { result = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated before 1.1.2021\u0026#34; }; } else if (now \u0026gt; new DateTime(2021, 01, 31)) { result = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated after 25.1.2021\u0026#34; }; } return await Task.FromResult(result); } Det er lagt inn logikk knyttet til datohåndtering for å forsikre oss om at det er norsk tid som gjelder og som blir brukt i valideringen.\nDateTime now = TimeZoneInfo.ConvertTime(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById(\u0026#34;Central European Standard Time\u0026#34;)); Videre gjøres det en enkel sjekk for å se om nåværende tidspunkt er innenfor rammene\n(now \u0026lt; new DateTime(2021, 01, 01) Dersom man ikke oppfyller kravene blir returobjektet populert med et InstantiationValidationResult objekt som inneholder to felter: Valid: en boolean som benyttes for å si om instansieringen er gyldig eller ikke Message: en string som kan inneholde en feilmelding dersom det ikke er gyldig\nresult = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated before 1.1.2021\u0026#34; }; I tillegg har man muligheten til å legge benytte property ValidParties: en liste med de partiene som kan instansiere applikasjonen.\nResultatet av en feilet validering er vist nedenfor:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/calculation/",
	"title": "Kalkuleringer",
	"tags": [],
	"description": "Hvordan legge til kalkuleringer?",
	"content": "Kalkulering er fra 4.7.0 erstattet av dataprosessering. Se her\nKalkulering Kalkuleringer kjøres på serveren, og er basert på input fra sluttbruker/skjemadata. Kalkuleringer trenger ikke å være rent matematiske, det kan også være å overføre verdier mellom felter, resultater av API-kall, osv.\nKalkuleringer kodes i C#, i filen CalculationHandler.cs. Denne filen kan redigeres enklest ved å laste ned kildekoden til app\u0026rsquo;en og redigere på egen maskin, f.eks. i Visual Studio Code. Datamodellen med skjemadata er tilgjengelig og kan redigeres/oppdateres etter ønske/behov.\nKalkuleringer kjøres hver gang data lagres. Med auto-lagring på (dette er standard) vil kalkulering kjøres hver gang en bruker har gjort en endring og hopper ut av et felt.\nVIKTIG: Når en kalkulering er kjørt som har oppdatert dataene på server, må front-end få beskjed om dette, sånn at de oppdaterte dataene kan lastes inn.\rFor å gjøre dette, må `Calculate`-metoden returnere `true` om det er noen av dataene som har blitt oppdatert.\rHvis dette ikke gjøres, vil de oppdaterte dataen ikke være synlig for sluttbruker før de ev. laster inn siden på nytt.\r\rEksempel på kode som erstatter en gitt verdi (12345678) med en annen verdi (22222222) i et gitt felt vises under:\npublic bool Calculate(object data) { if (data.GetType() == typeof(Skjema)) { // Cast the data object to model type to access all fields  Skjema model = (Skjema)data; // Get the existing value of a specified field, if it exists  string tlf = model? .OpplysningerOmArbeidstakerengrp8819? .OpplysningerOmArbeidstakerengrp8855? .OppgavegiverTelefonnummerdatadef27335?.value; // Check if the value exists and is equal to \u0026#34;12345678\u0026#34;  if (tlf != null \u0026amp;\u0026amp; tlf == \u0026#34;12345678\u0026#34;)  { // Replace the value in the field with a new value, \u0026#34;22222222\u0026#34;  model .OpplysningerOmArbeidstakerengrp8819 .OpplysningerOmArbeidstakerengrp8855 .OppgavegiverTelefonnummerdatadef27335.value = \u0026#34;22222222\u0026#34;;  // Return true to trigger a re-loading of data  return true; } } // Return false if no changes have been made  return false; } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/consume/",
	"title": "Konsumere APIer i en app",
	"tags": [],
	"description": "En applikasjon kan konsumere åpne og lukkede API som er tilgjengelig via Internett.",
	"content": "ASP.NET Core har gode muligheter til å konsumere forskjellige typer API.\nDette kan være nyttig dersom man ønsker å eksponere organisasjonens egne API via en app eller har behov for hjelp fra eksterne API i applikasjonslogikken.\nDet er mange måter å gjøre dette på, og på denne siden finner du eksempler på hvordan man kan konsumere REST APIer i en app.\nKalle et eksternt API direkte i en metode I dette eksemplet brukes et åpent API til å kalkulere et felt i skjemaet basert på input i et annet felt. Klientkallet implementeres direkte i kalkuleringsmetoden og det implementeres en modell for å kunne parse API responsen.\nREST Countries tilbyr et API som returnerer fakta om et land dersom man sender med navnet på landet. Vi ønsker å lage en app som tilbyr en bruker å søke opp hovedstaden i et land ved å bruke deres åpne API-endepunkt: https://restcountries.eu/rest/v2/name/.\nAPI-kallet er lagt til i kalkuleringsmetoden i App/logic/CalculationHandler slik at et nytt søk trigges hver gang man endrer et felt i appen.\nForutsetninger:\n Det er laget en app i Altinn Studio. Det er lastet opp en datamodell som beskriver verden bestående av land med et navn og en hovedstad. Autogenerert C# klasse av datamodellen er utvidet med JSON-property tags for å kunne gjenbruke klassen i parsing av API responsen.  Implementasjon:\n/// \u0026lt;summary\u0026gt; /// Perform calculations and update data model /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;The data\u0026lt;/param\u0026gt; public async Task\u0026lt;bool\u0026gt; Calculate(object instance) { if (instance.GetType() == typeof(Verden)) { Verden verden = (Verden)instance; string navn = verden?.land?.Navn; if (!string.IsNullOrEmpty(navn)) { using var client = new HttpClient  { BaseAddress = new Uri(\u0026#34;https://restcountries.eu/rest/v2/name/\u0026#34;); }; HttpResponseMessage response = await client.GetAsync(navn);  if (response.StatusCode == System.Net.HttpStatusCode.OK) { var land = await response.Content.ReadAsAsync\u0026lt;List\u0026lt;Land\u0026gt;\u0026gt;(); Land l = land.FirstOrDefault(); verden.land.Hovedstad = l.Hovedstad; } else { verden.land.Hovedstad = $\u0026#34;Hmm.. Du skrev {navn}. Er det et land?\u0026#34;; } } } return true; } Konsumere REST API uten klientbibliotek I dette eksemplet setter man opp en klient som konsumerer et åpent API til bruk i ulike deler av appen. Vi dekker oppsett av et klient interface, implementasjon av klient, tilgjengeliggjøring av klienten i appen og dependency injection inn i ulike klasser.\nHvis REST API\u0026rsquo;et ikke tilbyr et klientbibliotek for sitt API må dette opprettes som en del av applikasjonen eller som et ekstern bibliotek.\nDefinere API modeller Hvis API-et som skal konsumeres er dokumentert ved hjelp av Swagger eller OpenAPI kan man relativt lett genere C# klasser basert på datamodellen. Dette kan gjøres manuelt eller ved hjelp av verktøy som tilbyr slik generering. Bruker man Visual Studio kan man konvertere dette direkte. Velg \u0026ldquo;Paste JSON as classes\u0026rdquo;.\nusing System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; namespace Altinn.App.services.br.models { public class Enhet { public string organisasjonsnummer { get; set; } public string navn { get; set; } public Organisasjonsform organisasjonsform { get; set; } public Adresse postadresse { get; set; } public string registreringsdatoEnhetsregisteret { get; set; } public bool registrertIMvaregisteret { get; set; } public Naeringskode naeringskode1 { get; set; } public int antallAnsatte { get; set; } public Adresse forretningsadresse { get; set; } public string stiftelsesdato { get; set; } public Institusjonellsektorkode institusjonellSektorkode { get; set; } public bool registrertIForetaksregisteret { get; set; } public bool registrertIStiftelsesregisteret { get; set; } public bool registrertIFrivillighetsregisteret { get; set; } public string sisteInnsendteAarsregnskap { get; set; } public bool konkurs { get; set; } public bool underAvvikling { get; set; } public bool underTvangsavviklingEllerTvangsopplosning { get; set; } public string maalform { get; set; } public Links _links { get; set; } } } Eksempel modeller for API ses her.\nDefinere Klient Interface Det anbefales at det defineres et interface for klienten som skal kalle API. Dette gjør at man kan benytte seg av dependency injection ved enhetstesting for å kunne mocke vekk API kall. Definer interface som vist nedenfor.\nusing Altinn.App.services.br.models; using System; using System.Collections.Generic; using System.Linq; using System.Threading.Tasks; namespace Altinn.App.services.br.client { public interface IEnhetsregisteret { Task\u0026lt;Enhet\u0026gt; GetEnhetAsync(string orgnr); } } Eksempel interface kan sees her.\nImplementere klient Klienten er selve koden som gjøre kallene mot API og omformer resultatet til gitt datamodell.\nusing Altinn.App.services.br.models; using Newtonsoft.Json; using System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Threading.Tasks; namespace Altinn.App.services.br.client { public class EnhetsregistreretCI : IEnhetsregisteret { private HttpClient _apiClient; public async Task\u0026lt;Enhet\u0026gt; GetEnhetAsync(string orgnr) { string apiUrl = $\u0026#34;enheter/\u0026#34; + orgnr; var result = new Enhet(); HttpResponseMessage respons = await ApiClient.GetAsync(apiUrl);  if (respons.StatusCode == System.Net.HttpStatusCode.OK) { string data = respons.Content.ReadAsStringAsync().Result; result = JsonConvert.DeserializeObject\u0026lt;Enhet\u0026gt;(data);  } return result; } public HttpClient ApiClient { get { if (_apiClient != null) { return _apiClient; } string url = \u0026#34;https://data.brreg.no/enhetsregisteret/api/\u0026#34;; _apiClient = GetNewHttpClient(url); return _apiClient; } } private HttpClient GetNewHttpClient(string apiEndpoint) { var httpClient = new HttpClient { BaseAddress = new Uri(apiEndpoint) }; return httpClient; } } } Eksempel kan sees her.\nSett opp klient i applikasjon Når tjenesten med interface og klient er implementert kan den settes opp for bruk av applikasjonen.\nDette gjøres i App/Startup.cs hvor det settes opp interface og implementasjon av interface som tilbyr en gitt service til applikasjonen.\n// Custom service used by this application services.AddTransient\u0026lt;IEnhetsregisteret, EnhetsregistreretCI\u0026gt;(); Eksempel kan sees her\nKonsumere API fra applikasjonslogikk/API kontrollere For å få tak i service som er satt opp i applikasjonen må disse \u0026ldquo;injectes\u0026rdquo; inn i konstrukturøen på kontrolleren eller applikasjonslogikken.\nusing System.Threading.Tasks; using Altinn.App.services.br.client; using Altinn.App.services.br.models; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc; namespace Altinn.App.controllers { [ApiController] [Route(\u0026#34;{org}/{app}/enhetsregisteret\u0026#34;)] public class EnhetsregisteretController : ControllerBase { private IEnhetsregisteret _enhetsregisteret; public EnhetsregisteretController(IEnhetsregisteret enhetsregisteret) { _enhetsregisteret = enhetsregisteret;  } [HttpGet(\u0026#34;enhet/{orgnr}\u0026#34;)] public async Task\u0026lt;ActionResult\u0026lt;Enhet\u0026gt;\u0026gt; GetEnhet([FromRoute] string orgnr) { Enhet enhet = await _enhetsregisteret.GetEnhetAsync(orgnr);  return Ok(enhet); } } } Eksempel kan sees her.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/message/",
	"title": "Melding",
	"tags": [],
	"description": "Hvordan sette opp en melding i Altinn Studio.",
	"content": "En melding i Altinn 3 er egentlig bare et data-steg, på samme måte som f.eks. skjemautfylling. Det settes opp med en datamodell for meldingen, og en layout for hva som skal vises på siden. Melding er dermed ikke en egen steg-type. Dette gjør at en melding i Altinn 3 er ekstremt fleksibel, og kan settes opp enten som eneste steg i en prosess, eller som en del av en større prosess.\nVi har lagd noen verktøy som skal gjøre det enkelt å komme i gang med å sette opp en melding i en app.\nDatamodell Vi har lagd en standard datamodell for meldinger, for å gjøre det enkelt å komme i gang. Denne datamodellen kan man finne her. Denne kan enten brukes som den er, brukes som et utgangspunkt, eller man kan bruke en helt annen datamodell.\nLayout Layout\u0026rsquo;en kan man definere helt selv, på samme måte som for skjema. Vi har allikevel opprettet en meldings-widget, for å gjøre det enklere å komme i gang. Denne widget\u0026rsquo;en inneholder alle komponentene som trengs for å lage visningen under. Den inneholder også tekster som legges til i ressurs-filene automatisk, som har variabler med referanser til feltene Title og Body i standard datamodell. Dersom man ønsker andre tekster eller å bruke en annen datamodell, er det bare å redigere enten komponentene eller tekstene etter ønske etter at de er lagt inn i siden.\nMerk at om en ønsker å bruke _vedleggslisten_, som er med i standard meldings-widget, må man i tillegg manuelt legge inn hvilke _datatyper_ vedleggene som skal vises har i layout-filen. Det er lagt inn en placeholder for dette i komponenten når den legges til med widget'en. Funksjonalitet for å sette dette i Altinn Studio vil komme senere. Tilgjengelige datatyper ligger i `applicationMetadata.json`-filen til appen. Om dette ikke gjøres vil ikke generering av PDF fungere.\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/migration/",
	"title": "Migrering til versjonerte charts",
	"tags": [],
	"description": "Migrering fra helm template filer til versjonert helm dependency.",
	"content": "For å forenkle oppraderings prosessen av deployment charts har vi flyttet template filene ut et sentralt repository på github. Fra her publiseres helm charts som igjen draes inn i apps repoene som avhengigheter.\nDette gir oss muligheten til å oppdatere standard måte for deploy til altinn3 i et sentralt repository og forenkler jobben for tjenesteiere ved oppgradering.\nHvordan avdekke om din app bruker gammel deployment stretegi Åpne opp appen din i gitea eller hent siste versjon ned til din datamaskin med git.\nHvis mappen som heter deployment ser ut som nedenfor:\ndeployment\r├── .helmignore\r├── Chart.yaml\r├── templates\r│ ├── NOTES.txt\r│ ├── _helpers.tpl\r│ ├── deployment.yaml\r│ ├── horizontalPodAutoscaler.yaml\r│ ├── ingressRoute.yaml\r│ ├── middleware.yaml\r│ └── service.yaml\r└── values.yaml\rog innholdet i filen deployment/Chart.yaml er lignende dette:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 Benytter din applikasjon gammel deployment strategi og du kan følte guiden for hvordan du skal oppgradere til ny her.\nHvis mappen deployment ser sut som nedenfor:\ndeployment\r├── .helmignore\r├── Chart.yaml\r└── values.yaml\rog innholdet i `deployment/Chart.yaml er lignende dette:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Benytter din applikasjon siste deployment strategi.\nMigrere til ny deployment strategi Migreringen er rimelig enkel og involverer bare tre endringer i mappen deployment:\n Slett mappen templates. Definer avhengigheten til den sentralt vedlikeholde helm-charten i din Chart.yaml. dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Your Chart.yaml should now look like this:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0  Legg til en ny linje i toppen av values.yaml og skriv inn deployment: på denne linjen. Legg til to space først på hver linje etter dette (yaml behandler tab og mellomrom forskjellig så forsikre deg om at det er mellomrom). Gitt at din values.yaml ser ut som det her: replicaCount: 3 image: # Set \u0026#34;repository\u0026#34; name of your image for manual Helm install and upgrade. repository: tag: latest pullPolicy: Always pullSecrets: # Change this to the name of your pull secret - name: acr-secret service: name: deployment type: ClusterIP externalPort: 80 # If your application is running on another port, change only the internal port. internalPort: 5005 linkerd: enabled: true ingressRoute: name: Will be inserted during deploy entryPoints: - http - https routes: - match: Will be inserted during deploy kind: Rule services: - name: Will be inserted during deploy port: 80 middlewares: - name: hsts-header tls: options: name: tls-options secretName: ssl-cert volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken Etter at du har gjort dine migrerings endringer bør denne se ut som følger:\ndeployment: replicaCount: 3 image: # Set \u0026#34;repository\u0026#34; name of your image for manual Helm install and upgrade. repository: tag: latest pullPolicy: Always pullSecrets: # Change this to the name of your pull secret - name: acr-secret service: name: deployment type: ClusterIP externalPort: 80 # If your application is running on another port, change only the internal port. internalPort: 5005 linkerd: enabled: true ingressRoute: name: Will be inserted during deploy entryPoints: - http - https routes: - match: Will be inserted during deploy kind: Rule services: - name: Will be inserted during deploy port: 80 middlewares: - name: hsts-header tls: options: name: tls-options secretName: ssl-cert volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken   Commit og Push dine endringer til gitea og neste deploy av din applikasjon vil være med ny deployment strategi\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/goals/",
	"title": "Mål",
	"tags": ["translate-to-norwegian"],
	"description": "Oppsummering av målene for Altinn 3.",
	"content": "User friendly and responsive apps  User interface that is user friendly, effective and modern. Support for Responsive Design both for forms and the development tool. Built in accessability with support for WCAG 2 Good performance and low response time  Effective and self-serviced development  As a developer you can do everthing yourself (including deployment to production) whenever you want, without need for orders, training ++. Bottlenecks is eliminated. Effective and real testing, where unit test works like in a test environment and produiction. Support for creating automated tests of apps Rules and logic is defined once for all channels (portal/web service / rest), and are more robust than current plattform Built inn data modelling in web based tool (and support for XSD import from external tools like SERES, OR, etc. ) Not nescessery with Citrix for access to Altinn Studio  Simple for non-technical developers, flexible for technical developers  Non-technical app developers have access to needed functionality in browser You can reuse good and testet components/widgets It is easy to do call against API\u0026rsquo;s in other systems (retrieve data, run external logic) Techincally skilled deveopers can configure all aspect of the apps, as an example make a reusable widgets, stylesheets ++ Reuse of text and other resources on the desired level (platform, org, app), all languages supported Git (version control) are used for source control for the apps, both from browser and code editior.  Open Source, cross-platform  Altinn 3 will be based on open source Altinn 3 will be open source Altinn 3 can run on your own computer, own serwers on Windows, macOS or Linux Everything is based on open web-standardes and regulaer development knowledge.  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/org/",
	"title": "API test org",
	"tags": [],
	"description": "Når man kjører applikasjonene lokalt sammen med den lokale testplattformen kan man teste API som applikasjon eksponerer.",
	"content": "Appen har en rekke API som kan benyttes av applikasjonseier/tjenesteeier. Beskrivelsen du finner her er laget for Postman hvor det er benyttet testapplikasjonen MVA testapp.\nPostman-prosjektet kan lastes ned fra her (høyreklikk og velg \u0026ldquo;save as\u0026rdquo;).\nAutentisering av tjenesteier org I testmiljø og produksjon brukes maskinporten for å autentisere organisasjoner som eier apper.\nTestplattformen for lokal testing tilbyr et enkelt api for å autentisere organisjonen som er ansvarlig.\nMan trenger bare å oppgi tjenesteeier kode (som f.eks brg, skd osv)\nUrl: http://altinn3local.no/Home/GetTestOrgToken/ttd (ttd needs to be replaced with the org you want to authenticate)\nThe response is a JWT token that should be uses as a Authorization header.\nMultipart instansiering Applikasjonene støtter at man instansierer instanser til aktører. Personer eller organsiasjoner.\nUrl: http://altinn3local.no/ttd/mva/instances\nMetode: POST\nHeaders:\n Authorization: Bearer + jwttoken Content-Type: multipart/form-data; boundary=\u0026ldquo;abcdefg\u0026rdquo;  Eksempel Body:\n--abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34;  { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;organisationNumber\u0026#34; : \u0026#34;897069650\u0026#34; } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;RF0002\u0026#34;  \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;212\u0026#34; spesifikasjonsnummer=\u0026#34;10420\u0026#34; blankettnummer=\u0026#34;RF-0002\u0026#34; tittel=\u0026#34;Alminnelig omsetningsoppgave\u0026#34; gruppeid=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;GenerellInformasjon-grp-2581 gruppeid=\u0026#34;2581\u0026#34;\u0026gt; \u0026lt;Avgiftspliktig-grp-50 gruppeid=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;RapporteringsenhetNavn-datadef-21771 orid=\u0026#34;21771\u0026#34;\u0026gt;DDG Fitness\u0026lt;/RapporteringsenhetNavn-datadef-21771\u0026gt; \u0026lt;RapporteringsenhetAdresse-datadef-21773 orid=\u0026#34;21773\u0026#34;\u0026gt;Sofies Gate 1\u0026lt;/RapporteringsenhetAdresse-datadef-21773\u0026gt; \u0026lt;RapporteringsenhetPostnummer-datadef-21774 orid=\u0026#34;21774\u0026#34;\u0026gt;0170\u0026lt;/RapporteringsenhetPostnummer-datadef-21774\u0026gt; \u0026lt;RapporteringsenhetPoststed-datadef-21775 orid=\u0026#34;21775\u0026#34;\u0026gt;By\u0026lt;/RapporteringsenhetPoststed-datadef-21775\u0026gt; \u0026lt;RapporteringsenhetOrganisasjonsnummer-datadef-21772 orid=\u0026#34;21772\u0026#34;\u0026gt;897069650\u0026lt;/RapporteringsenhetOrganisasjonsnummer-datadef-21772\u0026gt; \u0026lt;/Avgiftspliktig-grp-50\u0026gt; \u0026lt;/GenerellInformasjon-grp-2581\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- Example Response The below response show how an instance was created for a given organization.\n1{ 2 \u0026#34;id\u0026#34;: \u0026#34;500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 3 \u0026#34;instanceOwner\u0026#34;: { 4 \u0026#34;partyId\u0026#34;: \u0026#34;500000\u0026#34;, 5 \u0026#34;personNumber\u0026#34;: null, 6 \u0026#34;organisationNumber\u0026#34;: \u0026#34;897069650\u0026#34; 7 }, 8 \u0026#34;appId\u0026#34;: \u0026#34;ttd/mva\u0026#34;, 9 \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, 10 \u0026#34;selfLinks\u0026#34;: { 11 \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/mva/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 12 \u0026#34;platform\u0026#34;: \u0026#34;https://localhost:5101/storage/api/v1/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34; 13 }, 14 \u0026#34;dueBefore\u0026#34;: null, 15 \u0026#34;visibleAfter\u0026#34;: null, 16 \u0026#34;title\u0026#34;: { 17 \u0026#34;nb\u0026#34;: \u0026#34;RF-0002\u0026#34; 18 }, 19 \u0026#34;process\u0026#34;: { 20 \u0026#34;started\u0026#34;: \u0026#34;2020-01-24T06:37:48.6026647Z\u0026#34;, 21 \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, 22 \u0026#34;currentTask\u0026#34;: { 23 \u0026#34;flow\u0026#34;: 2, 24 \u0026#34;started\u0026#34;: \u0026#34;2020-01-24T06:37:48.6027116Z\u0026#34;, 25 \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, 26 \u0026#34;name\u0026#34;: \u0026#34;Utfylling\u0026#34;, 27 \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, 28 \u0026#34;ended\u0026#34;: null, 29 \u0026#34;validated\u0026#34;: null 30 }, 31 \u0026#34;ended\u0026#34;: null, 32 \u0026#34;endEvent\u0026#34;: null 33 }, 34 \u0026#34;status\u0026#34;: null, 35 \u0026#34;appOwner\u0026#34;: { 36 \u0026#34;labels\u0026#34;: null, 37 \u0026#34;messages\u0026#34;: null, 38 \u0026#34;canBeDeletedAfter\u0026#34;: null 39 }, 40 \u0026#34;data\u0026#34;: [ 41 { 42 \u0026#34;id\u0026#34;: \u0026#34;54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 43 \u0026#34;instanceGuid\u0026#34;: \u0026#34;b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 44 \u0026#34;dataType\u0026#34;: \u0026#34;RF0002\u0026#34;, 45 \u0026#34;filename\u0026#34;: null, 46 \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, 47 \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/mva/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 48 \u0026#34;selfLinks\u0026#34;: { 49 \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/mva/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 50 \u0026#34;platform\u0026#34;: \u0026#34;https://localhost:5101/storage/api/v1/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34; 51 }, 52 \u0026#34;size\u0026#34;: 1009, 53 \u0026#34;locked\u0026#34;: false, 54 \u0026#34;refs\u0026#34;: [], 55 \u0026#34;created\u0026#34;: \u0026#34;2020-01-24T06:37:48.641997Z\u0026#34;, 56 \u0026#34;createdBy\u0026#34;: null, 57 \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-01-24T06:37:48.641997Z\u0026#34;, 58 \u0026#34;lastChangedBy\u0026#34;: null 59 } 60 ], 61 \u0026#34;created\u0026#34;: \u0026#34;2020-01-24T06:37:48.6068671Z\u0026#34;, 62 \u0026#34;createdBy\u0026#34;: null, 63 \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-01-24T06:37:48.6068671Z\u0026#34;, 64 \u0026#34;lastChangedBy\u0026#34;: null 65} "
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/pdf/",
	"title": "PDF",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform PDF.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/presentations/",
	"title": "Presentasjoner og Altinn kaffe",
	"tags": [],
	"description": "The Altinn-kaffe meeting series is a low threshold meeting series, where app owners (and potential app owners) can learn more about what we&#39;re doing in Altinn 3. It&#39;s also designed to gather information on how Altinn can help app owners realise their Altinn 3 potential. Slides mainly in Norwegian.",
	"content": "Introduksjonspresentasjon og utbredelsesstrategimøte Det første møtet var en lengre introduksjon til plattformen og målene med den.\n Altinn 3 - hva og hvorfor?  Vi holdt et møte for at man skulle kunne gi input på Altinn 3 utbredelsesstrategi 28. januar 2021. Disse presentasjonene ble vist.\n Overordnet Strategi og tiltak Kort status fra Team Tjenestestøtte  Vi har også lagd en mer generell presntasjon om hva Altinn Studio / Altinn 3 er, og hvordan man kommer i gang\n Generell Presentasjon og Kom i Gang  Status og planer Annenhver uke presenterer vi hva vi har gjort og hva vi planlegger å gjøre den neste to-ukersperioden.\n Status og planer - 30. september 2020 Status og planer - 14. oktober 2020 Status og planer - 28. oktober 2020 Status og planer - 11. november 2020 Status og planer - 25. november 2020 Status og planer - 9. desember 2020 Status og planer - 6. januar 2021 Status og planer - 20. januar 2021 Status og planer - 3. februar 2021 Status og planer - 17. februar 2021 Status og planer - 3. mars 2021 Status og planer - 17. mars 2021 Status og planer - 14. april 2021 Status og planer - 28. april 2021 Status og planer - 12. mai 2021 Status og planer - 26. mai 2021 Status og planer - 9. juni 2021 Status og planer - 23. juni 2021 Status og planer - 26. august 2021 Status og planer - 9. september 2021 Status og planer - 23. september 2021 Det kommer mer\u0026hellip;  Temamøter Ukene vi ikke presenterer status, har vi temamøter.\n Hvordan komme i gang med Altinn 3? (7. oktober 2020) Altinns presentasjon | SSBs presentasjon Integrasjon med mottakssystem (21. oktober 2020) Hvordan bidra til et bedre Altinn 3? (4. november 2020) Signering i Altinn 3 (18. november 2020) Kalkulering i Altinn 3 (16. desember 2020) Hvordan bruke første halvtimen i Altinn Studio (27. januar 2021) Datamodellering i Altinn Studio (24. februar 2021) Lanserte tjenester (10. mars 2021) Arbeidstilsynets presentasjon | Presentasjon for Kartverket Planer for utvikling i Q2 2021 (7. april 2021) Tilgang til logger og hemmeligheter (21. april 2021) Altinn Events - inkludert mulighet for push (5. mai 2021) Datamodellering: Håndtering av utfasing av Seres (19. mai 2021) Case: Karantenehotellunntak (2. juni 2021) Standardisering vs. fleksibilitet (30. juni 2021) Kopiering av app (2. september 2021) Det kommer mer\u0026hellip;  NDC 2020 Dette er et foredrag som ble holdt 11. juni 2020 på NDC Oslo, der tre av utviklerne våre presenterer Altinn 3 like etter produksjonssetting.\nForedraget er på engelsk, men er tekstet på både engelsk og norsk.\n   Slides brukt under presentasjonen (pptx) Behind the scenes  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/profile/",
	"title": "Profile",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform Profile.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorisation/rules/",
	"title": "Regelbibliotek",
	"tags": [],
	"description": "Bibliotek av autorisasjonsregler som kan brukes i en app. Husk å bytte ut tags ([ORG], [APP], [RULE_ID]) med din egen data.",
	"content": "[ORG] kan instansiere [ORG]/[APP] [ORG_1] og [ORG_2] kan her være like eller ulike. I tilfellet at de er ulike vil [ORG_1] tilsvare applikasjonseieren og [ORG_2] være en annen organisasjon som får lov til å instansiere.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG_2] can instantiate an instance of [ORG_1]/[APP]\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG_2]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG_1]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;instantiate\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rollen REGNA can lese instanser av [ORG]/[APP] som er i Task_1 Ved å endre på rolle og task i denne regelen vil du kunne gi rettigheter til å lese instansdata på en gitt task i prosessflyten.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA can read instances of [ORG]/[APP] when it is in Task_1\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;Task_1\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:task\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan skrive til en instans av [ORG]/[APP] uavhengig av prosessflyt Denne regelen kan brukes dersom applikasjonseier skal kunne oppdatere instanser uavhengig av hvor de er i prosessflyten sin.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG] can write to instances of [ORG]/[APP] in any task or event\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;write\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rollen REGNA eller DAGL kan bekrefte instanser av [ORG]/[APP] som er i Task_2 Denne reglen begrenser rettigheten til å bekrefte en instans i en bestemt task til kun to roller. Ved å enten modifisere task eller roller vil du her kunne sette regler for hvem som får bekrefte instansen i ulike faser av prosessen.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA or DAGL can confirm instances of [ORG]/[APP] when it is in Task_2\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;DAGL\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;Task_2\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:task\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;confirm\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rolle REGNA kan lese instanser av [ORG]/[APP] som er i EndEvent_1 Denne regler tillatter en bruker med den gitte rollen å lese instansdata etter at prosessen er avsluttet. Dette vil bl.a. inkludere å laste ned vedlegg og kvitteringer knyttet til instansen.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA can read instanes of [ORG]/[APP] when it is in EndEvent_1\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;EndEvent_1\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:end-event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Regel som definerer at [ORG] kan fullføre en instans av [ORG]/[APP] som har en fullført prosess. Denne regelen tillatter applikasjonseier å utføre en kvittering på at de er ferdig med en instans. Instansen må ha en fullført process.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;Rule that defines that [ORG] can complete an instance of [ORG]/[APP] which state is at the end event.\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;EndEvent_1\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:end-event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;complete\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan slette en instans av [ORG]/[APP] uavhengig av hvor den er i prosessen Denne regelen tillatter applikasjonseier å slette en instans. Dette kan gjøres uavhengig av hvor i prosessen instansen er.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG] can delete an instance of [ORG]/[APP] in any task or event.\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;delete\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan aksesserere med autentiseringsnivå 3 \u0026lt;xacml:ObligationExpressions\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel1\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation1-assignment1\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;4\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel2\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation2-assignment2\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel-org\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;3\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;/xacml:ObligationExpressions\u0026gt; "
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/register/",
	"title": "Register",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform Register.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/user/",
	"title": "API bruk som sluttbruker",
	"tags": ["todo"],
	"description": "Når man kjører applikasjonen lokalt så kan man teste API beregnet for sluttbruker.",
	"content": "TODO\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/enduser/",
	"title": "Sluttbrukerfunksjonalitet i Altinn 3",
	"tags": [],
	"description": "Dette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.",
	"content": "Lansert funksjonalitet For informasjon om hvordan man bruker funksjonalitetene som er beskrevet her, se brukerdokumentasjonen for Altinn Studio.\n\r\rSkjemafunksjonalitet Støtte for innsendingstjenester. Et utvalg standardkomponenter å bygge med (eks. tekstfelt, radioknapp, sjekkliste, datovelger, vedlegg, repeterende gruppe av komponenter), inkludert sidestilling av elementer (støtte for grid). Støtte for at skjemaet består av flere sider, men sluttbruker kan kun navigere framover/bakover mellom sidene (styrt navigasjon). Alle skjema og elementer har standardisert look and feel.\nStøtte for å sette opp ulike regler, herunder kalkulering, validering og dynamikk på både element- og sidenivå (dvs. styre hva som vises ut fra hva bruker fyller inn i skjemaet.)\nElementene kobles med tekster og knyttes til datamodell. Mulighet til å koble på API-er som datakilder, samt å forhåndsutfylle med data fra Altinns kopier av Folkeregisteret og Enhetsregisteret.\nVi støtter også innsynstjenester (rene oppslagstjenester) (#1328) ✔️\nArbeidsflyt i applikasjonen Du kan kombinere flere ulike steg i den rekkefølgen som er relevant for tjenesten:\n Utfylling/melding (data) - eksponering av data fra tjenesteeier og/eller innhenting av data fra sluttbruker Bekreftelse (confirm) - bruker skal bekrefte at dette er dataene de ønsker å sende inn Vente på tilbakemelding (feedback) - prosessen er ikke fullført, men det er andre enn bruker (tjenesteeier eller tredjepart) som skal gjøre noe  I tillegg har alle en sluttstatus for at instanser er arkivert/fullført.\nAutentisering og autorisasjon Det er støtte for å definere hvilke(n) rolle(r) som har tilgang til ulike operasjoner per steg i arbeidsflyten. Rollene kan enten være Altinn-roller, roller fra Enhetsregisteret eller at tjenesteeier selv har tilgang.\nIntegrasjon med meldingsboksen i Altinn Instanser av tjenester ligger i brukers meldingsboks på samme måte som i Altinn 2. Det er mulig å finne instansene ved bruk av søk (men med enkelte begrensninger).\nDu kan bruke presentasjonsfelter for å skille instanser av samme app fra hverandre (Q2 2021) (#594) ✔️\nTjenesteeier har selv mulighet til å angi hvilken status som er relevant for den enkelte instans. Det er også mulig å definere opp at instanser av en app aldri skal legges i brukers arkiv.\nIntegrasjon med sluttbrukersystemer Tjenestene har standardiserte API-er som kan benyttes for innsending fra tredjepartssystemer. Hver app har sine egne endepunkter. Autentisering av bruker skjer med ID-porten.\nKommende funksjonalitet Altinn 3 er i stadig videreutvikling, og funksjonalitet lanseres løpende. Backlogg revideres åtte ganger i året, og mindre endringer kan også forekomme mellom revisjonene. Generelt kan man si at jo lenger frem i tid leveranse er planlagt jo mer usikkert er angitt leveransetidspunkt.\nEndringer beskrevet i kursiv er å regne som på idéstadiet, og er ikke besluttet at skal utvikles. Lenker i parentes er til beskrivelser i vår åpne backlog på Github.\nSkjemafunksjonalitet Det skal være mulig å definere opp brukergrensesnitt som passer godt til den enkelte tjenestens behov. Eksempler på kommende funksjonaliteter:\n Friere navigering mellom sider (Q4 2021) (#5893) Utfyllbare tabeller (Q4 2021) (#378) Mulighet for å endre språk inne i applikasjonen (Q1 2022) (#2055). Denne endringen gjør det også mulig å tilby tjenester på andre språk enn bokmål/nynorsk/engelsk. Ulike «tema» for brukergrensesnittet i portalen (#2115)  Arbeidsflyt i applikasjonen Vi vil utvide biblioteket med tilgjengelige arbeidsflytsteg for å dekke stadig flere bruksområder. Eksempler på kommende funksjonaliteter:\n Funksjonell signering (Q4 2021) (#5540) Teknisk signering (Q1 2022) Komplekse signeringsregler - f.eks. basert på hva som fylles ut i skjemaet og parallellsignering (x av y personer skal signere) (Q2 2022) (#1324) / (#1325) Betaling (Q3 2022) (#1320) Friere navigering mellom stegene i prosessen (Q4 2021) (#2743) Innhenting av samtykke  Autentisering og autorisasjon Vi skal tilby minst samme fleksibilitet for brukerne til å styre hvem som har tilgang til Altinn 3-tjenestene som finnes i Altinn II. Det innebærer f.eks. følgende endringer:\n Støtte for delegering på app-nivå (Q4 2021) (#2731) Støtte for delegering på instansnivå (Q4 2021) (#2732) Tilgang til app med virksomhetsbruker (#3743) Whitelisting av aktuelle brukere for en app (#5547)  Hendelsesstyrte tjenester For å bygge sammenhengende tjenestekjeder, uten at man må bygge kompleks orkestrering, er det nødvendig at en tjeneste skal kunne \u0026ldquo;reagere\u0026rdquo; på hendelser i en annen app, eller på eksterne hendelser. Å legge til rette for denne måten å lage tjenestekjeder ligger i planene for andre halvår 2022.\nVarslinger (e-post og sms) Å sende ut varsler på e-post og/eller sms er en viktig del av flere tjenester. Inntil videre vil Altinn 3 bruke varslingsfunksjonaliteten i Altinn II.\n Det skal være mulig å koble varslingene til ulike hendelser i appene (Q1 2022) (#4275) Sluttbruker selv skal kunne sende e-post av kvitteringen (Q3 2022) (#1902)  Integrasjon med meldingsboksen i Altinn Det skal være lett å finne riktig instans av en tjeneste i meldingsboksen. For å få til dette legger vi til:\n Støtte for å lage ny instans med utgangspunkt i en eksisterende - lag ny kopi (Q2 2021) (#1566) Sjekk av om man allerede har en instans av app i meldingsboks, slik at man får velge mellom ny instans eller fortsette på eksisterende (Q2 2021) (#1811) Mulighet for å søke i innholdet i instansene (#5450)  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/storage/",
	"title": "Storage (Lagring)",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Platform Storage.",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/",
	"title": "Storage Interface endringslogg",
	"tags": [],
	"description": "Oversikt over endringer introdusert i Altinn.Platform.Storage.Interface NuGet package.",
	"content": "\rv3\rOversikt over endringer introdusert i v3 av Altinn.Platform.Storage.Interface.\n\r\rv2\rOversikt over endringer som ble introdusert i v2 av Altinn.Platform.Storage.Interface.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/studio/",
	"title": "Studio",
	"tags": ["swagger"],
	"description": "API dokumentasjon for Altinn Studio Repos.",
	"content": "Se https://altinn.studio/repos/api/swagger\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/platform/swagger/",
	"title": "Swagger",
	"tags": [],
	"description": "Open API-spesifikasjoner for Altinn 3 Platform API.",
	"content": "\rAuthentication (Autentisering)\rAPI dokumentasjon for Altinn Platform Authentication.\n\r\rAuthorization (Autorisasjon)\rAPI dokumentasjon for Altinn Platform Authorization.\n\r\rEvents (Hendelser)\rAPI dokumentasjon for Altinn Platform Events.\n\r\rPDF\rAPI dokumentasjon for Altinn Platform PDF.\n\r\rProfile\rAPI dokumentasjon for Altinn Platform Profile.\n\r\rRegister\rAPI dokumentasjon for Altinn Platform Register.\n\r\rStorage (Lagring)\rAPI dokumentasjon for Altinn Platform Storage.\n\r\rStudio\rAPI dokumentasjon for Altinn Studio Repos.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/swagger/",
	"title": "swagger",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/testusers/",
	"title": "Testbrukere lokalt",
	"tags": [],
	"description": "Vi har definert et lite sett med testbrukere som er tilgjengelig for lokal test.",
	"content": "Disse kan man velge når man logger inn i lokal test.\nSophie Salt Sophie er en svært driftig dame som bor i Oslo. Hun har startet en kjede med treningsententer som heter DDG Fitness og til nå er det startet 3 underenheter i Oslo, Bergen og Trondheim. Sophie har rollen DAGL og dens underroller for DDG Fitness AS og dens underhenheter.\nI tilegg er hun ekspert på helse og har startet eget konsulentfirma for helsetjenester. Sophie har rollen LEDE + knyttede roller for EAS Health Consulting.\nHun er også styremedlem i borettslaget der hun bor. \u0026ldquo;Oslos Vakreste Borettslag\u0026rdquo;. Sophie har rollen MEDL + knyttede roller for \u0026ldquo;Oslos Vakreste Borettslag\u0026rdquo;.\nAvgivere    Avgiver Roller     01039012345 Sophie Salt Privatperson   897069650 DDG Fitness AS Daglig leder + knytninger   897069651 DDG Fitness Bergen Daglig leder + knytninger   897069652 DDG Fitness Oslo Daglig leder + knytninger   897069653 DDG Fitness Trondheim Daglig leder + knytninger   897069631 EAS Health Consulting Styreleder + knytninger   950474084 Oslos Vakreste Borettslag Styremedlem + knytninger    Ola Nordmann. Ola Nordmann er en privatperson som kun kan representere seg selv. Er bosatt på Stokmarknes.\nAvgivere  01017512345 Ola Nordmann  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/customize/",
	"title": "Tilpasse visninger av steg",
	"tags": [],
	"description": "Hvordan tilpasse visninger i forskjellige steg av en prosess.",
	"content": "En applikasjon vil ha en prosess som brukeren av applikasjonen vil følge. Avhengig av hvilken type steg brukeren er i, vil forskjellige ting vises. Denne siden vil forklare hvordan visningen til de forskjellige stegene kan tilpasses.\nData (tilsvarer utfyllingssteg i Altinn II) I denne prosess-task-typen vises skjema som kan fylles ut.\nSkjema kan redigeres ved bruk av UI editoren eller ved å endre FormLayout.json direkte.\nBekreftelse (Confirmation) I denne prosess-task-typen vises noen standard-tekster, og bruker kan velge å bekrefte for å gå videre.\nTekstene kan overstyres, ved at man legger inn tekstnøkkel som hører til hver tekst i språkfilene for appen. Info om hvordan dette gjøres finner du her. Se under for oversikt over de forskjellige tekstnøklene som kan overstyres.\nI tillegg kan man legge inn statiske data som kan presenteres til sluttbruker, markert med 5 i bildet under.\nOverstyre tekster    Tekst nr. (se bilde over) Tekstnøkkel     1 confirm.title   2 confirm.body   3 confirm.attachments   4 confirm.button_text    Eksempel på overstyrte tekster i filen resources.nb.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;confirm.title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Vennligst bekreft at du ønsker å sende inn\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.body\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du må kun trykke send inn om du er helt sikker på at du vil sende inn. \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;I det du trykker send inn kan du ikke gjøre endringer.\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.attachments\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Dokumenter med opplysninger\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.button_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Lagre og fortsett\u0026#34; } Merk at i eksempelet over har vi brukt html-taggen \u0026lt;br/\u0026gt; for å lage linjeskift. For lenke og utheving, benytt markdown.\nDette resulterer i følgende visning:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/todo/",
	"title": "todo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/translate-to-norwegian/",
	"title": "translate-to-norwegian",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/designer/ui-editor/",
	"title": "UI editor",
	"tags": [],
	"description": "Hvordan bygge et skjema med UI editor i Altinn Studio.",
	"content": "Bygge et skjema ved bruk av UI editor UI Editor er tilgjengelig i fanen Lage når man er inne i en app i Altinn Studio.\nBruke skjemakomponenter Skjemakomponentene kan trekkes inn i arbeidsområdet (i midten) fra menyen til venstre. Man kan deretter endre rekkefølgen på dem ved hjelp av drag and drop i arbeidsområdet.\nNår du holder muspekeren over en komponent, eller når du velger den ved å klikke på den, blir to ikoner synlig - et søppelbøtte-ikon for å slette komponenten, og et blyant-ikon for å endre på egenskapene til komponenten.\nSe oversikten over skjemakomponenter for mer detaljer om komponentene som er tilgjengelig.\nRedigere egenskapene til komponentene Hver komponent har et sett med egenskaper som kan redigeres, for eksempel kobling til tekster og kobling til datamodell osv. For å endre på egenskapene, klikk blyant-ikonet som vises når du holder musepekeren over komponenten du vil endre på.\nGjør deretter endringene du ønsker, og lagre dem ved å klikke på hake-ikonet til høyre for egenskapsredigeringen. Du kan forkaste endringene ved å klikke på kryss-ikonet.\nMERK: UI-editoren og kompoentene er under utvikling. Det vil derfor være perioder der ikke alle egenskaper kan settes i UI-editor.\r\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/",
	"title": "v1",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v1 av deployment.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i deployment i v1.1.0\n\r\rHva er nytt\rOversikt over endringer som ble introdusert i v1 av deployment.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/validation/",
	"title": "Validering",
	"tags": [],
	"description": "Hvordan legge til logikk for å validere skjemadata?",
	"content": "Introduksjon Valideringer sørger for at brukerens input er gyldig med tanke på datamodellen, i tillegg til alle egendefinerte regler som settes opp for applikasjonen. Valideringer kan kjøres enten på klient (dvs. browseren) eller serversiden.\nKlientside-validering Dette er validering som kjøres i browseren, FØR data er sendt til server for lagring. Dette gjør det mulig å gi raske tilbakemeldinger til sluttbruker underveis i utfylling.\nKlientside-validering baserer seg på datamodellen som hører til skjemaet, og bruker denne til å bestemme hva som er gyldig input i et felt. Helt konkret brukes JSON Schema utgaven av datamodellen for valideringen. Denne genereres automatisk når man laster opp XSD. Det går an å gjøre endringer i JSON schema direkte for å tilpasse valideringen ved behov.\nMerk at dersom man gjør tilpasninger i JSON schema manuelt, for å så oppdatere XSD og laste inn på nytt, vil nytt JSON schema også genereres, og alle manuelle tilpasninger må gjøres på nytt. Derfor er det anbefalt å gjøre endringer i XSD og/eller datamodelleringsverktøyet for at disse endringene skal reflekteres i JSON schema.\nEt eksempel på hvordan et felt kan defineres i JSON schema datamodellen er:\n\u0026#34;someField\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: \u0026#34;4\u0026#34; } Input i dette feltet vil valideres mot begrensningene som er satt opp, og en feilmelding vil vises dersom disse ikke møtes - i dette tilfellet, dersom input er en tekst med lengde mer enn 4 karakterer.\nStandard feilmeldinger Det er satt opp standard feilmeldinger for alle valideringene som gjøres på klientsiden. Se oversikten under.\n   Regel Feilmelding bokmål Feilmelding nynorsk Feilmelding engelsk     min \u0026lsquo;Minste gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Minste gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Minimum valid value is {0}\u0026rsquo;   max \u0026lsquo;Største gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Største gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Maximum valid value is {0}\u0026rsquo;   minLength \u0026lsquo;Bruk {0} eller flere tegn\u0026rsquo; \u0026lsquo;Bruk {0} eller flere tegn\u0026rsquo; \u0026lsquo;Use {0} or more characters\u0026rsquo;   maxLength \u0026lsquo;Bruk {0} eller færre tegn\u0026rsquo; \u0026lsquo;Bruk {0} eller færre tegn\u0026rsquo; \u0026lsquo;Use {0} or fewer characters\u0026rsquo;   length \u0026lsquo;Antall tillatte tegn er {0}\u0026rsquo; \u0026lsquo;Antall tillatte tegn er {0}\u0026rsquo; \u0026lsquo;Number of characters allowed is {0}\u0026rsquo;   pattern \u0026lsquo;Feil format eller verdi\u0026rsquo; \u0026lsquo;Feil format eller verdi\u0026rsquo; \u0026lsquo;Wrong format or value\u0026rsquo;   required \u0026lsquo;Feltet er påkrevd\u0026rsquo; \u0026lsquo;Feltet er påkrevd\u0026rsquo; \u0026lsquo;Field is required\u0026rsquo;   enum \u0026lsquo;Kun verdiene {0} er tillatt\u0026rsquo; \u0026lsquo;Kun verdiene {0} er tillatt\u0026rsquo; \u0026lsquo;Only the values {0} are permitted\u0026rsquo;    Egendefinerte feilmeldinger Det er mulig å definere egne feilmeldinger som skal vises når et felt får valideringsfeil. Dette gjøres ved å legge på en parameter errorMessage der hvor feltet er definert i JSON schema. F.eks., man kan utvide eksempelet over:\n\u0026#34;someField\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;myCustomError\u0026#34; } Man kan skrive ønsket tekst direkte inn her, eller bruke en tekstnøkkel for en tekst definert i ressursfilene for språkstøtte.\nMerk at ved XSD-endringer, så vil ev. egendefinerte feilmeldinger forsvinne da JSON schema filen genereres på nytt fra XSD. På sikt er det tenkt at det å sette opp egendefinerte feilmeldinger skal være mulig å gjøre via datamodelleringsverktøyet i Altinn Studio. Per nå må dette gjøres manelt.\r\rServerside-validering Serverside-validering kan deles opp i to kategorier:\n Valideringer mot datamodell - Disse kjører automatisk når brukeren prøver å sende inn skjemadata. Egendefinerte valideringer - Disse skrives av applikasjonsutvikleren, og kjører når brukeren prøver å sende inn skjemadata eller flytte prosessen til et nytt steg.  Hvordan legge til egendefinert validering Egendefinerte validering kan igjen deles opp i to kategorier; task-validering og data-validering.\n Task-validering vil kjøres hver gang validering trigges enten manuelt fra applikasjonen eller når man prøver å flytte seg framover i prosessen. Data-validering vil kjøre dersom man står på et steg som har definerte dataelementer knyttet til seg.  Valideringer er skrevet i C#, i ValidationHandler.cs -filen i applikasjonsmalen. Filen kan aksesseres og endres i Altinn Studio via logikkmenyen, ved å velge Rediger valideringer, eller direkte i applikasjonsrepoet der ligger filen i logic/Validation-mappen.\nEndringer gjøres i ValidateData og ValidateTask-metodene (disse er tomme når appen lages). Førstnevnte får inn et dataobjekt og sistnevnte får inn instansen og taskId. For å legge til en valideringsfeil brukes AddModelError-metoden til validationResults object som sendes med i begge metodene.\nEt eksempel på en enkel data-validering som sjekker at feltet FirstName ikke inneholder verdien 1337, når rotelementet til modellen er Skjema er vist nedenfor:\npublic void ValidateData(object data, ModelStateDictionary validationResults) { if (data.GetType() == typeof(Skjema)) { // Cast instance data to model type  Skjema model = (Skjema)data; // Get value to test - FirstName  string firstName = Skjema?.Person?.FirstName; // Check if FirstName exists, and contains the value \u0026#34;1337\u0026#34;  if (firstName != null \u0026amp;\u0026amp; firstName.Contains(\u0026#34;1337\u0026#34;))  { // Add validation error, with error message and list  // of affected fields (in this case Person.FirstName)  validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;Error: First name cannot contain the value \u0026#39;1337\u0026#39;.\u0026#34; ); } } } Se kommentarer i koden over for en forklaring på hva de ulike delene gjør.\nEt eksempel på en enkel task-validering som sjekker hvor lang tid brukeren har brukt på Task_1 og returnerer en feil dersom det har tatt lenger enn 3 dager.\npublic async Task ValidateTask(Instance instance, string taskId, ModelStateDictionary validationResults) { if (taskId.Equals(\u0026#34;Task_1\u0026#34;)) { DateTime deadline = ((DateTime)instance.Created).AddDays(3); if (DateTime.UtcNow \u0026lt; deadline)  { validationResults.AddModelError(\u0026#34;Task_1\u0026#34;, $\u0026#34;Ferdigstilling av Task_1 har tatt for lang tid. Vennligst start på nytt.\u0026#34;); } } } Enkeltfeltvalidering Dersom det er behov for umiddelbar validering av et felt som ikke kan dekkes i klientsidevalideringen, så kan man sette opp en trigger for validering på enkeltfelter i formLayout.json\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;3611fb2a-c06b-4fa7-a400-3f6c1ece64e1\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;25795.OppgavegiverNavnPreutfyltdatadef25795.Label\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;etatid\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;triggers\u0026#34;: [\u0026#34;validation\u0026#34;] , // \u0026lt;--- Add this field  }, { \u0026#34;id\u0026#34;: \u0026#34;9ec368da-d6a9-4fbd-94d0-b4dfa8891981\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Button\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Merk at dersom du definerer at et felt skal trigge validering på serverside, så er det kun resultatet av denne valideringen som vil vises. Det vil si at dersom det er annen klient-side validering som er definert, så vil en ev. server-validering av feltet overskrive disse. Pass derfor på å implementere alle nødvendige\rvalideringer på feltet også på server-siden, det går an å legge flere feilmeldinger på samme felt ved behov.\r\rKonfigurasjonen overfor vil resultere i at din egendefinerte validering i ValidationHandler.cs vil trigges hver gang feltet oppdaterer seg. Dersom du har behov for å vite hvilket felt som trigget valideringen er denne tilgjengelig i http-konteksten som en header på requesten ved navn ValidationTriggerField.\nEt eksempel på en egendefinert validering der headerverdien hentes ut er vist nedenfor.\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { _httpContextAccessor.HttpContext.Request.Headers.TryGetValue(\u0026#34;ValidationTriggerField\u0026#34;, out StringValues value); if (value.Count \u0026gt; 0 \u0026amp;\u0026amp; value[0].Equals(\u0026#34;kommune\u0026#34;)) { // Cast instance data to model type  flyttemelding model = (flyttemelding)data; // Get value to test - Kommune  string kommune = model.kommune; if (!kommune.Equals(\u0026#34;Oslo\u0026#34;)) { validationResults.AddModelError(value[0], \u0026#34;Dette er ikke en gyldig kommune.\u0026#34;); } } await Task.CompletedTask; } OBS Merk at validering av enkeltfelter bør implementeres slik at det kjører både på trigger og under generell validering. Eksempelet som omhandler flere komplekse valideringer viser hvordan dette kan implementeres.\nDet er gjort flere ting for å få denne kodesnutten til å kjøre\n I ValidationHandler.cs inkluderes using Microsoft.Extensions.Privites; øverst i filen for å kunne ta i bruk StringValues. I App.cs inkluderes using Microsoft.AspNetCore.Http; øverst i filen for å kunne ta i bruk IHttpContextAccessor. I App.cs dependency injectes IHttpContextAccessor i konstruktøren og sendes med videre til ValidationHandler.  public App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IHttpContextAccessor httpContextAccessor // \u0026lt;--- Add this line  ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); // \u0026lt;--- Include the new property here  _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService); } Dersom man har flere komplekse valideringer som er tidkrevende er det anbefalt å implementere flere private metoder for validering av disse og bruke ValidationTriggerField til å avgjøre hvilken private metode som skal kjøres. Man kan bl.a. bruke en switch statement for å oppnå dette.\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { if (data is flyttemelding model)) { _httpContextAccessor.HttpContext.Request.Headers .TryGetValue(\u0026#34;ValidationTriggerField\u0026#34;, out StringValues value); string dataField = value.Any() ? value[0] : string.Empty; switch (dataField) { case \u0026#34;kommune\u0026#34;: ValidateKommune(model, validationResults); break; case \u0026#34;boaddresse\u0026#34;: ValidateBoAdresse(model, validationResults); break; default: ValidateKommune(model, validationResults); ValidateBoAdresse(model, validationResults); break; } } } private void ValidateKommune(flyttemelding model, ModelStateDictionary validationResults) { if (model.kommune != null \u0026amp;\u0026amp; !model.kommune.Equals(\u0026#34;Oslo\u0026#34;)) { validationResults.AddModelError( nameof(model.kommune), \u0026#34;Dette er ikke en gyldig kommune.\u0026#34;); } } private void ValidateBoAdresse(flyttemelding model, ModelStateDictionary validationResults) { if (model.boaddresse != null \u0026amp;\u0026amp; model.boaddresse.Length \u0026gt; 150) { validationResults.AddModelError( nameof(model.boaddresse), \u0026#34;Boadresse kan ikke være lengere enn 150 tegn.\u0026#34;); } } Spesifisere at valideringsfeil er fikset Når validering trigges av et enkelt felt, så vil alle tidligere valideringer på dette feltet fjernes i påvente av svar fra den siste valideringen. Dersom et felt trigger validering som oppdaterer/legger til feilmelding på flere felter på en gang, vil ikke disse fjernes selv om det ikke lenger er noen feil i disse feltene. Dette er fordi man ikke har noen måte å vite hvilke felter som ev. er validert ifm en enkeltfeltvalidering.\nF.eks., dersom man har 2 felter: fornavn og etternavn. Begge felter trigger enkeltfeltvalidering, og dersom begge feltene har verdi så validerer man at fullt navn ikke kan være lengre enn 50 tegn. Feilmelding settes da på begge feltene. Dersom man retter opp i dette ved å endre fornavn, vil feilmeldingen fra fornavn-feltet forsvinne, men feilmeldingen som vises på etternavn-feltet vises fortsatt selv om valideringen ikke setter noen feilmeldinger på feltene.\nprivate void ValidateFullName(Datamodell model, ModelStateDictionary validationResults) { if (!string.isNullOrEmpty(model.fornavn) \u0026amp;\u0026amp; !string.isNullOrEmpty(model.etternavn) \u0026amp;\u0026amp; model.fornavn.Length + model.etternavn.Length \u0026gt; 50) { validationResults.addModelError(nameof(model.fornavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } } For å kunne fjerne gamle feilmeldinger i et sånt tilfelle, er det lagt til støtte for å kunne spesifisere at en valideringsfeil er fikset. Da vil det aktuelle feltet kunne få beskjed om at en spesifikk feilmelding som den viser frem er fikset og skal skjules.\nDette gjøres ved å legge til en valideringsfeil i koden i det tilfellet der det ikke er noen feil i valideringen, og sette *FIXED* foran selve feilmeldingen. Dette tilsvarer oppsettet for myk validering. Denne prefixen gjør at feilmeldingen som settes fjernes fra det aktuelle feltet, eller ignoreres (dersom det ikke er noen feilmelding på feltet fra før).\nMan kan da utvide eksempelet over for å støtte dette:\nprivate void ValidateFullName(Datamodell model, ModelStateDictionary validationResults) { if (!string.isNullOrEmpty(model.fornavn) \u0026amp;\u0026amp; !string.isNullOrEmpty(model.etternavn) \u0026amp;\u0026amp; model.fornavn.Length + model.etternavn.Length \u0026gt; 50) { validationResults.addModelError(nameof(model.fornavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } else { validationResults.addModelError(nameof(model.fornavn), \u0026#34;*FIXED*Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;);  validationResults.addModelError(nameof(model.etternavn), \u0026#34;*FIXED*Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;);  } } Myk validering Myke valideringer (eller advarsler) er valideringsmeldinger som ikke stopper bruker fra å sende inn eller gå videre til neste steg i prosessen. Denne typen valideringer kan f.eks. brukes til å be brukeren om å verifisere input som virker feil eller rart, men som strengt tatt ikke er ugyldig.\nMeldinger basert på myke validering vil vises en gang, men bruker kan velge å klikke seg videre uten å utføre endringer.\nMyke valideringer legges til fra server-siden i validerings-logikken, på samme måte som vanlige validerings-feil. Forskjellen er at valideringsmeldingen må prefixes med *WARNING*. Dette vil da tolkes som en myk validering. Prefixen *WARNING* blir ikke synlig for sluttbruker.\nKodeeksempel\npublic async Task ValidateData(object data, ModelStateDictionary modelState) { if (data is TestModel testModel) { string firstName = testModel?.Person?.FirstName; if (firstName != null \u0026amp;\u0026amp; firstName.Contains(\u0026#34;1337\u0026#34;)) { validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;*WARNING*Are you sure your first name contains 1337?\u0026#34;); } } await Task.CompletedTask; } Gruppevalidering Det er mulig å gjøre valideringer på en repeterende gruppe i det brukeren ønsker å lagre en gitt indeks. Dette gjøres ved å legge til en trigger på gruppe-komponenten i layoutfilen (f.eks FormLayout.json). Eksempel:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;demo-gruppe\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;...\u0026#34; ], \u0026#34;maxCount\u0026#34;: 3, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;Endringsmelding-grp-9786.OversiktOverEndringene-grp-9788\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;validation\u0026#34;] // \u0026lt;--- Legg til denne  }, ... ] } } Dette vil da sørge for at det vil kjøres validering på komponentene som er en del av gruppen på den aktuelle indeksen man jobber på. Om det finnes valideringsfeil så vil man stoppes fra å lagre gruppen før dette er rettet opp i.\nOm man legger til validering på gruppe-komponenten så vil det også gå et kall mot valideringen backend med en header som spesifiserer hvilken komponent som trigget valideringen: ComponentId. Valideringer er skrevet i C#, i ValidationHandler.cs-filen i applikasjonsmalen. I valideringen kan man så hente ut denne id\u0026rsquo;en og skreddersy eventuelle valideringer som skal gjøres backend, eksempel:\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { if (data is flyttemelding model)) { _httpContextAccessor.HttpContext.Request.Headers .TryGetValue(\u0026#34;ComponentId\u0026#34;, out StringValues value); string component = value.Any() ? value[0] : string.Empty; switch (dataField) { case \u0026#34;demo-group\u0026#34;: // kjør valideringer spesifikke til gruppen  break; default: // kjør valideringene i sin helhet  break; } } } For tips til hvordan man løser komplekse valideringer se ekemplene under enkeltfeltvalidering.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/open-source/",
	"title": "Altinn og åpen kildekode",
	"tags": [],
	"description": "Altinn 3 er åpen kildekode, med en åpen backlog, åpen dokumentasjon og åpen dialog og diskusjoner.",
	"content": "Det er flere som har fått med seg at Altinn har tatt en fundamentalt ny og åpen retning de siste årene.\nVi har fått litt spørsmål om hvorfor vi har gjort dette, og tenker det kan være interessant at vi deler våre tanker om åpen kildekode, som en sentral nasjonal felleskomponent.\nDeling og gjenbruk Det finnes mange gode grunner til å dele kode som åpen kildekode.\nNAV, en av de virkelig store inne åpen kildekode i Norge, er også inne på flere av de samme punktene, men særlig dette med viktigheten av gjennomsiktighet og tillit i forhold til løsninger finansiert av det offentlige.\nVi applauderer når NAV skriver dette:\n Offentlig finansierte løsninger bør være offentlig tilgjengelig.\nMotivasjonen er da ikke hovedsakelig gjenbruk, selv om det selvsagt er en heldig bieffekt. Motivasjonen er først og fremst åpenhet og gjennomsiktighet i de digitale løsningene.\n Gjenbruk er derimot noe vi i Altinn anser som en helt sentral motivasjon.\nOg vi er ikke alene om å tenke på denne måten, f.eks. gov.uk planen Open Source, Open Standards and Re­Use (PDF) beskriver gjenbruk som både en policy og et prinsipp.\nVi legger til rette for gjenbruk og deling på alle nivåer i arkitekturen, fra våre prinsipper til hele plattformen og infrastrukturen, ned til design og GUI-komponenter, kode og konfigurasjon.\nVi oppfordrer også alle de som utvikler på toppen av Altinn til å dele sine apps.\nDette er også en av flere grunner til at Altinn nå er et digitalt fellesgode (DPG), der målsettingen er å kunne gjenbruke det vi utvikler ikke bare på nasjonalt nivå, men også globalt.\nSamarbeid Den beste måten å få til et godt samarbeid på tvers av organisasjoner og prosjekter er åpenhet og gjennomsiktighet, at alle kan bidra, gi input, bli hørt, følge med på det som skjer.\nDet er dette som har vært helt sentralt i \u0026ldquo;revolusjonen\u0026rdquo; med åpen kildekode, som har blitt den nye normalen for store deler av programvareutvikling i verden. Det er nå 40 millioner utviklere og over 28 millioner åpne repos på GitHub.\nSiden alle våre verktøy og avhengigeheter ligger åpent på GitHub så kan også vi i Altinn følge med, samarbeide og bidra tilbake til programvare som vi benytter.\nEksempler på dette er .NET, Kubernetes, React, Linkerd og Gitea.\nOg vår issue #5992 er et godt eksempel på hvordan vi kan spore og enkelt lenke til saker på tvers av programvare.\nOg siden Altinn er åpen kildekode på GitHub, så er det like enkelt for alle andre å gjøre det samme mot oss. Både det å opprette nye issues, bidra i diskusjoner eller bidra med kode, noe labelen external-contribution-❤️ illustrerer godt.\nLeverandørbindinger Altinn som felleskomponent har tidligere fått store utfordringer ved å basere seg på lukket proprietær programvare. Programvare fra Adobe i Altinn 1 og fra Microsoft i Altinn 2.\nEnd-of-life for proprietær programvere er faktisk hovedårsaken til behovet for å lage Altinn 3.\nNår du bygger en løsning på toppen av proprietær programvare så har du i praksis mistet kontroll over egen fremtid, f.eks. om leverandøren velger å fase ut produktet. Om man baserer seg på åpen kildekode så kan man i en slik situasjon lage en fork, om ikke noen andre gjør det.\nAltinn 3 er derfor basert på programvare og biblioteker som er åpen kildekode.\nVi tenker at dette naturlig nok også er veldig viktig for de som vurderer om man skal ta i bruk Altinn.\nHvilke bindinger innfører vi til Altinn som teknisk løsning og Digdir som \u0026ldquo;leverandør\u0026rdquo;? Selv om Altinn er et samarbeid, så vil dette være viktige spørsmål.\nAltinn 3 er derfor helt åpen kildekode med liberal lisensiering, og alt som utvikles kjører som vanlige containere.\nDe beste verktøyene For å utvikle god programvare så er det viktig å ha tilgang til gode verktøy.\nEn ting som mange kanskje ikke tenker på er at når du deler det du utvikler som åpen kildekode, så blir mange av de aller beste verktøyene der ute tilgjengelig - helt gratis.\n\u0026ldquo;Del, og du blir delt med\u0026hellip;\u0026quot;\nHer er noen av de fantastiske SaaS-verktøyene som vi benytter:\n GitHub - Håndtering av kildekode, backlogs, boards, automatisering, CI/CD, etc. ZenHub - Epos, estimering, avhengigheter, rapporter. Cypress - Dashboards og automatisert testing av GUI. SonarCloud - Statisk analyse av kildekode. LGTM - Sikkerhetsanalyse av kildekode.  Og dette er bare et lite utvalg\u0026hellip;\nAlle verktøy og rammeverk som vi bygger Altinn på toppen av, er åpen programvare som er veldig godt likt.\nDe beste folkene Det er et gjennomgående tema at folk liker å jobbe med ny teknologi og de beste verktøyene. De beste utviklerne foretrekker også å jobbe med åpen kildekode, føle at man bidrar til noe større, at man setter spor.\nI tiden som har gått siden vi lanserte Altinn 3 så har vi ansatt en del veldig dyktige folk, og et gjennomganstema i intervjuer og diskusjoner er at de beste kandidatene er tydelige på at de synes det er viktig med åpen kildekode, og at dette er noe de ønsker å være med på.\nVi ønsker å bygge et stort community, der alle kan bidra, og da er det ekstremt viktig at vi har teams med dyktige og fornøyde utviklere som kan hjelpe til med å få det til å skje.\n"
}]