[
{
	"uri": "https://docs.altinn.studio/nb/app/design/insight/",
	"title": "Innsiktsfase",
	"tags": [],
	"description": "Først av alt bør du samle prosjektgruppen og starte med å definere problemet. Hva er det dere skal løse og hvem skal det løses for?",
	"content": "Tenk gjennom Hva er dagens utfordring? Start med å definere problemet. Hva er det dere skal løse? Med et klart avgrenset problem er det lettere å lage en klar løsning. Her kan det være en idé å samle prosjektgruppen, komme vekk fra møtebordet og bruke post-its på veggene. Hvem er brukerne og hvilke behov har de? Vi anbefaler at dere starter med å definere målgruppe og brukerbehov så tidlig som mulig i prosjektet. Lag en oversikt over hvem brukerne er. I de fleste tilfellene skal man lage løsninger som fungerer for flere brukergrupper. Er det innbyggere eller aktører i næringslivet? Hvilken bakgrunn har de? Er de digitale eller ikke så vant til å bruke digitale tjenester? I denne fasen gjøres det typisk innledende innsiktsarbeid i form av intervjuer, observasjoner eller fokusgruppe. Kontaktpunkter for brukeren Sett opp en oversikt/brukerreise over brukerens kontaktpunkt. Eksempel på hvordan en fragmentert brukerreise kan fortone seg: Skal Altinn være skjult for sluttbruker eller er det Altinns grensesnitt som skal benyttes? Stemmer dette med hvordan brukeren forventer å få løst sin oppgave? Er det mulig å tilby brukerne den relevante delen av altinn i den konteksten de er i, i stedet for å sende dem frem og tilbake? Hva er databehovet? Behovet for en digital løsning starter gjerne med at det er behov for å samle inn data. Start med å undersøke om andre har dataene du trenger og om disse er tilgjengelige for gjenbruk. Det kan du sjekke i Felles datakatalog. Hvis ikke - hvordan kan du spørre på en måte som krever minst mulig av brukerne? Noen ganger kan det være en idé å prøve noe annet enn opplagte løsninger hvor man spør i form av et skjema.  Når du har kommet deg gjennom innsiktsfasen og definert brukerbehov, anbefaler vi at du setter sammen en prototype som kan brukertestes på relevante brukere. Dersom du skal lage et skjema, kan du bruke vårt prototype-Kit for Figma.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/",
	"title": "Om Altinn 3",
	"tags": [],
	"description": "Altinn 3 er tredje generasjon plattform for å utvikle og kjøre digitale tjenester.",
	"content": "Plattformen er eid av Digitaliseringsdirektoratet og utviklet som en åpen kildekode-plattform.\nDen nåværende løsningen og plattformen (Altinn II - lansert i 2010) regnes av Gartner som en av verdens fem ledende plattformer for digitale myndigheter.\nPlattformen brukes av over 90 % av den norske befolknigen og nær 100 % av alle virksomheter Mer enn 62 etater, fylkeskommuner og kommuner bruker Altinn som platform for sine tjenester.\nDet finnes nær 1000 aktive tjenester på plattformen som dekker ulike bruksscenarier.\nEksempler på slike tjenester er skattemeldingen, rapportering av ulykker i luftfarten, meldinger fra forsvaret, oppslag mot data i Brønnøysundregistrene og mye, mye mer.\nKonsept Ved å bruke Altinn 3 kan etater og andre myndighetsutøvere bygge tjenester som fullverdige applikasjoner og produksjonssette dem som containere til deres isolerte infrastruktur i skyen. Altinn Platform gir appene kjernefunksjonalitet som lagring, autorisasjon, autentisering, tilgang på registerdatam med mer.\nInfrastrukturen er svært skalerbar for å støtte de ulike behovene tjenesteeierne har, og forvaltes av DevOps-teamet hos Altinn.\nApplikasjons-templaten som følger med Altinn Studio er gjort klar for de vanligste typene digitale tjenester, noe som gjør det mulig å lage og publisere de enkleste tjenestene i løpet av timer.\nNår applikasjonen er produksjonssatt til Altinn Apps er den tilgjengelig for så godt som alle privatpersoner og virksomheter i Norge.\nHvorfor Altinn 3? Det er mange grunner til å bruke Altinn 3 til å bygge og kjøre dine digitale tjenester.\n Applikasjons-template som har innebygd funksjonalitet for de vanligste bruksområdene for digitale tjenester Lett å utvikle og kjøre applikasjoner Gjenbruk av data, brukergrensesnitt, APIer og funksjonalitet En kjent plattform for sluttbrukerne Svært skalerbar og sikker infrastruktur Åpen kildekode Tilgang til så godt som alle privatpersoner og virksomheter i Norge  Når ble Altinn 3 lansert? Første versjon av Altinn 3 kom i juni 2020, og de første applikasjonene på løsningen ble satt i produksjon 19. juni 2020.\nHvordan lære mer om Altinn 3 Begynn gjerne med å lese om de ulike delløsningene i Altinn 3.\n Altinn Studio lar deg bygge dine digitale tjenester Altinn Apps lar deg kjøre dine digitale tjenester Altinn Platform gir deg standardfunksjonalitet til bruk i dine digitale tjenester  \rMål\rOppsummering av målene for Altinn 3.\n\r\rAltinn og åpen kildekode\rAltinn 3 er åpen kildekode, med en åpen backlog, åpen dokumentasjon og åpen dialog og diskusjoner.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/setup/",
	"title": "Oppsett for gruppering av felter",
	"tags": [],
	"description": "Generelt oppsett for gruppering av felter i skjema.",
	"content": "Felter i skjema kan settes opp til å bli del av en gruppe. Dette kan brukes til å f.eks. sette opp dynamikk på en enkelt gruppe av felter, i stedet for på hvert enkelt felt. I tillegg må felter kunnne grupperes for å støtte repeterende grupper i skjema.\nEn gruppe settes opp i FormLayout.json, sammen med de andre komponentene i skjemaet. Dette kan enten gjøres manuelt direkte i filen, eller via skjemaeditor i Atinn Studio ved å bruke Gruppe-komponenten.\nNoen punkter å notere seg ved manuelt oppsett:\n Gruppen må ligge før ev. komponenter som skal inngå i gruppen i FormLayout.json. En gruppe MÅ ha type: \u0026quot;group\u0026quot; satt for at den skal registreres som en gruppe  Eksempel på en (repeterende) gruppe definert i FormLayout.json som inneholder 4 felter som kan repetere 3 ganger: En gruppe defineres på følgende måte i FormLayout.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;\u0026lt;unik-id\u0026gt;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;group\u0026#34;,  \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;\u0026lt;gruppen i datamodellen (kun repeterende grupper)\u0026gt;\u0026#34; }, \u0026#34;maxCount\u0026#34;: \u0026#34;\u0026lt;Antall ganger gruppen kan repetere\u0026gt;\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34;, \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34;, \u0026#34;osv...\u0026#34; ],  \u0026#34;tableHeaders\u0026#34;: [ \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34; ], \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;add_button\u0026#34;: \u0026#34;tekstressurs.felt\u0026#34; } }    Parameter Påkrevd Beskrivelse     id Ja Unik ID, tilsvarer ID på andre komponenter. Må være unik i FormLayout.json-filen.   type Ja MÅ være \u0026ldquo;group\u0026rdquo;. Sier at dette er en gruppe.   dataModelBindings Nei MÅ være satt for repeterende grupper, med group-parameteren som i eksempelet over. Skal peke på den repeterende gruppen i datamodellen.   textResourceBindings Nei Kan være satt for repeterende grupper, se beskrivelse.   maxCount Ja Antall ganger en gruppe kan repetere. Settes til 1 om gruppen ikke er repeterende.   children Ja Liste over de feltene som skal inngå i gruppen. Her brukes felt-id fra FormLayout.json   tableHeaders Nei Liste over komponentener som skal inngå som en del av tabbel header feltene. Om ikke spesifisert så vises alle komponentene.    textResourceBindings Det er mulig å legge til ulike nøkler i textResourceBindings for å overstyre default tekster.\n add_button - blir lagt til på enden av \u0026ldquo;Legg til ny\u0026rdquo; teksten på knappen, og kan brukes til å f.eks ha tekst som sier \u0026ldquo;Legg til ny person\u0026rdquo;. save_button - blir brukt som tekst i \u0026ldquo;Lagre\u0026rdquo;-knappen når brukeren fyller ut data. edit_button_open - blir brukt som tekst i \u0026ldquo;Endre\u0026rdquo; knappen i tabellen når brukeren skal åpne et element. edit_button_close - blir brukt som tekst i \u0026ldquo;Endre\u0026rdquo; knappen tabellen når brukeren skal lukke et element.  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/repeating/",
	"title": "Repeterende grupper",
	"tags": [],
	"description": "Oppsett for repeterende grupper.",
	"content": "Grupper i datamodellen inneholder ett eller flere felter. Grupper er definert som repeterende dersom de har maxOccurs \u0026gt; 1 i xsd\u0026rsquo;en. En gruppe som er repeterende i datamodellen må også settes opp som repeterende i skjemaet, ellers vil lagring av data feile.\nEksempel Skjema med noen enkelt-felt, og en repeterende gruppe som:\n inneholder 3 felter kan repeteres opp til 3 ganger har lagt til egen streng på \u0026ldquo;legg til\u0026rdquo; knappen  Oppsett i FormLayout.json fra eksempelet over:\n1{ 2 \u0026#34;data\u0026#34;: { 3 \u0026#34;layout\u0026#34;: [ 4 { 5 \u0026#34;id\u0026#34;: \u0026#34;gruppe-1\u0026#34;, 6 \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, 7 \u0026#34;children\u0026#34;: [ 8 \u0026#34;ac555386-ac2b-47a0-bb1b-842f8612eddb\u0026#34;, 9 \u0026#34;5c079cd4-c80c-44ea-b8b8-18e323267a37\u0026#34; 10 ], 11 \u0026#34;maxCount\u0026#34;: 3, 12 \u0026#34;dataModelBindings\u0026#34;: { 13 \u0026#34;group\u0026#34;: \u0026#34;spesifisering-grp-5836\u0026#34; 14 }, 15 \u0026#34;textResourceBindings\u0026#34;: { 16 \u0026#34;header\u0026#34;: \u0026#34;person\u0026#34; 17 } 18 }, 19 { 20 \u0026#34;id\u0026#34;: \u0026#34;ac555386-ac2b-47a0-bb1b-842f8612eddb\u0026#34;, 21 \u0026#34;type\u0026#34;: \u0026#34;Checkboxes\u0026#34;, 22 \u0026#34;componentType\u0026#34;: 5, 23 \u0026#34;textResourceBindings\u0026#34;: { 24 \u0026#34;title\u0026#34;: \u0026#34;Avkrysningsboks\u0026#34; 25 }, 26 \u0026#34;dataModelBindings\u0026#34;: { 27 \u0026#34;simpleBinding\u0026#34;: \u0026#34;klage-grp-5805.spesifisering-grp-5836.KlageSpesifisering-datadef-25457.value\u0026#34; 28 }, 29 \u0026#34;options\u0026#34;: [ 30 { 31 \u0026#34;label\u0026#34;: \u0026#34;25795.OppgavegiverNavnPreutfyltdatadef25795.Label\u0026#34;, 32 \u0026#34;value\u0026#34;: \u0026#34;Verdi1\u0026#34; 33 }, 34 { 35 \u0026#34;label\u0026#34;: \u0026#34;25796.OppgavegiverAdressePreutfyltdatadef25796.Label\u0026#34;, 36 \u0026#34;value\u0026#34;: \u0026#34;Verdi2\u0026#34; 37 } 38 ], 39 \u0026#34;required\u0026#34;: true 40 }, 41 { 42 \u0026#34;id\u0026#34;: \u0026#34;5c079cd4-c80c-44ea-b8b8-18e323267a37\u0026#34;, 43 \u0026#34;type\u0026#34;: \u0026#34;AddressComponent\u0026#34;, 44 \u0026#34;componentType\u0026#34;: 11, 45 \u0026#34;textResourceBindings\u0026#34;: { 46 \u0026#34;title\u0026#34;: \u0026#34;Adresse\u0026#34; 47 }, 48 \u0026#34;dataModelBindings\u0026#34;: { 49 \u0026#34;address\u0026#34;: \u0026#34;klage-grp-5805.spesifisering-grp-5836.KlageSpesifiseringg-datadef-12345.value\u0026#34; 50 }, 51 \u0026#34;simplified\u0026#34;: true, 52 \u0026#34;readOnly\u0026#34;: false, 53 \u0026#34;required\u0026#34;: true 54 } 55 ] 56 } 57} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/alternatives/",
	"title": "Innstillinger",
	"tags": [],
	"description": "Innstillinger for visning.",
	"content": "Det er implementert en ny (valgfri) parameter som kan legges inn på definisjonen av en repeterende gruppe i layout-filen, som gjør at man kan styre litt rundt visningen og oppførselen til gruppen på siden. I tillegg er det lagt til støtte for flere \u0026ldquo;sider\u0026rdquo; inne i redigerings-flaten til gruppen.\nStyre visning Det er lagt til en ny parameter, edit, som kan settes på en gruppe-komponent (repeterende gruppe). Denne lar oss definere forskjellige innstillinger mtp visning av et gruppe-element under redigering/utfylling. Følgende innstillinger kan settes.\nmode Definerer om tabellen (som viser alle elementene i gruppen) skal vises når et element er åpent i redigerings-modus. Følgende verdier godtas:\n   Verdi Beskrivelse     \u0026ldquo;showTable\u0026rdquo; Standard oppførsel om ingenting er satt. Viser tabellen over flaten for redigering av gruppe-element.   \u0026ldquo;hideTable\u0026rdquo; Skjuler tabellen når et gruppe-element er åpent for redigering.   \u0026ldquo;showAll\u0026rdquo; Skjuler tabellen. Viser alle elementene i gruppen i redigerings-modus, under hverandre. Lagre-knapp skjules.    filter Støtte for å filtrere elementene i gruppen, slik at kun de elementene som matcher de definerte kriteriene vises. F.eks. i en gruppe som viser arbeidserfaring, vis kun de elementene der arbeidssted var Oslo. Liste med kriterier er basert på verdi av ett eller flere felter i gruppen, på formen\n\u0026#34;edit\u0026#34;: { \u0026#34;filter\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;felt i datamodell\u0026gt;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026lt;ønsket verdi\u0026gt;\u0026#34; } ] } Dersom det er flere kriterier, må alle matche for at elementet skal vises.\nOm det kun er ett resultat, vises dette automatsk i redigerings-modus. Om det er flere elementer i gruppen som matcher filteret, vil disse vises. Andre elementer i gruppen skjules. filter kan kombineres med mode-parameter.\nOm man kombinerer `\"mode\": \"showAll\"` med `\"filter\"`, vil det ikke fungere å legge til nye elementer i gruppen. Dette er fordi man med \"showAll\" kun viser redigerings-flaten, og så lenge filteret ikke matcher, vil ikke elementet vises.\r\raddButton Bestemmer om \u0026ldquo;Legg til ny\u0026rdquo;-knappen vises under tabellen. Nyttig å skjule denne om man kun ønsker å presentere data.\nsaveButton Bestemmer om \u0026ldquo;Lagre\u0026rdquo;-knappen vises når et gruppeelement er i redigeringsmodus. Standard oppførsel om parameteren ikke er satt er at \u0026ldquo;Lagre\u0026rdquo;-knapp vises. Dersom man har satt \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot; skjules Lagre-knappen alltid, da man i denne modusen ikke har mulighet til å lukke redigerings-flaten for gruppe-elementet. Dataene lagres uansett.\ndeleteButton Bestemmer om \u0026ldquo;Slett\u0026rdquo;-knappen vises når et gruppeelement er i redigeringsmodus. Standard oppførsel om parameteren ikke er satt er at \u0026ldquo;Slett\u0026rdquo;-knapp vises.\nmultiPage Sier at redigering/utfylling av gruppe kan gjøres over flere \u0026ldquo;sider\u0026rdquo;/visninger. Krever mer oppsett for å fungere, se under for mer informasjon.\nopenByDefault Sier at gruppen skal åpnes i editeringsmodus om det ikke finnes noen elementer i gruppen fra før. Merk at denne ikke kan brukes sammen med \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot;.\nEksempel:\n{ ... \u0026#34;edit\u0026#34;: { \u0026#34;openByDefault\u0026#34;: true } } Flere sider innad i gruppe-visning - Denne funksjonaliteten er p.t. kun tilgjengelig for repeterende grupper.\r- Visning av gruppe over flere sider inne i redigerings-flaten til gruppen støttes KUN for grupper på øverste nivå, og støttes ikke for grupper i grupper.\r\rNår man skal legge inn data i en gruppe, kan det være tilfeller der hvert element i gruppen inneholder mange felter, og at det dermed blir mye scrolling og uoversiktlig for sluttbruker. For å løse dette er det innført en mulighet til å dele opp utfyllingen over flere visninger, som bruker kan navigere frem/tilbake mellom mens de fyller ut gruppe-elementet. Navigeringen her skjer innad i en layout, og oppdaterer kun visningen inne i redigeringsflaten for gruppen.\nFor å ta i bruk denne funksjonaliteten, må man prefikse komponentene i children listen med et tall som tilsier hvilken \u0026ldquo;side\u0026rdquo; av utfyllingen komponenten skal vises på, etterfulgt av :. Vi starter tellingen på 0, dvs. at komponenter som skal vises på den første \u0026ldquo;siden\u0026rdquo; må prefikses med 0:. Komponenter som skal vises på den andre siden prefikses med 1:. Osv. I tillegg må man sette \u0026quot;multiPage\u0026quot;: true på den nye edit-parameteren (se over). Se eksempel under:\n{ \u0026#34;id\u0026#34;: \u0026#34;Some-group-id\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;0:fnr\u0026#34;, \u0026#34;1:fornavn\u0026#34;, \u0026#34;1:mellomnavn\u0026#34;, \u0026#34;1:etternavn\u0026#34;  ], \u0026#34;maxCount\u0026#34;: 10, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;familie.barn\u0026#34; }, \u0026#34;edit\u0026#34;: { \u0026#34;multiPage\u0026#34;: true, \u0026#34;mode\u0026#34;: \u0026#34;hideTable\u0026#34;,  } } Her har man også lagt inn en mode som skjuler tabellen under redigering. Resultatet blir som vist under.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/prototype/",
	"title": "Prototype",
	"tags": [],
	"description": "Ved hjelp av Altinns Prototype-kit kan du lage en klikkbar prototype for å definere flyt og innhold i din tjeneste.",
	"content": "Altinn Prototype-kit er en samling av sidemaler og komponenter du kan bruke til å lage en prototype i Figma av Altinn-skjemaet ditt.\nMed Altinns Prototype-Kit for Figma kan du:\n Se hvordan Altinn-skjemaer ser ut og oppleves for brukeren Gjør deg kjent med designelementer i Altinn 3 Definere flyt og innhold for ditt eget skjema Lage klikkbare skisser som kan brukertestes Bruke prototypen som en spesifikasjon/referanse når appen utvikles  Kom i gang med Figma Det er en fordel hvis du har en designer i prosjektet som har brukt Figma eller liknende verktøy tidligere. Dersom du ikke har tilgang på en slik ressurs anbefaler vi å gå gjennom en introduksjon til Figma først.\n Opprett en bruker på https://www.figma.com/. Figma kan installeres lokalt eller brukes i din nettleser. Åpne Altinn prototype-kit og følg stegene som er beskrevet i introduksjonen på første side i filen:  \r\rAltinn Prototype-kit\r\r\r\rNår designeren/fagpersonen har designet ferdig skjemaet, og det er brukertestet, kan det videre brukes som spesifikasjon til det utviklerne skal lage i Altinn Studio.\nNB: Skal du lage tjenester i egen løsning, der Altinn er usynlig for brukeren, bør du heller bruke etatens eget designsystem for å prototype tjenesten.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/",
	"title": "Endringslogg for app frontend",
	"tags": [],
	"description": "Oversikt over endringer introdusert i app frontend.",
	"content": "\rv3\rOversikt over endringer introdusert i v3 av app frontend.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/usertest/",
	"title": "Brukertest",
	"tags": [],
	"description": "Det er alltid lurt å brukerteste i flere faser av prosjektet. Gjennom brukertester måler du om det du lager treffer brukernes behov. Det er en god investering å gjøre dette tidlig i prosjektet, slik at du ikke bruker penger på å utvikle en løsning som ikke løser utfordringene.",
	"content": "Å brukerteste trenger ikke være veldig avansert, hverken med tanke på oppsett eller antall testpersoner. En tommelfingerregel er at hvis du har testet på fem personer har du funnet 80 % av brukervennlighetsfeilene (Jacob Nielsen).\nEtter en brukertest vil det være ting å justere på. Det kan være større ting som navigasjon og flyt, men også små justeringer som språk eller mindre endringer i interaksjonsdesignet. Hvis det er behov for å gjøre større endringer kan det være lurt å ta en ny brukertest for å sjekke om justeringene har ønsket effekt.\nEt tegn på om du har lykkes å lage en løsning som treffer brukernes behov er hvis de fleste brukerne i brukertesten klarer å gjennomføre det de skal ha gjort på nettstedet eller løsningen din uten hjelp, og innenfor en fornuftig tidsramme.\nBrukertesting i Figma Har du satt opp en prototype i Figma ved hjelp av vårt Prototype-Kit? Flott! Da kan du benytte denne til brukertesting!\nDersom du har lagt til flere steg i ditt skjema, må du huske å lenke mellom disse stegene. Dette gjør du ved å velge \u0026ldquo;Prototype\u0026rdquo; oppe til høyre i Figma. Marker en ramme eller en knapp og legg merke til den lille hvite dotten som vises til høyre på det du markerte. Denne dotten kan du ta tak i og dra til rammen du ønsker å gå til.\nDet finnes en flyt for hvert startalternativ, samt en flyt for mobilskissene. Trykk på Play-knappen på prototypen du vil starte. Etter at den er startet kan du bytte mellom de ulike flytene i venstremargen.\nFor å dele filen med testerne velger du “Share” oppe til høyre i vinduet. Du kan enten velge at filen skal være åpen for alle som har lenken, eller at kun inviterte (via epost) skal få tilgang.\nGode råd for brukertesting  Test tidlig med reelle brukere Brukervennligheten kan kun måles om den blir testet på målgruppen til løsningen. Å teste tidlige gjør det billigere å fikse eventuelle problemer som avdekkes. Ufarliggjøre testen Forklar testdeltageren at hensikten ikke er å teste hvor flinke de er, men at hovedfokuset er på å avdekke eventuelle feil med tjenesten, slik at den kan bli enda bedre. Be testpersonen om å tenke høyt. For noen vil det å «tenke høyt» komme av seg selv, mens andre trenger et par påminnelser innimellom. Ikke still ledende spørsmål, men vis at du ønsker å høre testpersonens tanker og tilbakemeldinger. Vær lyttende Husk å gi testpersonen rom for tenkepauser og ha først og fremst en lyttende posisjon. Avsett god tid, så du unngår stressende stemning. Minn deg selv på formålet med testen Tilbakemeldinger fra testdeltager kan fort oppfattes som kritikk mot eget arbeid, minn deg selv på at du ønsker jo tross alt at tjenesten skal bli så bra som mulig.  Uforme testoppgaver Bruk god tid på å formulere oppgavene til brukertesten, og gjør gjerne en pilottest i forkant for å avdekke feil med selve testen.\n Sett et klart mål for hva deltakeren skal prøve å oppnå. Velg oppgaver som er relevante og troverdige Ikke gi bort svaret eller gi for mange hint  Hos gov.uk finner du flere gode råd for å gjennomføre testen på best mulig måte.\nEtter testen Når du har vært gjennom et par brukertester har du sannsynligvis funnet ting du bør forbedre i utformingen av skjemaet eller formuleringen av innholdet. Vurder å kjøre en ekstra runde brukertesting etter du har gjort endringene.\nNå er du snart klar for utvikling! Husk også å se våre retningslinjer for design og innhold i skjemaene.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/case/",
	"title": "Casebeskrivelse",
	"tags": ["apps", "case", "training"],
	"description": "Beskrivelse av kommunens krav og ønsker til tjenesten",
	"content": "Sogndal kommune trenger sårt flere unge mennesker og ønsker å bli en attraktiv kommune for unge voksne og andre i etableringsfasen.\nI den sammenheng ønsker de å opprette en tjeneste i Altinn beregnet på personer som skal flytte til Sogndal i løpet av de neste 6 månedene.\nVed å samle inn data om tilflyttere på et tidlig tidspunkt kan kommunen legge til rette og spisse tilbudene til tilflytterne allerede før første flytteeske er pakket.\nDe har en del krav til tjenesten som er beskrevet i seksjonene nedenfor.\nKrav fra kommunen Navngivning \rVis/skjul innhold\r\rKrav\r\r\r  Applikasjonen må ha et fornuftig navn som gjør det enkelt å finne den igjen blant det store antallet repositories Sogndal kommune har i Altinn Studio.\n  Det er ingen foreløpige planer om årlige revisjoner av appen, så man trenger ikke ta hensyn til årstall i navnet.\n  Det er et ønske om at et eller flere av ordene \u0026ldquo;tilflytter\u0026rdquo; og \u0026ldquo;Sogndal\u0026rdquo; er med i navnet.\n\r\r Første side med datainnsamling \rVis/skjul innhold\r\rKrav\r\r\r Vil ha navn og alder på personen som er tilflytter  Fornavn Mellomnavn (valgfritt) Etternavn Alder   Vil ha adressen på personen som er tilflytter  Gateadresse Postnummer Poststed   Vil ha kontaktinformasjon på personen som er tilflytter  Epost Telefon    \r\r Tekster \rVis/skjul innhold\r\rKrav\r\r\r Alle inputfelter skal ha forklarende labels som beskriver hva som skal fylles inn Applikasjonen må være tilgjengelig både på bokmål, nynorsk og engelsk I en første versjon er det tilstrekkelig at kun ett av disse språkene støttes Det er viktig at applikasjonens visningsnavn klinger godt og er beskrivende for tjenesten  \r\r Infoside \rVis/skjul innhold\r\rKrav\r\r\r\r\r Alternativ arbeidsflyt (sporvalg) \rVis/skjul innhold\r\rKrav\r\r\rEn bruker som ikke oppfyller kravene for skjemaet skal stoppes så tidlig som mulig i arbeidsflyten.\nPå infosiden er det ønskelig at brukeren skal oppgi om skjemaet gjelder dem eller ikke.\nHvordan dette gjøres er fritt fram, og feltet Innflytter.KanBrukeSkjema i datamodellen er mulig å benytte til dette formålet.\nBasert på svaret skal brukeren sendes videre til Spor 1 eller Spor 2.\nSpor 1   Brukeren har ikke svart bekreftende på at skjemaet gjelder deres situasjon\n  Bruker skal sendes til en side med følgende tekst:\nDette skjemaet er ikke for deg.\rSe en oversikt over andre tilbud i kommunen her.\r  Linje 2 i teksten skal være en hyperlenke som peker på: https://www.sogndal.kommune.no/\n  Det skal ikke være mulig å navigere til andre skjemasider etter denne.\n  Spor 2   Brukeren har svart bekreftende på at skjemaet gjelder deres situasjon\n  Brukeren sendes videre til datainnsamlingssidene.\n  \r\r Preutfylling av personopplysninger \rVis/skjul innhold\r\rKrav\r\r\r  Dersom personen som arbeider i skjemaet selv er tilflytter skal følgende verdier preutfylles:\n Fornavn: Innflytter.Fornavn Mellomnavn: Innflytter.Mellomnavn Etternavn: Innflytter.Etternavn E-post: Innflytter.Kontaktinformasjon.Epost Telefonnummer: Innflytter.Kontaktinformasjon.Telefonnummer Alder: Innflytter.Alder    Det skal ikke være mulig å endre preutfylt navn og alder\n  Det skal være mulig å endre preutfylt e-post og telefonnummer\n  \r\r Differensiert datagrunnlag for offentlig og privat sektor \rVis/skjul innhold\r\rKrav\r\r\rVi ønsker at brukeren skal ha et ulikt sett med svaralternativer for bransje-valget basert på hvilken sektor de har krysset av for.\n Privat sektor: Standard listen med bransjer Offentlig sektor: Stat og Kommune  \r\r Skreddersydd tilbud for IT-kompetanse \rVis/skjul innhold\r\rKrav\r\r\rVi ønsker at dersom brukeren velger IKT (data/it) under bransje at det vises en tekst med en lenke til en av våre stillingsutlysninger.\n  Under bransje-valget skal følgende tekst presenteres\nVi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her.\r  Linje 2 i teksten skal være en hyperlenke som peker på: https://sogndal.easycruit.com/index.html\n  Tekst og lenke skal kun vises om man har valgt IKT (data/it) i alle andre tilfeller skal dette være skjult.\n\r\r Bekreftelse før innsending \rVis/skjul innhold\r\rKrav\r\r\rVi ønsker at brukeren før innsending presenteres med hva dataen skal benyttes til og samtykker (indirekte) til dette ved å sende inn skjemaet.\nMulige operasjoner På dette punktet i arbeidsflyten skal brukeren kunne:\n Se over dataen som er utfylt Avslutte arbeidsflyten uten å sende inn skjemaet Avslutte arbeidsflyten og sende inn skjemaet  Autorisasjon  Det skal være samme rollekrav for å fylle ut og bekrefte en instans.  Validering  Det skal kun være mulig for brukeren som eier instansen å sende inn skjemaet, selv om andre måtte inneha de nødendigve rollene  Tekster Vi ønsker at brukeren skal presenteres med følgende tekst før innsending\nDu er nå klar for å sende inn melding om tilflytting til Sogndal kommune.\rVed å sende inn dette skjemaet samtykker du til at dataen du har fylt ut kan lagres og benyttes til å tilpasse kommunens tilbud til deg de neste 18 månedene.\rFør du sender inn vil vi anbefale å se over svarene dine. Du kan ikke endre svarene etter at du har sendt inn.\r\r\r\r Innhenting av tidligere bosteder \rVis/skjul innhold\r\rKrav\r\r\rFor å kunne skreddersy et best mulig tilbud til nye innflyttere ønsker vi oss en oversikt over tidligere bosteder til innflytteren.\nPå datasiden ønsker vi at det legges opp til at brukeren kan fylle inn tidligere bosteder. Tidligere bosteder skal inneholde følgende felter:\n Gateadresse Postnummer Poststed  Det skal være mulig å legge inn opptill 10 tidligere bosteder.\n\r\r Validering tidligere bosteder \rVis/skjul innhold\r\rKrav\r\r\rGrunnet en personlig vendetta blant en av Sogndal-kommunes ansatte ønsker vi at om innflytter fyller inn postnummer 4619 som en av tidligere bosteder IKKE skal få lov til å flytte inn i Sogndal. Her ønsker vi at det skal dukke opp en feilmelding på det aktuelle feltet med følgende tekst:\nDu er ikke velkommen til vår kommune. Beklager!\r\r\r\r Dataprossessering av ugyldig gateadresse \rVis/skjul innhold\r\rKrav\r\r\rEn av kommunens databehandlere har sett seg lei av å manuelt rette opp i en gateadresse som ofte blir skrevet feil av innflyttere. Vi ønsker derfor å programatisk fikse opp i dette under utfyllingen av appen.\nOm sluttbruker fyller inn Sesame Street 1 i feltet Innflytter.Adresse.Gateadresse skal dette automatisk rettes til Sesamsgate 1. I alle andre tilfeller skal feltet forbli urørt.\n\r\r "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/",
	"title": "Data",
	"tags": [],
	"description": "Konfigurering av datamodell, preutfylling og andre ting relatert til data i en app.",
	"content": "\r\rDatamodell i Altinn Studio\rSlik importerer eller viser du datamodellen i Altinn Studio.\n\r\rPreutfylling av data (prefill)\rHvordan konfigurere prefill for en app.\n\r\rKodelister (options)\rHvordan konfigurere options/kodelister for en app.\n\r\rVedlegg\rI en applikasjon kan man legge til rette for opplasting av filvedlegg både via GUI og API.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/design-principles/",
	"title": "Designprinsipper",
	"tags": ["translate-to-english"],
	"description": "Når vi utvikler nye eller forbedrer eksisterende produkter følger vi et sett med prinsipper for å kunne sikre oss at vi leverer brukervennlige løsninger til alle. Vi anbefaler å følge disse prinsippene når du jobber med utvikling av nye tjenester.",
	"content": " Vi setter brukerbehov først Vi bruker innsikt om brukernes behov aktivt i utviklingen av produktene våre. Alle løsninger skal fokusere på å løse reelle problemer for brukerne og vi bruker undersøkelser og brukerinnsikt til å ta beslutninger. Skjule kompleksitet Vi lager fokuserte og forenklede løsninger og skreller vekk unødvendig kompleksitet for brukerne. Løsningene er ofte komplekse på baksiden, men fremstår enkle og brukervennlige for folk som bruker dem. Helhetlige brukeropplevelser Produktene våre skal henge sammen slik at folk får en helhetlig brukeropplevelse. Vi bruker konsistent språk og samme komponenter i alle digitale løsninger. Brukerne skal kjenne seg igjen uansett hvilken del av produktet man bruker. Visuelt design som motiverer Det visuelle designet skal bidra til å gjøre brukerne trygge i dialogen med det offentlige. Vi bruker en vennlig fargepalett, et enklere grensesnitt, tydelige interaksjonselementer og fargesterke illustrasjoner til å skal skape en god atmosfære. Alle visuelle beslutninger skal ha et klart formål om å skape en spesifikk effekt. Tilgjengelighet for alle Vi strekker oss langt for å lage digitale løsninger som skal være tilgjengelige for alle. Vi gjenbruker komponenter som en måte å optimalisere tilgjengelighet på - teknisk så vel som interaksjonsdesign og visuelt design.  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/generic/",
	"title": "Generelt",
	"tags": [],
	"description": "Oversikt over logikkfiler og hvordan de kan brukes.",
	"content": "Introduksjon De forskjellige filene som brukes til å definere logikk, finner man i logikk-menyen, som er tilgjengelig i UI-editoren via f(x)-ikonet øverst til høyre.\nDe kan også redigeres direkte fra applikasjonsrepoet, under folderen App/logic (for serverside applikasjonslogikk) eller folderen App/ui (for dynamikk). Denne folderen inneholder som standard følgende filer:\n🗀 App/ 🗀 logic/ 🗀 DataProcessing/ 🗎 DataProcessingHandler.cs 🗀 Print/ 🗎 PdfHandler.cs 🗀 Validation/ 🗎 ValidationHandler.cs 🗎 App.cs 🗎 InstantiationHandler.cs Flere filer kan legges til her når det er nødvendig.\nEt komplett prosjekt med eksempler på serverside applikasjonslogikk ligger her.\nMERK: Måten man refererer til elementer i datamodellen er ulik mellom OR og SERES typer XSDer. For OR XSDer er .value et nødvendig suffiks i referansen. Eksempelkoden under bruker en blanding av de to typene datamodeller.\n\r\rAuto-complete/intellisense Ved å redigere kildekoden i appene lokalt, i f.eks. Visual Studio Code, får man intellisense og autocomplete med på kjøpet. For C#-filene er det enkleste å jobbe med disse lokalt.\nFor javascript-filene er det også intellisense/autocomplete tilgjengelig om man ønsker å redigere filene direkte i Altinn Studio. Dette kommer automatisk mens man skriver, og man kan også tvinge det frem ved å trykke CTRL + SPACE\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/link-to-app/",
	"title": "Inngang til skjema",
	"tags": [],
	"description": "For å gjøre opplevelsen til brukeren best mulig bør du tenke over hvordan du lenker til Altinn-appen fra din etat.",
	"content": "Brukertester har vist at når brukerne starter på etaten/kommunens sider for å fylle ut et skjema og så blir sendt videre til Altinn, får de ofte opplevelsen av at «plutselig var jeg i altinn». Innganger til skjema bør derfor presenteres slik at det er tydelig at man går til Altinn, men samtidig slipper å gå innom unødvendige mellomledd. \u0026ldquo;Start innsending\u0026rdquo; bør lenke direkte til skjemaet. Opplevelsen til bruker vil da også i større grad bli at man får løst oppgaven i konteksten man er i, men at Altinn er brukt som løsning for innsending og historikk.\nIntegrerte komponenter\nI tett samarbeid med sentrale tjenesteeiere planlegger vi på sikt å kunne tilby komponenter som kan benyttes på etatens nettsider, slik at brukerne kan løse oppgaven i den konteksten de er i.\nAltinns brukere ønsker både løsning der de er og en samlet oversikt. Og de bør få begge deler. Men behovene dekkes best på litt forskjellige måter.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/content/",
	"title": "Innhold i skjema",
	"tags": ["translate-to-english"],
	"description": "Forklar brukeren hva som skal til for å fylle ut skjemaet riktig og fordel innholdet i flere steg.",
	"content": "Brukeren skal ikke trenge å få feilmelding for å forstå hva som skal til for å fylle ut skjemaet riktig. Dette bør tydelig komme frem i informasjonstekst i begynnelsen av skjemaet og i labels som tilhører hvert enkelt skjemafelt.\nSom hovedregel bør man kun spørre om informasjon som er helt nødvendig å innhente. Du kan derfor opplyse i starten av skjemaet om at alle felt er påkrevde og må fylles ut (for å slippe å markere alle som påkrevde). Frivillige felt kan eventuelt markeres med \u0026ldquo;frivillig\u0026rdquo; i selve labelen til feltet.\nFordel innholdet i flere steg og bruk sporvalg En side med mye informasjon og flere oppgaver kan fort bli overveldende for en bruker. Prøv å del opp tjenesten slik at brukeren bare har en oppgave per side. Dette kan for eksempel være et spørsmål brukeren må svare på eller viktig informasjon som må leses. Dette kan gjøre det lettere for brukeren å fokusere på og forstå det du ber dem om.\nDesignet vi tilbyr nå er laget med utgangspunkt i dette konseptet. Et større antall komponenter kan føre til mye scrolling og en mer uoversiktlig opplevelse for brukeren. Se eksempel: Starte enkeltpersonforetak.\nBrukeren skal slippe å svare på mer enn nødvendig. Dersom brukeren har svart nei på et spørsmål og du dermed kan skjule flere av stegene for ham, kan du gjøre dette med dynamisk sporvalg.\nDisabled Ved å vise skjemafelt som disabled forventer man at brukeren skal vite hvorfor de ikke kan bruke elementet, men dette er ikke alltid tilfellet. Noen brukerer forstår heller ikke at feltet er deaktivert, som igjen kan føre til forvirring. Bruk av disabled bør derfor unngås. Dersom en handlingen av en eller annen grunn ikke er tillatt, kan dette i stedet forklares i en informasjonstekst.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/intro/",
	"title": "Introduksjon til Altinn Studio",
	"tags": [],
	"description": "Altinn Studio er vårt nye verktøy for å utvikle offentlige digitale tjenester. Dette kan være alt fra helt enkle skjema til avanserte applikasjoner.",
	"content": "Prosessen for å lage skjemaer og meldinger vil være forskjellig alt etter som hvor stor eller liten målgruppen er, hvor mye data som skal behandles eller hvor mye jobb det er å legge til rette for at egne systemer kan snakke med Altinn.\nSlik går du frem:\n  Start alltid med å definere brukerbehov\nTenk nøye gjennom hele prosessen fra et brukerperspektiv. Hva er utfordringen og hvem skal den løses for? Hva er databehovet? Lag gjerne en skisse til kommunikasjon med brukeren og test skissen på folk i målgruppen.\nPlanlegg og design din app\r\r\r  Få tilgang til systemer\nHvis du ikke har utviklet tjenester i Altinn Studio før trenger du å opprette en bruker. Har du ikke allerede en ferdig datamodell/XSD så trenger du i tillegg tilgang til SERES-domeneklient.\n  Tilrettelegge egne systemer for sending og mottak av data\nDet finnes standardiserte mønstre basert på REST-API for å sende og motta data fra/til dine interne systemer. Autentisering skjer med Maskinporten og du laster ned data ved pull fra database, og laster opp data direkte mot API i den enkelte applikasjon. Vår referanseapplikasjon Altinn CLI ​viser disse mønstrene og kan brukes for å komme i gang.\n  Utvikle tjenestene\nAltinn Studio brukes til å opprette applikasjoner (apps). En app kan være alt fra enkle skjemaer til større avanserte applikasjoner som digitaliserer komplekse prosesser. Det er viktig å tenke på at brukeren skal oppleve prosessene som sammenhengende og oversiktlige. Prosessene kan startes av det offentlige eller av brukeren selv, eller automatisk som en reaksjon på en hendelse.\n  Teste tjenestene\nAltinn har et eget testmiljø hvor du kan teste om apper og opp-/nedlasting av data virker som det skal. I testmiljøet bruker du fiktive testpersoner og organisasjoner. Når du har kommet så langt i utviklingen er det også viktig å brukerteste den endelige løsningen på reelle folk i målgruppen. Dette for å sikre at det ikke er noen hinder for de som skal bruke tjenestene. Det er også mulig å teste app lokalt på egen maskin.\n  Produksjonssette tjenestene\nTjenesteeier kan selv produksjonssette sine applikasjoner og gjøre vedlikehold av kode og avhengigheter.\n  Melding av feil\nFeil meldes til Altinn fra den enkelte tjenesteeier sitt dashboard på Altinn Digitalisering (krever innlogging).\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/",
	"title": "Kom i gang",
	"tags": [],
	"description": "Kom i gang slik at du kan utvikle apper i Altinn Studio.",
	"content": "\r\rIntroduksjon til Altinn Studio\rAltinn Studio er vårt nye verktøy for å utvikle offentlige digitale tjenester. Dette kan være alt fra helt enkle skjema til avanserte applikasjoner.\n\r\rOpprette bruker i Altinn Studio\rKonfigurer brukeren din i Altinn Studio for første gang.\n\r\rDashboard i Altinn Studio\rHvordan bruke dashboardet i Altinn Studio\n\r\rKopier app i Altinn Studio\rSlik oppretter man en kopi av applikasjon i Altinn Studio.\n\r\rOpprette app i Altinn Studio\rSlik oppretter man en ny applikasjon i Altinn Studio.\n\r\rMigrere tjenester\rFra Altinn 2 til Altinn 3.\n\r\rNavigasjon i Altinn Studio\rSlik navigerer du mellom de ulike delene av Altinn Studio.\n\r\rTilganger\rHvordan man får tilganger til Altinn Studio, hemmeligheter og applikasjonslogger.\n\r\rLokal utvikling\rHvordan komme i gang med lokal utvikling\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/consistency/",
	"title": "Konsistens på tvers av tjenester",
	"tags": [],
	"description": "For å være lett å bruke og unngå forvirring, bør samme interaksjonsmønstre følges på tvers av tjenester.",
	"content": "Når brukere møter en ny tjeneste, har de med seg forventninger fra tidligere opplevelser. Når disse forventningene møtes, kreves det mindre av brukeren for å samhandle med komponentene, og det bygges selvtillit. Ved å ikke trenge å lære nye interaksjoner, vil brukerens fokus i større grad være på innholdet.\nVi anbefaler ikke å endre CSS for individuelle tjenester som bruker Altinn-designet. Dersom vi åpner opp for designendringer og fargeendringer, vil dette skade konsistensen mellom tjenestene. Konsekvent design mellom tjenesteeiere er noe vi bør strekke oss mot. For å få det til kreves et godt samarbeid mellom fagmiljøet i Altinn og hos de ulike tjenesteeierene. Vi ønsker oss en god felles løsning som kan brukes og forbedres av alle, fremfor mange forskjellige løsninger gjennom ulike CSS-endringer. Dette vil også gjøre det lettere å kontrollere tilgjengeligheten på tvers av apper på plattformen vår. Velger du likevel å gå bort fra designet, er du selv ansvarlig for å følge alle WCAG-krav.\nHar du behov for en ny komponent?\nVi ønsker at alle er med på å videreutvikle biblioteket av komponenter med både design og kode. I praksis vil dette si at Altinn ønsker å ta imot forslag til nye komponenter etter hvert som tjenesteeierne ser behovet for det.\nOpprett en sak i github\rSkriv til oss på Slack\r\r\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/",
	"title": "Lage apper",
	"tags": [],
	"description": "Altinn Studio er vårt nye verktøy for å utvikle digitale tjenester (apps). Dette kan være alt fra helt enkle skjema til veldig avanserte applikasjoner.",
	"content": "\rHvem kan ta i bruk Altinn Studio?\nDu må være tjenesteeier i Altinn samt godta bruksvilkår for Altinn i skyen for å kunne produksjonssette apper, men alle kan logge inn i altinn.studio og teste ut mulighetene.\n\r\rHvis du lurer på noe så er det bare å ta kontakt med oss på Slack eller GitHub, eller lese denne dokumentasjonen.\n\rKom i gang\rKom i gang slik at du kan utvikle apper i Altinn Studio.\n\r\rIntrokurs\rEt kursopplegg for å lære seg apputvikling med Altinn Studio og lokale verktøy.\n\r\rDesign og planlegging\rFor at tjenesten din skal bli best mulig for de som skal bruke den, er det viktig å starte med å fokusere på brukerne og forstå deres brukerbehov i møte med tjenesten din.\n\r\rUtvikling\rHvordan opprette og redigere apper i Altinn Studio.\n\r\rTesting av apper\rApplikasjoner (apper) kan testes i testmiljø, eller lokalt.\n\r\rProduksjonssetting av apper\rTjenesteeier kan selv produksjonssette sine applikasjoner, og gjøre vedlikehold av kode og avhengigheter.\n\r\rVedlikehold av app i produksjon\rApplikasjoner i produksjon krever jevnlig vedlikehold og oppdateringer.\n\r\rLanserte tjenester\rNoen av tjenestene som allerede er i produksjon, til informasjon og inspirasjon.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/navigation/",
	"title": "Navigasjon mellom sider",
	"tags": [],
	"description": "Hvordan sette opp navigasjon mellom sider.",
	"content": "Navigering videre til neste side skjer via en navigerings-knapp. Denne må legges til manuelt i hver layout-fil hvor man ønsker navigering fremover. Navigering tilbake til forrige side gjøres via tilbake-pil i venstre hjørnet. Denne knappen vises alltid så lenge det er en side å gå tilbake til, og er ikke en del av layout-filen. Se bilde under.\nLegge til knapp for navigering Knapp for navigering legges inn i alle layout-filer der det er behov. Om man ønsker at den skal dukke opp nederst på siden, må den legges inn nederst i layout-filen. Eksempel vises under\n{ \u0026#34;id\u0026#34;: \u0026#34;nav-page2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;next\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;back\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} } Det er også mulighet for å vise en tilbake-knapp sammen med neste-knappen, ved å legge til parameteren \u0026quot;showBackButton\u0026quot;: true på komponenten.\n   Parameter Beskrivelse     id Unik ID, tilsvarende som for alle andre skjemakomponenter.   type Må være \u0026quot;NavigationButtons\u0026quot;   textResourceBindings Setter man parametre next (og evt. back) her, vil man kunne overstyre med egne tekster som vises på knappen(e). Se eksempel over.   showBackButton Valgfri. Gjør at 2 knapper (tilbake/neste) vises i stedet for bare en (neste).    Navigasjonsbar Navigasjonsbar gir enkel tilgang til alle sider i en applikasjon.\nNavigasjonsbar lister opp alle sider i appen, og egner seg derfor ikke til bruk ved sporvalg.\r\rPå store skjermer vil alle sider listes opp. Dersom det ikke er plass på en linje, vil listen brytes og fortsette på neste linje. På mindre skjermer vil alle sider være skjult i en meny. Den siden som er aktiv vil vises i menyen. Når menyen klikkes på, vil en liste over alle sider vises.\nNavigasjonsbar legges inn i alle layoutfiler der den skal brukes. Eksempel på konfigurasjon:\n{ \u0026#34;id\u0026#34;: \u0026#34;navbar-page-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationBar\u0026#34; } Endre tekster på navigasjonsbarknapper Teksten på navigasjonsbarknappene vil som standard bruke filnavnet på siden uten filendelsen. F.eks om man har side1.json og side2.json vil navigasjonsknappene hete side1 og side2. For å overstyre disse tekstene, kan du legge til tekster i resources.XX.json, hvor id er navnet på filen uten filendelse. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;side1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Første side\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;side2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Siste side\u0026#34; }, Rekkefølge Standard rekkefølge for sidene er alfabetisk. Utover det kan man navngi hver side som man ønsker, det er da filnavnet som gjelder her. For å sikre at sidene kommer i ønsket rekkefølge kan man f.eks. sette en prefix med tall foran sidenavnet i filnavn. F.eks:\n|- App/\r|- ui/\r|- layouts/\r|- 1.firstPage.json\r|- 2.secondPage.json\r|- 3.aFinalPage.json\rDet er også mulig å styre rekkefølgen på sidene ved hjelp av Settings.json under App/ui/. Dette gjøres på følgende vis:\n{ \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [\u0026#34;side2\u0026#34;, \u0026#34;side1\u0026#34;] } } Her vil sidene da vises i rekkefølgen spesifisert i pages.order. Om denne array\u0026rsquo;en ikke settes i repo så vil man bruke alfabetisk rekkefølge som utgangspunkt for rekkefølgen på sidene.\nFunksjonalitet for å kunne dynamisk bestemme hvilken side som er neste er ikke noe som støttes i denne versionen av funksjonaliteten.\r\rValidering ved sidebytte Det er mulig å trigge validering i det brukeren prøver å bevege seg til neste side. Dette kan gjøres ved å legge til strengen validatePage i triggers på navigasjons-knapp komponenten. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;7cbc1c00-4c8c-42b6-bcef-12b3c4c45373\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;componentType\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;Neste\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;Tilbake\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;validatePage\u0026#34;], \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;showBackButton\u0026#34;: true } Ved å legge til validatePage i triggers vil app-frontend kjøre valideringene på den aktuelle siden i det brukeren navigerer til neste side. Om det er feilmeldinger på siden vil brukeren bli hindret i å gå videre før dette er rettet opp. Om validatePage er lagt til som en trigger vil også id\u0026rsquo;en på siden som trigger valideringen sendes ved som en header LayoutId til valideringene som kjøres på serversiden. Dette muliggjør å skreddersy backend-valideringene basert på hvilken side brukeren trigger valideringen fra.\nDet er også mulig å trigge validering på alle sider ved å legge til validateAllPages i triggers.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/",
	"title": "Sider",
	"tags": [],
	"description": "Hvordan sette opp en app med flere sider, sporvalg, oppsummering eller flere skjema.",
	"content": "Oppsett av flere sider kan gjøres enten manuelt (som beskrevet under) eller direkte i skjema-editoren i Altinn Studio.\rMerk at siste side sluttbruker var innom nå caches slik at man kommer tilbake til denne siden når appen lastes inn på nytt.\r\rOppsett For å få funksjonalitet for flere sider i skjema, må nuget-versjon til pakkene app\u0026rsquo;en bruker oppgraderes til versjon 1.2.0-alpha eller nyere. Se instrukser for hvordan det gjøres her.\nFlere sider i skjema (innenfor samme prosess-task) støttes ved å dele opp dagens layout-fil App/ui/FormLayout.json i en fil per side. Filene må legges i en mappe App/ui/layouts. Hver layout-fil må bruke samme format som den eksisterende FormLayout.json filen. F.eks.:\n|- App/\r|- ui/\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json\rAnbefalt fremgangsmåte så lenge det er behov for å sette det opp manuelt, er å bruke ui-editoren i Altinn Studio for å legge inn alle komponentene inn i FormLayout.json, for å så kopiere de ut i sine respektive layout-filer, en for hver side man ønsker. FormLayout.json kan enten få nytt navn under layouts-mappen, eller slettes.\nMerk: FormLayout.json må enten flyttes (evt med nytt navn) inn i layouts-mappen, eller slettes. Dersom man har den gamle FormLayout.json-filen under App/ui-mappen som tidligere, vil kun denne brukes og alle filer under App/ui/layouts-mappen ignoreres.\n\rNavigasjon mellom sider\rHvordan sette opp navigasjon mellom sider.\n\r\rSporvalg\rHvordan legge til dynamisk sporvalg i app\n\r\rOppsummeringsvisning\rHvordan sette opp visning av oppsummering av utfylt skjema.\n\r\rFlere skjema i samme app (layout-sets)\rHvordan sette opp en app som inneholder flere ulike skjema.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/title-and-paragraph/",
	"title": "Tittel og avsnitt",
	"tags": [],
	"description": "Det bør som hovedregel alltid være en header (H2) og et avsnitt i starten på en skjamaside for å oppsummere brukerens oppgave.",
	"content": "Retningslinjer:  Tekstlengde på avsnitt strekkes ikke ut 100% i modalboksen, ettersom lange linjer tekst forstyrrer flyten i lesingen. Avsnitt er derfor begrenset til maks 696px i bredden, selv om modalen fyller ut 1056px. Teksten skal alltid være venstrestilt. Ha riktig rekkefølge på overskriftsnivåene. Ikke hopp over nivåer, men gå nedover et nivå om gangen. For eksempel er H2 - H2 og H2 - H3 lov, men H1 - H3 er ikke lov.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/",
	"title": "UI-komponenter",
	"tags": [],
	"description": "De ulike komponentene er laget for at de skal passe sammen i en større helhet. Det er derfor viktig å følge retningslinjene for hvordan disse brukes for å oppnå et konsistent og gjenkjennbart uttrykk. UI-komponenter som foreløpig inngår i Altinns bibliotek finner du her.",
	"content": "Har du behov for en ny komponent?\nVi ønsker at alle er med på å videreutvikle biblioteket av komponenter med både design og kode. I praksis vil dette si at Altinn ønsker å ta imot forslag til nye komponenter etter hvert som tjenesteeierne ser behovet for det.\nSjekk gjerne nedenunder at ikke komponenten du trenger allerede eksisterer.\nOpprett en sak i github\rSkriv til oss på Slack\r\r\r\r\rTittel og avsnitt\rDet bør som hovedregel alltid være en header (H2) og et avsnitt i starten på en skjamaside for å oppsummere brukerens oppgave.\n\r\rKnapp og lenke\rHovedknapp (blå) brukes for å sende brukeren til neste steg.\n\r\rInput\rInputfelt brukes når brukeren skal føre inn tekst eller tall.\n\r\rDato\rDatovelger benyttes i forbindelse med planlegging eller for datoer i nærliggende tid. For datoer lengre tilbake i tid brukes datofelt.\n\r\rAvkrysningsboks\rAvkrysningsbokser brukes i tilfeller der brukeren kan huke av ett eller flere alternativer fra en liste.\n\r\rRadioknapp\rRadioknapper brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder nedtrekksliste, så vær bevisst på når du bruker hvilken.\n\r\rNedtrekksliste\rNedtrekksliste brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder radioknapper, så vær bevisst på når du bruker hvilken.\n\r\rHjelpetekst\rHjelpetekster er små tekstsnutter som kan benyttes for å gi brukeren ekstra veiledning i utfylling av skjemafelter.\n\r\rFeilmeldinger\rFeilmeldinger forklarer brukeren hva som gikk galt og hvordan det kan rettes opp i.\n\r\rFilopplasting\rFilopplasting tillater brukere å laste opp en eller flere filer.\n\r\rBilde\rBruk bilder og illustrasjoner for å fremheve poenger eller illustrere konsepter som er vanskelig å beskrive med tekst\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/",
	"title": "Introkurs",
	"tags": ["apps", "build", "deploy", "training"],
	"description": "Et kursopplegg for å lære seg apputvikling med Altinn Studio og lokale verktøy.",
	"content": "Dette intro-kurset er delt opp i seks bolker og dekker et fiktivt case for Sogndal kommune. I løpet av disse seks bolkene vil du ha vært innom den mest sentrale funksjonaliteten for en Altinn App, samt testing av applikasjonen lokalt og i testmiljø.\nTre ting må være på plass før du går i gang med dette kurset.\n En bruker i Altinn Studio Ditt lokale utviklingsmiljø er satt opp med støtte for utvikling og testing av apps Tilgang til en organisasjon med et testmiljø*  * En forutsetning for bolk 3. Resterende bolker kan fullføres med fullt læringsutbytte uten at dette er på plass.\nNå kjører vi i gang! Les gjennom caset til Sogndal kommune, og jobb deg gjennom bolk for bolk. \rCasebeskrivelse\rBeskrivelse av kommunens krav og ønsker til tjenesten\n\r\rBolk 1\rOpprette app i Studio, sette opp lokalt utviklingsmiljø og local test\n\r\rBolk 2\rLegge til flere sider, sporvalg og prefill\n\r\rBolk 3\rBygg og deploy applikasjon til testmiljø\n\r\rBolk 4\rLegge til kodelister manuelt, programatisk og dynamisk\n\r\rBolk 5\rLegge til bekreftelsessteg\n\r\rBolk 6\rUtvidelse av skjema med repeterende gruppe\n\r\rBolk 7\rFrittstående utvidelser av appen\n\r\rLøsningsforslag\rLøsningsforslag og forklaring på forståelsessjekker\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/",
	"title": "Altinn 3 API",
	"tags": ["translate-to-norwegian"],
	"description": "Beskrivelse av Altinn API for sluttbrukere og applikasjonseiere.",
	"content": "The APIs The new solution will have multiple APIs, but they can be divided in two groups. The app APIs and the Platform APIs.\nApp API The application API is an API that provides access to specific instances of a specific app. The API provides features for working with data elements while keeping the metadata document for the instance and its data elements updated. The instance level endpoints revolves around moving an instance through its defined process and controlling some instance level settings.\nMetadata for an app is the second job of the app API. There are endpoint that give access to the metadata of the app itself, its data types and process description.\nEvery app will expose almost identical endpoints and functionality. External parties should need only one client implementation across all app APIs. Technically there is nothing preventing an application owner from adding or making changes to the API, but in those cases it is probably an application with a different process flow. In these cases, the application might require some special handling, and additional documentation should be provided by the application owner.\nhttps://{org}.apps.altinn.no/{org}/{appname} The URL identifies the application owner specific hostname using the short name org, and the identificator of the app consisting of both the application owner short name and the name of the app org/appname.\nPlatform API The Platform APIs are primarily made to support the applications hosted on the platform, but a lot of endpoints can be used directly by both application owners and users. Primarily on the Authentication, Events and Storage APIs.\nThe Storage API provides access to all instances across all applications. It can be used to access metadata about applications, instances, data elements and instance activitylog (events), as well as the actual data content. This API should be the preferred method for application owners to download data associated with instances created based on their applications. Application users can use it if they need a form of message box or want to retrieve archived instances and their data.\nThe Authentication API provides methods for authentication.\nThe Events API provides access to the Events component endpoint for listing events. This can be used sporadically to query Altinn for events that have occured in the solution.\nhttps://platform.altinn.no API user groups There are primarily two groups of users of the Altinn APIs. The first group consists of applications and systems used by the owners of the Apps hosted by Altinn. This group is called Application Owners. The second group consists of organisations and people using the Apps to communicate with the application owners. This group is called Application Users.\nThe two groups have many similar needs, but there are some differences in what type of tasks they need to perform. All new APIs is technically available to both groups, but some endpoints have authorization to allow only on of the groups.\nApplication Owners A list of common tasks for an application owner:\n Query instances for a given application according to status or instance owners. Create an application instance. Upload form data and attachments. Download form data. Change process state (workflow). Confirm instance as complete.  Application Users A list of common tasks for an application user:\n Query instances for themselves or a party they can represent (instance owner). Create an application instance. Upload form data and attachments. Download form data. Change process state (workflow). View status of an instance.  \rApp API\rStandard API\u0026#39;er eksponert av apper i Altinn 3.\n\r\rAuthentication API\rBeskrivelse av hvordan systemer og tjenesteeiere kan benytte Maskinporten eller ID-porten for å få tilgang til APIer i Altinn 3.\n\r\rEvents API\rPlatform API for hendelser.\n\r\rModeller\rDette er en oversikt over de fleste modellene brukt av de forskjellige APIen. Den forklarer ikke hver eneste property i alle modeller, men vil forsøke å gi en solid introduksjon til de viktigste delene.\n\r\rScenarier\rForskjellige API-bruksscenarier.\n\r\rStorage API\rBeskrivelse av API\u0026#39;et til Storage komponenten i Altinn 3 platformen.\n\r\rAltinn Studio Repository API\rOpenAPI (swagger) spesifikasjon for App kildekode API.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/app-metadata/",
	"title": "App metadata",
	"tags": ["api", "translate-to-norwegian"],
	"description": "The application metadata document holds technical information about the app and the data type requirements.",
	"content": "Application The Application model is the main model for metadata for the application.\n   Name Description     id A gobally unique id for the application. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the short name of the application owner and the second part is the name of the app.   versionId The current version of the application. (Currently not in use.)   org The short name of the application owner.   title A collection of the application title in different languages.   validFrom The date and time from when the application can be used to create instances.   validTo The data and time for when the application will expire and can no longer be used to create new instances.   processId The id of the process model being used by the application. (Currently not in use.)   dataTypes A list of all the data types associated with the application. See DataType.   partyTypesAllowed A collection of flags that controls what type of instance owners new instances can be created for. See PartyTypesAllowed   autoDeleteOnProcessEnd A value indicating whether an instance will be automatically deleted once the process ends. This can be used by highly sensitiv applications to force an instance delete instead of sending the instance to the archive.   presentationFields A collection of presentation fields. See PresentationField. Currently not in use.   dataFields A collection of data fields. See DataField.   eFormidling The configuration for the eFormidling integration for the application. See eFormidlingContract.   messageBoxConfig A collection of configurations related to the Altinn Message box    DataType Data type represents the requirements for data elements. Data types representing a form will have model validation in addition to the requirements defined here.\n   Name Description     id The id of the data type. Unique for the app.   description A collection of data type descriptions in different languages.   allowedContentTypes A list of Content-Types allowed by the data type.   allowedContributers A list of allowed contributors. This can be used to restrict who it is that can work with the data type.   appLogic A complex object with information on how a data type is connected to a model. See ApplicationLogic.   taskId A reference to a task from the application process. The value indicate that the data type requirements must be fulfilled before the process can move on from the given step in the process.   maxSize The maximum allowed size of the data element.   maxCount The maximum number of data elements of this type.   minCount The minimum required number of elements of this type.   grouping The name of a group. This can be used to logically associate a data type to a group. E.g Photos or a text resource key.    ApplicationLogic ApplicationLogic holds information about how a data type representing a form is connected to a model.\n   Name Description     autoCreate A value indicating whether a data element will be automatically created once an instance moves into the process step indicated by taskId.   classRef The name of the C# class used to represent the form as a model in application logic.   schemaRef A reference to the original schema used to define the model.    PartyTypesAllowed PartyTypesAllowed contains a set of values indicating the type of owners an instance can have.\n   Name Description     bankruptcyEstate A value indicating that the instance owner can be a bancruptcy estate.   organisation A value indicating that the instance owner can be any organisation.   person A value indicating that the instance owner can be a person.   subUnit A value indicating that the instance owner can be a sub unit.    PresentationField PresentationField represents a form field extraction rule. Every time a form is being saved the presentation field rules will be applied and any values from the form will be stored directly on the instance. This can later be used to present instance specific data in places like the portal message box. The purpose is to make it easier to identify a specific instance in a list with many almost identical instances.\n   Name Description     id An id or key to identify the specific rule.   path A path to a specific field or property in the form model.   dataTypeId The name of the datatype. See DataType.    DataField DataField represents a form field extraction rule. Every time a form is being saved the data field rules will be applied and any values from the form will be stored directly on the instance. While PresentationField will have logic applied to it with regards to where and how it\u0026rsquo;s used, the use of data fields is entirely up to the application developer and the application owner. One usage scenario is to provide data fields which can be used for routing to the correct backend system.\n   Name Description     id An id or key to identify the specific rule.   path A path to a specific field or property in the form model.   dataTypeId The name of the datatype. See DataType.    eFormidlingContract This type is used by a feature still in development.\neFormidlingContract holds the configuration of the eFormidling integration for the application. An application configured to enable eFormidling integration in combination with the eFormidiling contract will send a shipment to eFormidling for every instance that is created.\n   Name Description     serviceId The service identifier of the process   process The process type to be set on the shipment   receiver The receiver of the eFormidling shipment.   sendAfterTaskId The id of the last task to be completed before the shipment is sent   type The document type of the shipment e.g. arkivmelding   typeVersion The version of the document type   standard The document standard e.g. urn:no:difi:arkivmelding:xsd::arkivmelding   securityLevel The security level to be set on the standard business document   dataTypes A list of the dataTypes to be included in the shipment. Data type for both form data and attachments should be listed to be included in the shipment    messageBoxConfig MessageBoxConfig holds configurations related to the presentation of instances in the Altinn MessageBox.\n   Name Description     hideSettings The settings related to hiding an instance from the message box    hideSettings Only one of the two settings should be used at a time.\n   Name Description     hideAlways A boolean indicating that the instance should always be hidden   hideOnTask A list of tasks where the instance should be hidden from the message box    Complete example This is a complete app metadata document with data types.\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/bli-applikasjonseier\u0026#34;, \u0026#34;versionId\u0026#34;: null, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Bli applikasjonseier\u0026#34; }, \u0026#34;validFrom\u0026#34;: null, \u0026#34;validTo\u0026#34;: null, \u0026#34;processId\u0026#34;: null, \u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;allowedContributers\u0026#34;: null, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.BliTjenesteeier_M\u0026#34;, \u0026#34;schemaRef\u0026#34;: null }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: null, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;grouping\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;allowedContributers\u0026#34;: null, \u0026#34;appLogic\u0026#34;: null, \u0026#34;taskId\u0026#34;: null, \u0026#34;maxSize\u0026#34;: null, \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0, \u0026#34;grouping\u0026#34;: null } ], \u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: true, \u0026#34;organisation\u0026#34;: true, \u0026#34;person\u0026#34;: true, \u0026#34;subUnit\u0026#34;: true }, \u0026#34;messageBoxConfig\u0026#34;:{ \u0026#34;hideSettings\u0026#34;:{ \u0026#34;hideOnTask\u0026#34;:[\u0026#34;Task_3\u0026#34;] } }, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: false, \u0026#34;created\u0026#34;: \u0026#34;2020-07-17T08:26:21.5707559Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;sandgrainone\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-07-17T08:26:21.5708691Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;sandgrainone\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/",
	"title": "Endringslogg for app nuget pakker",
	"tags": [],
	"description": "Oversikt over endringer introdusert i App Nuget-pakker.",
	"content": "\rv4\rOversikt over endringer introdusert i v4 av Altinn.App.* pakkene.\n\r\rv3\rOversikt over endringer som ble introdusert i v3 av Altinn.App.* pakkene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/",
	"title": "Bidra til utviklingen av Altinn",
	"tags": [],
	"description": "Samarbeid, del og lær. Alt vi gjør er åpen kildekode på GitHub. Vi setter stor pris på dine kommentarer og bidrag!",
	"content": "Du kan bidra til at Altinn blir en så bra løsning som mulig ved å:\n Følge Altinn 3 på Github Du kan følge med på utviklingen i Github og løfte frem oppgaver som interesserer deg ved å gi de en tommel opp (👍). Har du innspill til oppgaven oppfordrer vi til å legge igjen en kommentar. Rapportere eller fikse feil Har du oppdaget en feil som ikke allerede er rapportert setter vi pris på at du oppretter en sak i github. Dersom du har fikset en feil kan du opprette en Pull Request. Ny komponent/funksjonalitet Trenger du en ny komponent eller funksjonalitet i forbindelse med en app du utvikler? Vi setter pris på at behovet først meldes inn til oss, slik at vi kan vurdere om forslaget er i tråd med eksisterende interaksjonsmønster. Vi ser også på om det bør lages en ny felleskomponent, eller om vi kan utvide funksjonaliteten til en eksisterende komponent. Start derfor gjerne med å foreslå en ny komponent så finner vi ut sammen hvem som utvikler komponenten.  \rForeslå en ny komponent\rOm dere har behov for en komponent eller funksjonalitet som vi ikke tilbyr ønsker vi at behovet blir meldt som en feature request før utviklingen starter.\n\r\rUtvikle en komponent\rStart gjerne utviklingen av ny funksjonalitet eller nye komponenter som er godkjent av Altinn. Vi setter pris på om du planlegger arbeidet ditt med oss før du begynner.\n\r\rIntro for utviklere\rIntroduksjon\n\r\rUtviklingshåndbok\rUtviklingshåndbok for bidrag til kodebasen i Altinn.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk1/",
	"title": "Bolk 1",
	"tags": ["apps", "training", "datamodel", "localtest", "texts"],
	"description": "Opprette app i Studio, sette opp lokalt utviklingsmiljø og local test",
	"content": "I denne bolken skal du basert på kravene fra Sogndal kommune sette opp førstesiden til applikasjonen for tilflyttere og verifisere at ting ser ut som forventet lokalt.\nTemaer som dekkes i denne bolken:\n Opprette ny applikasjon Legge til datamodell og knytte felter Utvikle en app i lokalt utviklingsmiljø Redigering av tekstressurser Teste applikasjon i lokalt utviklingsmiljø (LocalTest)  Oppgaver \rVis/skjul innhold\r\rOpprette ny applikasjon\r\r\rOpprett applikasjonen i Altinn Studio med organisasjonen du har tilgang til som eier. Alternativt kan du opprette applikasjonen med deg selv som eier dersom du ikke skal teste den i et testmiljø.\nKrav fra kommunen   Applikasjonen må ha et fornuftig navn som gjør det enkelt å finne den igjen blant det store antallet repositories Sogndal kommune har i Altinn Studio.\n  Det er ingen foreløpige planer om årlige revisjoner av appen, så man trenger ikke ta hensyn til årstall i navnet.\n  Det er et ønske om at et eller flere av ordene \u0026ldquo;tilflytter\u0026rdquo; og \u0026ldquo;Sogndal\u0026rdquo; er med i navnet.\nNyttig dokumentasjon  Opprette app i Altinn Studio  \r\r \rVis/skjul innhold\r\rLaste opp datamodell\r\r\rSogndal kommune har opprettet en datamodell som representerer data de ønsker å samle inn fra fremtidige innbyggere.\nSom applikasjonsutvikler vil man i noen tilfeller måtte opprette datamodell for en tjeneste selv. Da vil man kunne benytte seg av datamodelleringsverktøyet i Altinn Studio (lanseres våren 2022), eller ta utgangspunkt i en eksisterende datamodell og redigere den i f.eks. Visual Studio eller et selvvalgt tekstredigeringsprogram.\n\r Last ned xsd-filen, åpne den i et tekstredigeringsprogram og ta en nærmere titt på innholdet. Last opp datamodellen i Altinn Studio Push endringene master og ta en nærmere titt på filene i mappen App/models  Forståelsessjekk  Hvilken data er det tjenesteeier ønsker å samle inn her? Hvilken effekt har \u0026lt;minOccurs\u0026gt; i datamodellen? Du vil se at feltet har ulik verdi for Inflytter.Fornavn og Inflytter.Mellomnavn Hvilke andre egenskaper er satt på feltet Innflytter.Mellomnavn? Det er blitt generert en .C#, .metadata.json og .schema.json fil i tillegg til .xsd filen som du lastet opp. Hva er sammenhengen mellom disse filene? Enkelte restriksjoner fra datamodellen overføres ikke til C#-filen, hvilke? Det er og lagt til nye egenskaper, hvilke?  Nyttig dokumentasjon  Laste opp datamodell i Altinn Studio Beskrivelse av indikatorer i XSD  \r\r \rVis/skjul innhold\r\rRedigere tekster\r\r\rFor at tjenesten skal være brukervennlig og mulig å benytte for de som sitter med synshemninger er det viktig at alle komponenter har gode og beskrivende overskrifter og beskrivelser. Vi ønsker nå at dere legger til tekster som skal brukes for hvert datafelt.\nDet er mulig å koble tekster til komponenter både i Altinn Studio og lokalt.\nMERK: Visningsnavn for applikasjonen må endres både i App/config/applicationMetadata.json og i tekstressursene.\n\rKrav fra kommunen  Alle inputfelter skal ha forklarende labels som beskriver hva som skal fylles inn Applikasjonen må være tilgjengelig både på bokmål, nynorsk og engelsk I en første versjon er det tilstrekkelig at kun ett av disse språkene støttes Det er viktig at applikasjonens visningsnavn klinger godt og er beskrivende for tjenesten  Nyttig dokumentasjon  Redigere applikasjonstekster Formatering av tekster ISO 639-1 standard  Forståelsessjekk I Altinn i dag støtter vi tre skriftspråk: bokmål, nynorsk og engelsk.\n Hvordan får du inn engelsk språkstøtte i applikasjonen? Hvis vi en dag skal støtte Ukrainsk, hvilken språkkode vil du da måtte annotere filen med? Hvis en tekstnøkkel refert til i FormLayout.json ikke finnes i tekstressursene, hva vil vises da?  \r\r \rVis/skjul innhold\r\rSette opp komponenter\r\r\rFeltene som skal fylles ut på en skjemaside kan settes opp ved hjelp av \u0026ldquo;drag and drop\u0026rdquo; i Altinn Studio eller manuelt i json-filen som beskriver utseendet til en skjemaside FormLayout.json.\nBasert på kravene fra kommunen klarer du å sette opp den første skjemasiden i Altinn Studio?\nKrav fra kommunen  Vil ha navn og alder på personen som er tilflytter  Fornavn Mellomnavn (valgfritt) Etternavn Alder   Vil ha adressen på personen som er tilflytter  Gateadresse Postnummer Poststed   Vil ha kontaktinformasjon på personen som er tilflytter  Epost Telefon    Nyttig dokumentasjon  Tilgjengelige komponenter i Altinn Studio Retningslinjer for bruk av komponenter  Forståelsessjekk I applikasjonsrepoet ditt finner du FormLayout.json i mappen App/ui/layouts. JSON-filen beskriver skjemasiden du har satt opp i Altin Studio, gitt at du har pushet endringene dine til master.\n Finner du igjen komponenten som er koblet til e-post-feltet? Hvilken endring kreves i denne filen dersom e-post-feltet ikke lenger skal være påkrevd? Ved å endre én linje i FormLayout.json er det mulig å endre komponenten knyttet til mellomnavn til et input felt for et langt svar. Hvilken endring kreves?  \r\r \rVis/skjul innhold\r\rLaste ned applikasjonen lokalt\r\r\rEnkelte applikasjonsfeatures er det ikke støtte for å utvikle i Altinn Studio. Disse må utvikles i et lokalt utviklingsmiljø.\nSelve utviklingen kan gjøres i ditt foretrukne utviklerverktøy, men trenger du en anbefaling er Visual Studio Code et godt alternativ.\nNyttig dokumentasjon  Hvordan klone applikasjon til lokalt utviklingsmiljø Hvordan synkronisere endringer i lokalt utviklingsmiljø  \r\r \rVis/skjul innhold\r\rKjøre appen i localtest\r\r\rVed hjelp av en mock som kan spinnes opp lokalt av Altinn Plaform er det mulig å gjøre enkel testing og verifikasjon av applikasjonen i det lokale utviklingsmiljøet.\nI denne oppgaven skal du få kjørt opp applikasjonen lokalt med støtte fra LocalTest. Når du har fått appen opp og kjøre og logget inn med en testbruker, bør du ha et resultat som likner dette:\nVidere vil du ønske å teste endringene dine fortløpende i localtest.\n Ved endringer knyttet til formLayout og andre json-filer holder det med en refresh (F5) i nettleser. Ved endringer i prefill vil man måtte instansiere applikasjonen på nytt. Ved endringer i cs-filer må applikasjonen stoppes og startes på nytt. Alternativt kan du benytte deg av dotnet run watch når du starter applikasjonen for hot reload.  \rNyttig dokumentasjon  Hvordan sette opp LocalTest Debugging av applikasjon Tilgjengelig testbrukere i LocalTest  \r\r Oppsummering I denne bolken har du opprettet en applikasjon i Altinn Studio, lastet opp en datamodell og satt opp en skjemaside som kobler komponenter til noen av feltene i datamodellen. Videre har du klonet repoet lokalt for å kunne videre applikasjonen i ditt lokale utvilkingsmiljø.\nTjenesten skal kunne kjøres opp på din lokale maskin med local test og du skal kunne fylle inn feltene.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelig i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk2/",
	"title": "Bolk 2",
	"tags": ["apps", "training", "prefill", "sporvalg"],
	"description": "Legge til flere sider, sporvalg og prefill",
	"content": "I denne bolken skal du videreutvikle applikasjonen du laget i bolk 1 for å oppfylle flere av kravene fra Sogndal kommune.\nTemaer som dekkes i denne bolken:\n Flere sider Bildekomponent Sporvalg Prefill  Oppgaver \rVis/skjul innhold\r\rLegge til infoside\r\r\rFor skjemaer der det samles inn eller gis mye informasjon vil det forbedre brukeropplevelsen dersom man deler applikasjonen opp i flere sider.\nLa oss se nærmere på hvordan man kan opprette en ny side i applikasjonen som vises før brukeren kommer til første datainnsamlingsside som ble laget i bolk 1.\nFor å redigere ulike skjemasider i Altinn Studio må du:\n Logge inn i Altinn Studio Finne applikasjonen din på dashboardet og trykke Rediger app Navigér til Lage-fanenåpner Til høyre finner du området for administrasjon av skjemasider.  Opprettelse og administrasjon av flere sider kan enkelt gjøres i Altinn Studio, men dersom du ønsker å gjøre det manuelt kan dokumentasjonen her være til hjelp.\n\rDa er det eneste som gjenstår å sette seg inn i kommunens krav til infosiden og komme i gang med utviklingen. Lykke til!\nKrav fra kommunen I og med at det skal samles inn en god del data i denne tjenesten, er det viktig for Sogndal kommune at det tydelig kommuniseres hvem skjemaet er ment for og hva som vil gjøres med dataen som samles inn. Noen i kommunen har opprettet en skisse av informasjonssiden.\nFølgende er ønskelig at reflekteres i applikasjonen:\n plassering av bilder tekststørrelser formatering av tekst  Skisse på informasjonsside\nSkisse på informasjonsside (.docx)\nNyttig dokumentasjon  Formatering av tekst i en applikasjon Hvordan legge til bilder i en applikasjon Sidestilte komponenter Filoppsett ved flere sider Administrere rekkefølge på flere sider  Forståelsessjekk  Hvilken fil i applikasjonsrepoet er det som må justeres på dersom du manuelt ønsker å endre siderekkefølgen på eksisterende sider? Hvis du ønsker å gi en side et annet navn, men ikke har Altinn Studio tilgjengelig, hvilke filer må oppdateres med det nye filnavnet? Hvordan oppnår du at teksten bryter dersom tekststrengen ikke er lang nok til å naturlig brytes?  \r\r \rVis/skjul innhold\r\rAlternativ arbeidsflyt (sporvalg)\r\r\rI mange tilfeller er det ikke aktuelt å svare på alle spørsmål i et skjema, kanskje fordi svaret sier seg selv, eller fordi det ikke er relevant basert på noe man har svart tidligere i skjemaet. Da kan sporvalg være en god løsning.\nVed hjelp av sporvalg kan man styre hvilke siden av en applikasjon som er synlige for brukeren.\nI denne oppgaven skal du sette opp sporvalg i applikasjonen basert på kravene fra Sogndal kommune.\nKrav fra kommunen En bruker som ikke oppfyller kravene for skjemaet skal stoppes så tidlig som mulig i arbeidsflyten.\nPå infosiden er det ønskelig at brukeren skal oppgi om skjemaet gjelder dem eller ikke.\nHvordan dette gjøres er fritt fram, og feltet Innflytter.KanBrukeSkjema i datamodellen er mulig å benytte til dette formålet.\nBasert på svaret skal brukeren sendes videre til Spor 1 eller Spor 2.\nSpor 1   Brukeren har ikke svart bekreftende på at skjemaet gjelder deres situasjon\n  Bruker skal sendes til en side med følgende tekst:\nDette skjemaet er ikke for deg.\rSe en oversikt over andre tilbud i kommunen her.\r  Linje 2 i teksten skal være en hyperlenke som peker på: https://www.sogndal.kommune.no/\n  Det skal ikke være mulig å navigere til andre skjemasider etter denne.\n  Spor 2   Brukeren har svart bekreftende på at skjemaet gjelder deres situasjon\n  Brukeren sendes videre til datainnsamlingssidene.\n  Nyttig dokumentasjon  Hvordan sette opp sporvalg Formatering av tekst  Forståelsessjekk  Hvis en bruker går tilbake og endrer svaret sitt på infosiden, får den da opp datainnsamlingssidene? Hvis ikke. Hvilke endringer kan du gjøre for å støtte dette i din applikasjon? Dersom man har sporvalg på et senere tidspunkt i en arbeidsflyt og en sluttbruker endrer et valg. Hva skjer med skjemdataen man tidligere har fylt ut, dersom siden skjules for sluttbrukeren?  \r\r \rVis/skjul innhold\r\rPreutfylling av personopplysninger\r\r\rEn av fordelene til Altinn er at man allerede har metadata om både personer og virksomheter tilgjengelig. Ved hjelp av prefill kan man hente ned data om brukeren og presentere denne i en app, slik at de slipper å fylle inn disse feltene. Typiske prefillverdier vil være: navn, adresse, e-post ect.\nDersom dataen er tilgjengelig i en av Altinns prefillkilder kan dette konfigureres mot et felt i datamodellen og automatisk populeres når skjemaet opprettes. Dersom man har andre behov for prefill kan dette løses med kode i applikasjonen.\nI denne oppgaven flyttes fokus tilbake til den første datainnsamlingssiden, og målet er å preutfylle personopplysninger om sluttbrukeren for å spare brukeren litt tid.\nKrav fra kommunen   Dersom personen som arbeider i skjemaet selv er tilflytter skal følgende verdier preutfylles:\n Fornavn: Innflytter.Fornavn Mellomnavn: Innflytter.Mellomnavn Etternavn: Innflytter.Etternavn E-post: Innflytter.Kontaktinformasjon.Epost Telefonnummer: Innflytter.Kontaktinformasjon.Telefonnummer Alder: Innflytter.Alder    Det skal ikke være mulig å endre preutfylt navn og alder\n  Det skal være mulig å endre preutfylt e-post og telefonnummer\n  Nyttig dokumentasjon  Tilgjengelige prefillkilder Prefill fra nasjonale register og brukerprofil Egendefinert prefill Beskrivelse av InstanceOwner-objektet  Kodehjelp: Beregning av alder fra personnummer private static int CalculateAge(string sosialSecNumber) { int MAX_D_NUMBER = 71; int MIN_D_NUMBER = 41; int MAX_TEST_NUMBER = 92; int MIN_TEST_NUMBER = 81; int START_D_NUMBER = 40; int START_TEST_NUMBER = 80; string stringDay = sosialSecNumber.Substring(0, 2); string stringMonth = sosialSecNumber.Substring(2, 2); string stringYear = sosialSecNumber.Substring(4, 2); string stringIndivid = sosialSecNumber.Substring(6, 3); int day = int.Parse(stringDay); int month = int.Parse(stringMonth); int year = int.Parse(stringYear); int individ = int.Parse(stringIndivid); // Get day if D-number  if (MAX_D_NUMBER \u0026gt;= day \u0026amp;\u0026amp; MIN_D_NUMBER \u0026lt;= day) { day -= START_D_NUMBER; } // Get month if TestUser-number  if (MAX_TEST_NUMBER \u0026gt;= month \u0026amp;\u0026amp; MIN_TEST_NUMBER \u0026lt;= month) { month -= START_TEST_NUMBER; } // find century  if (year \u0026gt; 54 \u0026amp;\u0026amp; (individ \u0026gt;= 500 \u0026amp;\u0026amp; individ \u0026lt; 750)) { // 1855-1899  year += 1800; } else if (year \u0026gt; 39 \u0026amp;\u0026amp; (individ \u0026gt;= 900 \u0026amp;\u0026amp; individ \u0026lt; 1000)) { // 1940-1999  year += 1900; } else if (year \u0026lt; 40 \u0026amp;\u0026amp; (individ \u0026gt;= 500 \u0026amp;\u0026amp; individ \u0026lt; 1000)) { // 2000-2039  year += 2000; } else { year += 1900; } // calculate age  int age = DateTime.Now.Year - year; if (DateTime.Now.Month \u0026lt; month) { age -= 1; } else if (DateTime.Now.Month == month) { if (DateTime.Now.Day \u0026lt; day) { age -= 1; } } return age; } Forståelsessjekk  Er det mulig å endre en prefillverdi når den først er satt? Hvordan kan man hindre at en prefillverdi endres av sluttbrukeren? Ikke alle norske innbyggere har et personnr, noen får tildelt et D-nummer. Hvordan må koden din justeres for å ta hensyn til dette dersom alder skal baseres på et f-nr eller d-nr som sluttbruker selv taster inn?  \r\r Oppsummering I denne bolken har du utvided applikasjonen din med mer funksjonalitet i form av å, legge til flere sider, sette opp sporvalg for å styre brukerflyten og satt opp preutfylling av skjemafelter både med tilgjengelig datakilder i Altinn og custom kode.\nTjenesten skal kunne kjøres opp på din lokale maskin med local test og du skal kunne teste begge brukerflytene og bekrefte at riktige felter blir preutfylt.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelig i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk3/",
	"title": "Bolk 3",
	"tags": ["apps", "training", "build", "deploy", "test"],
	"description": "Bygg og deploy applikasjon til testmiljø",
	"content": "Denne bolken krever at du er medlem av en organisasjon som har et etablert testmiljø for Altinn Apps. Dersom dette ikke er tilfellet, går du bare videre til neste bolk.\r\rI denne bolken skal du bygge og deploye applikasjonen til Altinns testmiljø (TT02) og verifisere at alt fungerer som forventet også der.\nTemaer som dekkes i denne bolken:\n Sette egendefinerte krav for ressursbruk Bygg av applikasjon Deploy av applikasjon  Oppgaver \rVis/skjul innhold\r\rSette egendefinerte krav for ressursbruk\r\r\rAlle applikasjoner kommer med et standardoppsett for ressursbruk og skalering i applikasjonsclusteret. Det oppsettet er mulig å overstyre dersom applikasjonen din skulle ha andre behov.\n Man kan endre antall replikas (instanser av applikasjonen som kjører samtidig) Man kan endre reglene for hvor tidlig eller sent applikasjonen skal skalere antall instanser ut ifra CPU eller minnebruk Man kan endre hvor mye ressurser som skal dedikeres til applikasjonens instanser i clusteret  Ved å overstyre disse verdiene kan man for mindre applikasjoner spare kostnader, og for større applikasjoner sørge for at de har en optimal ytelse med alle nødvendige ressurser tilgjengelig.\nFor denne testapplikasjonen ønsker vi at du skal skalere ned resursbruken til det minimale.\nSkalering: replicaCount: 1\nRessursbruk: Sett requests til cpu: 50m og 128Mi\nAlle endringer knyttet til skalering og ressursbruk gjøres i deployment/values.yaml-filen\n\rNyttig dokumentasjon  Sette egendefinerte regler for skalering Sette egendefinerte grenser for ressursbruk  \r\r \rVis/skjul innhold\r\rBygge applikasjon\r\r\rNår man referer til å bygge en applikasjon i Altinn Studio, betyr dette å opprette en versjon av applikasjonens nåværende tilstand som kan deployes til et eller flere miljø.\nOpprett et nytt bygg for applikasjonen med versjonsnr 0.0.1 og legg til en beskrivende kommentar om hva versjonen inneholder.\nNyttig dokumentasjon  Bygge app i Altinn Studio  \r\r \rVis/skjul innhold\r\rDeploye applikasjon\r\r\rVed å deploye en applikasjon til testmiljø vil man kunne teste alle integrasjoner. I tillegg benyttes TT02ofte til å verifisere at en applikasjon oppfører seg som forventet før man deployer til produksjon.\nFor å kunne deploye en applikasjon til TT02 må organisasjonen som eier applikasjonen ha et apps cluster i testmiljøet. I tillegg trenger utvikleren som skal deplopye applikasjonen rollen Deploy-TT02 for organisasjonen i Altinn Studio.\n\rDeploy applikasjonen din til TT02 og test de ulike sporvalgene og skjemasidene for å bekrefte at det oppfører seg som forventet.\nNyttig dokumentasjon  Deploye app til testmiljø Tilgangsstyring for organisasjon i Altinn Studio  Forståelsessjekk  Er det mulig å ha to versjoner av en applikasjon i TT02 samtidig? Hva skjer hvis man deployer samme versjon av applikasjonen til miljøet en gang til? Vil applikasjonen være tilgjengelig umiddelbart etter deploy? Er det mulig å fjerne en applikasjon fra miljøet hvis den først er blitt deployet?  \r\r \rVis/skjul innhold\r\rTeste applikasjonen i TT02\r\r\rPå deploysiden finner du direktelenken til applikasjonen din. Den er på formatet {org}.apps.tt02.altinn.no/{org}/{app}\nMed mindre du er logget inn med en bruker fra før av, vil denne lenken ta deg til innloggingssiden til Altinn. Organisasjonen din bør ha tilgang på et sett med testbrukere, benytt en av disse for å logge inn.\nFor interne ressurser i DigDir: Benytt deg av en av testbruker som du finner i testdatasettet og logg inn.\n\r\r Oppsummering I denne boken har du bygget og deployet applikasjonen din til TT02, logget inn i Altinn med en testbruker, og testet applikasjonen din.\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk4/",
	"title": "Bolk 4",
	"tags": ["apps", "training", "options", "kodelister", "dynamikk"],
	"description": "Legge til kodelister manuelt, programatisk og dynamisk",
	"content": "I denne bolken skal du utvide applikasjonen du har laget i foregående bolker for å støtte enda fler av kravene til Sogndal kommune.\nTemaer som dekkes i denne bolken:\n Kodelister/Options Dynamikk  Oppgaver \rVis/skjul innhold\r\rInnsamling av arbeidsopplysninger\r\r\rI mange applikasjoner er det behov for å gi brukeren et sett med svaralternativer for et datafelt. Svaralternativene refereres dette til som kodelister eller options.\nI Altinn Studio er dette støttet i form av radioknapper, avkrysningsbokser og nedtrekkslister.\nDet er tre måter å sette opp kodelister i Altinn i dag\n Direkte på komponenten via Altinn Studio eller manuelt i FormLayout.json* I en statisk json-fil som referes til i komponenten Programmatisk i applikasjonslogikken  * kun tilgjengelig på radioknapp og avkrysningsboks\n\rI denne oppgaven skal du få prøve deg på alle tre måtene å sette opp en kodeliste på.\nSogndal kommune ønsker å samle inn opplysninger om tilflytterens arbeidsituasjon. Blant dataen de ønsker å samle inn er hvilken sektor og bransje tilflytter jobber i, og hvor mange år tilflytter har vært yrkesaktiv.\nI Altinn Studio   Opprett en ny skjemaside for å samle inn data om arbeidsforhold\n  Sett opp en radioknapp-komponent for Sektor opprett svaralternativene Offentlig og Privat manuelt.\n  Sett opp en avkrysningsboks for Bransje. Velg Kodeliste som metode for å legge til avkrysningsboker og legg inn Kodeliste ID industry\nResten av oppsettet for denne komponenten gjøres lokalt.\n  Sett opp en nedrekksliste for År i arbeidslivet Legg inn Kodeliste ID years-in-work-force\nResten av oppsettet for denne komponenten gjøres lokalt.\n  Commit og Push endringene dine til master, og Pull endringene i ditt lokale utviklingsmiljø.\n  I lokalt utviklingsmiljø   Sogndal kommune har opprettet en kodeliste for bransjer. Last ned filen og plasser denne på rett sted i repoet.\n  Sett opp verdiene i kodelisten for År i arbeidslivet direkte i applikasjonslogikken.\nSvaralternativer:\n   Label Dataverdi     0 - 5 år 0-5   5 - 10 år 5-10   10 - 20 år 10-20   20+ år 20+      Verifiser at alle kodelister fungerer som forventet.\n  Nyttig dokumentasjon  Hvordan sette opp statiske kodelister Hvordan sette opp dynamiske kodelister Sikrede dynamiske options  Forståelsessjekk  Hva er forskjellen på statiske og dynamiske options? Hva vil være et bruksområde for sikrede dynamiske options?  \r\r \rVis/skjul innhold\r\rDifferensiert datagrunnlag for offentlig og privat sektor\r\r\rI noen tilfeller kan verdiene som skal vises fram i en kodeliste være knyttet til et annet felt i skjemaet.\nSogndal kommune ønsker at listen av bransjer å velge mellom skal spisses til hvilken sektor man jobber i.\nLes gjennom kravene til kommunen for å se om du kan hjelpe dem.\nKrav fra kommunen Vi ønsker at brukeren skal ha et ulikt sett med svaralternativer for bransje-valget basert på hvilken sektor de har krysset av for.\n Privat sektor: Standard listen med bransjer Offentlig sektor: Stat og Kommune  Nyttig dokumentasjon  Hvordan sende med query parameter ved henting av options  Forståelsessjekk  Om en option-liste er satt opp med en mapping mot datamodellen - hva skjer når det aktuell feltet endrer verdi? Hva skjer med valgt verdi på et felt som er koblet til en option-liste som hentes på nytt fra server siden?  \r\r \rVis/skjul innhold\r\rSkreddersydd tilbud for IT-kompetanse\r\r\rKrav fra kommunen Vi ønsker at dersom brukeren velger IKT (data/it) under bransje at det vises en tekst med en lenke til en av våre stillingsutlysninger.\n  Under bransje-valget skal følgende tekst presenteres\nVi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her.\r  Linje 2 i teksten skal være en hyperlenke som peker på: https://sogndal.easycruit.com/index.html\n  Tekst og lenke skal kun vises om man har valgt IKT (data/it) i alle andre tilfeller skal dette være skjult.\nNyttig dokumentasjon  Legge til funksjoner for regler eller dynamikk Eksempler på bruk av dynamikk i skjema  Forståelsessjekk  Hvis du legger til en ny funksjon i RuleHandlerHelper - hvor kjøres disse funksjonene?  Vil dynamikk fungere uten denne definert?   Hvis du legger til en ny funksjon i RuleHandlerObject - hvor kjøres disse funksjonene?  Vil dynamikk fungere uten denne definert?   Hva er sammenhengen mellom funksjoner definert i RuleHandlerObject og filen RuleConfiguration.json?  \r\r Oppsummering I denne bolken har du satt opp nedtrekksliste, radioknapp og avkrysningsbokser og lagt inn verdier for disse komponentene manuelt, programatisk og dynamisk.\nTjenesten skal kunne kjøres opp på din lokale maskin med local test og du skal kunne validere at komponentene presenterer forventede dataverdier.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelig i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk5/",
	"title": "Bolk 5",
	"tags": ["apps", "training", "process", "policy", "autorisasjon", "confirmation", "bekreftelsessteg", "validering"],
	"description": "Legge til bekreftelsessteg",
	"content": "I denne bolken skal du legge til et prosessteg i applikasjonen.\nTemaer som dekkes i denne bolken:\n Prosess Brekreftelsessteg Autorisasjonsregler Validering Overstyre standardtekster  Oppgaver \rVis/skjul innhold\r\rUtvide prosess med et bekreftelsessteg\r\r\rEn Altinn App har en prosessflyt som beskriver de ulike stegene i flyten. Standardflyten for en nyopprettet applikasjon består av én task, et utfyllingssteg.\nDin oppgave er å utvide standard prosessflyten med et bekreftelsessteg som illustrert nedenfor.\nStandard prosessflyter er tilgjengelig på GitHub. Finner du den som passer til flyten vi ønsker å oppnå her?\nHar du lyst på en ekstra utfordring kan du redigere prosessflyten manuelt eller i en BPMN editor, og heller bruke malen på prosessflyt med data og bekreftelsessteg som fasit.\n\rKrav fra kommunen På dette punktet i arbeidsflyten skal brukeren kunne:\n Se over dataen som er utfylt Avslutte arbeidsflyten uten å sende inn skjemaet Avslutte arbeidsflyten og sende inn skjemaet  Nyttig dokumentasjon  Tilgjengelige prosessteg i en Altinn App Hvordan endre prosessflyten til en applikasjon Online BPMN editor BPMN standard  Forståelsessjekk  Hvilke Altinn-spesifikke egenskaper er satt på hver prosesstask? Hvilke begrensninger vil en ekstern BPMN editor ha når man skal redigere prosessbeskrivelsen til en Altinn App? Vil prosessflyten kunne gå begge veier? Fra utfylling til bekreftelse og fra bekreftelse til utfylling?  \r\r \rVis/skjul innhold\r\rLegge til autorisasjonsregler for bekreftelsessteget\r\r\rPolicy-filen til applikasjonen din er tilpasset standard prosessflyt. Oppdater policyfilen, så den har autorisasjonsregler som dekker det nye prosessteget.\nKrav fra kommunen  Det skal være samme rollekrav for å fylle ut og bekrefte en instans.  Nyttig dokumentasjon  Regelbibliotek Alle roller i Altinn  Forståelsessjekk  Hva vil skje når prosessflyten går videre til bekreftelse-steget uten at autoriasjonsreglene er blitt oppdatert? Hva skjer dersom du ikke spesifiserer hvilke roller som har lov til å utføre en aksjon i en autorisasjonsregel?  \r\r \rVis/skjul innhold\r\rValidering av innsender\r\r\rKrav fra kommunen  Det skal kun være mulig for brukeren som eier instansen å sende inn skjemaet, selv om andre måtte inneha de nødendigve rollene  Nyttig dokumentasjon  Egendefinert validering  Forståelsessjekk  Hvilken endring ville du foreslått for kunden for å kunne oppfylle dette kravet uten å legge inn egendefinerte valideringen på dette steget?  \r\r \rVis/skjul innhold\r\rOverstyre standardtekster for bekreftelsesside\r\r\rKrav fra kommunen Vi ønsker at brukeren skal presenteres med følgende tekst før innsending\nDu er nå klar for å sende inn melding om tilflytting til Sogndal kommune.\rVed å sende inn dette skjemaet samtykker du til at dataen du har fylt ut kan lagres og benyttes til å tilpasse kommunens tilbud til deg de neste 18 månedene.\rFør du sender inn vil vi anbefale å se over svarene dine. Du kan ikke endre svarene etter at du har sendt inn.\rNyttig dokumentasjon  Tilpasning av brekreftelsessiden  \r\r Oppsummering I denne bolken har du utvided applikasjonen din med et bekreftelsessteg, tilpasset visningen, og lagt til validering og autorisasjonsregler knyttet til prosessteget.\nTjenesten skal kunne kjøres opp på din lokale maskin med local test og du skal kunne teste det nye prosessteget og bekrefte at visningen ser ut som ønsket.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelig i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk6/",
	"title": "Bolk 6",
	"tags": ["apps", "training", "repeterende grupper", "validering", "dataprosessering", "konsumere API"],
	"description": "Utvidelse av skjema med repeterende gruppe",
	"content": "I denne bolken skal du utvide applikasjonen du har laget i foregående bolker for å støtte mer av funksjonaliteten som Sogndal kommune ønsker.\nTemaer som dekkes i denne bolken:\n Repeterende grupper Validering Dataprosessering  Oppgaver \rVis/skjul innhold\r\rRepeterende grupper\r\r\rKrav fra kommunen For å kunne skreddersy et best mulig tilbud til nye innflyttere ønsker vi oss en oversikt over tidligere bosteder til innflytteren.\nPå datasiden ønsker vi at det legges opp til at brukeren kan fylle inn tidligere bosteder. Tidligere bosteder skal inneholde følgende felter:\n Gateadresse Postnummer Poststed  Det skal være mulig å legge inn opptill 10 tidligere bosteder.\nNyttig dokumentasjon  Oppsett for gruppering av felter Oppsett for repeterende grupper  Forståelsessjekk  Hvilket felt i datamodellen er det som bestemmer om et element er repeterende? Hvor mange repetisjoner er tillatt for feltet TidligereBosteder?  \r\r \rVis/skjul innhold\r\rValidering\r\r\rKrav fra kommunen Grunnet en personlig vendetta blant en av Sogndal-kommunes ansatte ønsker vi at om innflytter fyller inn postnummer 4619 som en av tidligere bosteder IKKE skal få lov til å flytte inn i Sogndal. Her ønsker vi at det skal dukke opp en feilmelding på det aktuelle feltet med følgende tekst:\nDu er ikke velkommen til vår kommune. Beklager!\rNyttig dokumentasjon  Serverside valideringer Hvordan legge til egendefinert validering Enkeltfeltvalideringer  Forståelsessjekk  Når kjøres valideringer serverside? Hvorfor burde valideringer som legges til på klientsiden også dupliseres serverside?  \r\r \rVis/skjul innhold\r\rDataprosessering\r\r\rKrav fra kommunen En av kommunens databehandlere har sett seg lei av å manuelt rette opp i en gateadresse som ofte blir skrevet feil av innflyttere. Vi ønsker derfor å programatisk fikse opp i dette under utfyllingen av appen.\nOm sluttbruker fyller inn Sesame Street 1 i feltet Innflytter.Adresse.Gateadresse skal dette automatisk rettes til Sesamsgate 1. I alle andre tilfeller skal feltet forbli urørt.\nNyttig dokumentasjon  Dataprosessering Kalkulering  Forståelsessjekk  Når blir Data processing kjørt? Hva skiller ProcessDataWrite og ProcessDataRead? Hva er forskjellen på DataProcessing og Calculations?  \r\r Oppsummering I denne bolken har du sett på repeterende grupper og hvordan dette konfigureres som en del av brukergrensesnittet. Vi har også sett på hvordan man setter opp custom valideringer i backend for caser som ikke lar seg definere som en del av restriksjoner i datamodellen. Til slutt har vi sett på hvordan man kan sette opp dataprosessering som muliggjør manipulering av data runtime.\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/bolk7/",
	"title": "Bolk 7",
	"tags": ["apps", "training"],
	"description": "Frittstående utvidelser av appen",
	"content": "MERK: Denne bolken er fortsatt under utvikling. Ta en titt innom på et senere tidspunkt så er den nok blitt enda bedre!\r\rI denne bolken er det en samling med frittstående utvidelser av applikasjonen. De trenger ikke å løses i rekkefølge.\nTemaer som dekkes i denne bolken:\n Oppsummmeringsside Stateless applikasjon Variabler i tekst Bruk av eksternt API Konfigurasjon av Meldingsboks Presentasjonstekster  Oppgaver \rVis/skjul innhold\r\rOppsummeringsside\r\r\rKrav fra kommunen Sogndal kommune opplever at enkelte innsendinger inneholder feilopplysninger og skrivefeil som skaper unødig arbeid for saksbehandlere. For å unngå at personer sender inn feil informasjon ønsker kommunen at brukeren presenteres for en oppsummmeringsside som viser hvilk\nSogndal kommune ønsker at man benytter kategoriene Personalia om brukerens person-infomrasjon, og Arbeid om svarene gitt på brukerens arbeidshistorikk.\nNyttig dokumentasjon  Hvordan sette opp visning av oppsummering av utfylt skjema Kategorier i oppsummering  Forståelsessjekk  Hvorfor burde oppsummeringssiden ignoreres fra PDF-genereringen?  \r\r \rVis/skjul innhold\r\rStateless førsteside\r\r\rKrav fra kommunen Sogndal kommune har oppdaget at det er en del trafikk fra personer som ikke møter kriteriene i applikasjonen. For hver av disse brukerene blir det laget en instans lagret til databasen. Dette skaper unødige utgifter.\nSogndal kommune ønsker derfor at informasjonssiden vises som en \u0026ldquo;stateless\u0026rdquo;-del av applikasjonen, og at man derfra kan velge å starte en instans om man møter kriteriene.\nNyttig dokumentasjon  Introduksjon til stateless applikasjoner Konfigurasjon av stateless applikasjoner Starte instans fra stateless skjema  Forståelsessjekk  Hva lagres av data for stateless applikasjoner?  \r\r \rVis/skjul innhold\r\rVariabler i tekst\r\r\rKrav fra kommunen IT-kompetanse er svært ettertraktet. I Bolk 4 satt vi opp et skreddersydd tilbud til de med IT-kompetanse.\nSogndal kommune har sett på tallene og ser at det genererer for lite trafikk til stillingsutlysningene. For å prøve å forbedre dette ønsker vi at tilbudet blir enda litt mer skreddersydd.\nVi ønsker at den originale teksten:\nVi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her.\rNå skal inneholde en personlig touch med brukerens navn. Teksten vi nå ønsker oss er:\nHei, {innsenders navn}! Vi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her.\rSiste linje i teksten skal fortsatt være en lenke til stillingsutlysningene.\nNyttig dokumentasjon  Variabler i tekster  Forståelsessjekk  Hva vises som en del av teksten om den aktuelle variabelen ikke har noen verdi i datamodellen?  \r\r \rVis/skjul innhold\r\rEksternt API\r\r\rI noen tilfeller vil man måtte ta i bruk eksterne API for å dekke alle behovene til en applikasjon. Dette kan være for å berrike nedtrekkslister eller å presentere data til brukeren basert på informasjon de har oppgitt.\nI denne oppgaven skal du implementere en klient som integrerer seg mot Bring sine APIer for å berrike adressen som sluttbruker oppgir med et poststed basert på postnummer.\nAPIet som skal benyttes er et postnummer oppslag tilgjengeliggjort av Bring. Test det gjerne i nettleser med ulike postnummer.\nGET\rhttps://fraktguide.bring.no/fraktguide/api/postalCode.json?country=no\u0026amp;pnr={postnummer}\rKrav fra kommunen  Adresseinformasjonen skal samles inn via standard-input komponenter og ikke Altinns adressekomponent Poststed skal automatisk fylles ut for sluttbruker når postnummer er oppgitt Poststed skal ikke være mulig å redigere Antall kall til Bring sitt API skal begrenses til maksimalt én gang om dager per postnummer  Nyttig dokumentasjon Konsumering av eksterne API\nForståelsessjekk  Med en memorycache hvor mange ganger vil man maksimalt gjøre et API-kall i løpet av et døgn dersom applikasjonen kjører med tre replikas  \r\r \rVis/skjul innhold\r\rVise og skjule elementer i meldingsboks\r\r\rKrav fra kommunen Nyttig dokumentasjon Forståelsessjekk \r\r \rVis/skjul innhold\r\rPresentasjonstekst\r\r\rKrav fra kommunen Nyttig dokumentasjon Forståelsessjekk \r\r \rVis/skjul innhold\r\rEvents\r\r\rKrav fra kommunen Nyttig dokumentasjon Forståelsessjekk \r\r "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/",
	"title": "App brukergrensesnitt",
	"tags": [],
	"description": "Konfigurering av komponenter, layouts, sider, grid, etc.",
	"content": "\r\rSider\rHvordan sette opp en app med flere sider, sporvalg, oppsummering eller flere skjema.\n\r\rFelter\rHvordan sette opp felter og gruppering.\n\r\rStyling\rHvordan styre styling, formatering og grid-layout for en app.\n\r\rBilder\rHvordan legge til og endre referanser til bilder.\n\r\rTekster\rHvordan editere og formatere tekster, bruke variabler og legge til hjelpetekster.\n\r\rPDF\rHvordan konfigurere generering av PDF.\n\r\rWidgets\rHvordan bruke sammensatte komponenter (widgets).\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/",
	"title": "Design og planlegging",
	"tags": [],
	"description": "For at tjenesten din skal bli best mulig for de som skal bruke den, er det viktig å starte med å fokusere på brukerne og forstå deres brukerbehov i møte med tjenesten din.",
	"content": "Før du begynner utviklingen av tjenesten/applikasjonen din, anbefaler vi å gjennomføre en innsiktsfase, lage en prototype og utføre en brukertest.\n\rInnsiktsfase\rFørst av alt bør du samle prosjektgruppen og starte med å definere problemet. Hva er det dere skal løse og hvem skal det løses for?\n\r\rPrototype\rVed hjelp av Altinns Prototype-kit kan du lage en klikkbar prototype for å definere flyt og innhold i din tjeneste.\n\r\rBrukertest\rDet er alltid lurt å brukerteste i flere faser av prosjektet. Gjennom brukertester måler du om det du lager treffer brukernes behov. Det er en god investering å gjøre dette tidlig i prosjektet, slik at du ikke bruker penger på å utvikle en løsning som ikke løser utfordringene.\n\r\rRetningslinjer\rVi ønsker å oppnå helhetlige og konsistente brukeropplevelser ved å bruke gjenkjennbare og godt testede komponenter. For å oppnå dette ut i tjenestene, ber vi deg om å benytte retningslinjene på disse sidene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/",
	"title": "Felter",
	"tags": [],
	"description": "Hvordan sette opp felter og gruppering.",
	"content": "\rGruppering av felter\rHvordan gruppere felter i skjema.\n\r\rInnstillinger for felt\rInnstillinger for tekster knyttet til et felt.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/button/",
	"title": "Knapp og lenke",
	"tags": [],
	"description": "Hovedknapp (blå) brukes for å sende brukeren til neste steg.",
	"content": "Retningslinjer:  Det skal kun være en hovedknapp per side. Sekundærvalg kan legges til som knapper stylet som lenker. Teksten på knappen skal være tydelig. Som regel fungerer \u0026ldquo;Neste\u0026rdquo; bra, men knappen kan også formuleres som svar på et spørsmål (se eksempel under). På siste steg i skjemaet (innsending) skal hovedknappen være grønn.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/tracks/",
	"title": "Sporvalg",
	"tags": [],
	"description": "Hvordan legge til dynamisk sporvalg i app",
	"content": "Dynamisk sporvalg i en applikasjon kan være nyttig dersom man ønsker å vise og/eller skjule enkelte sider basert input fra sluttbruker på forutgående deler av skjemaet.\nTrigge kalkulering av sporvalg fra frontend Appen vil gjøre et initielt kall for å kalkulere rekkefølgen ved innlasting. For å trigge kalkuleringingen av sporvalg på sidebytte må man legge inn dette som en trigger på den aktuelle navigasjons-komponenten man ønsker. Dette gjøres ved å legge til calculatePageOrder som en del av triggers. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;navigation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;Neste\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;Tilbake\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;calculatePageOrder\u0026#34;], \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;showBackButton\u0026#34;: true } Her vil frontend da gjøre kallet mot apiet definert i appen og benytte listen som returneres til å avgjøre hvilke side den går til i det brukeren trykker neste. Denne rekkefølgen blir også lagret i staten frontend slik at navigering vil fungere både frem og tilbake på den gitte rekkefølgen man returnerer fra backend.\nOm man ønsker å trigge kalkulering på hvert eneste sidebytte kan dette gjøres ved å enten legge inn calculatePageOrder som en del av triggers for alle navigasjonskomponentene man har i applikasjonen, eller legge til en trigger i Settings.json under pages-seksjonen. Eksempel:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [ \u0026#34;Side1\u0026#34;, \u0026#34;Side2\u0026#34;, \u0026#34;Side3\u0026#34; ], \u0026#34;triggers\u0026#34;: [\u0026#34;calculatePageOrder\u0026#34;] } } Om triggers er satt på navigasjonskomponenten vil denne overstyre triggers som settes i Settings.json, på denne måten er det mulig å styre default-oppførsel på komponentnivå om ønskelig.\nSette opp sporvalg backend I App.cs må man overstyre metoden som henter ut den standardrekkefølgen av sider som er definert i Settings.json Dette gjøres ved å legge til funksjonen nedenfor i App.cs. Forventet output fra denne metoden er en stortert liste som inneholder navnet på de relevante sidene i applikasjonen.\n/// \u0026lt;inheritdoc /\u0026gt; public override async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(string org, string app, int instanceOwnerId, Guid instanceGuid, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); // Implement your own logic here  return pageOrder; } Funksjonen får inn en rekke parametere som kan være nyttig dersom man skal benytte skjemadata eller annen informasjon om sluttbruker til å kalkulere sporvalget.\n layoutSetId Dersom appen din definerer flere layout set vil id på det gjeldende layout settet sendes inn. Dersom applikasjonen ikke har layout set vil denne strengen være tom. Basert på denne parameteren kan man hente ut standard siderekkefølge som er definert i applikasjonen:  List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResourcesService.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResourcesService.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } Dette forutsetter at servicen IAppResources gjøres tilgjengelig i App.cs. Da servicen allerede dependency injectes inn i klasen er det kun to steg som kreves.\n Opprett en privat variabel i staten av klassen.  private readonly IAppResources _appResourcesService; Definer den nye private variabelen lik servicen som sendes med i konstruktøren til App.cs  _appResourcesService = appResourcesService;   CurrentPage Siden man ønsker å navigere fra vil være spesifisert i denne parameteren.\n  FormData inneholder skjemadataen. Den kan enkelt jobbes med som et objekt ved å caste den til riktig type Skjema skjema = (Skjema)formData;. Her heter C# modellen til skjemadataen Skjema for din applikasjon kan det være et annet navn. Dette kan du sjekke ved å finne klassenavnet på C# filen i App/models-mappen.\n  Reflektere sporvalg i kvittering (PDF) Som applikasjonsutvikler må man selv sørge for å reflektere de sporvalgene som gjøres i PDFen som opprettes i slutten av hver task. I App.cs finnes funksjonen FormatPdf:\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } Som input til metoden får man layoutSettings som inneholder default siderekkefølge under propertyen layoutSettings.Pages.Order. I tillegg får man skjemadataen som er knyttet til steget som skal avsluttes. Denne kan parses til en C# modell som beskrevet lengere oppe på denne siden.\nVed å manipulere layoutSettings.Pages.Order i denne metoden vil man kunne duplisere de sporvalgene som er gjort for sluttbruker. MERK! Kallet til PDF handler, vist nedenfor, må ikke fjernes fra FormatPDF metoden dersom du har implementert ytterlig logikk for kvitteringen i PDFHandler.cs.\nreturn await _pdfHandler.FormatPdf(layoutSettings, data); For å unngå å duplisere logikk vil vi anbefale å lage en privat metode som manipulerer siderekkefølgen basert på skjemadata og kalle denne både fra FormatPdfog GetPageOrder. Et kodeeksempel på en slik implementasjon følger.\npublic override async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(string org, string app, int instanceOwnerId, Guid instanceGuid, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResourcesService.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResourcesService.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } UpdatePageOrder(pageOrder, (FavorittArtist)formData); return pageOrder; } public override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { UpdatePageOrder(layoutSettings.Pages.Order, (FavorittArtist)data); return await _pdfHandler.FormatPdf(layoutSettings, data); } private void UpdatePageOrder(List\u0026lt;string\u0026gt; pageOrder, FavorittArtist formdata) { if (formdata.EnGodNrTo.Contains(\u0026#34;Tix\u0026#34;)) { pageOrder.Remove(\u0026#34;Prince\u0026#34;); } else { pageOrder.Remove(\u0026#34;Tix\u0026#34;); } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/tone-of-voice/",
	"title": "Språk",
	"tags": [],
	"description": "Retningslinjene skal sørge for at vi får et ensrettet språk og forståelig innhold i tjenestene som lages i Altinn.",
	"content": "Som hovedregel bør du bruke retningslinjene fra Språkrådet når du skriver. I tillegg har vi definert noen mer spesifikke regler for Altinn som vi anbefaler at du følger.\nVi oppfordrer til at du skriver innholdet i tjenestene dine på både bokmål, nynorsk og engelsk.\nGenerelle anbefalinger  Bruk et muntlig og lett språk Skriv direkte til brukeren (bruk «du») Forklar hva som er neste steg Skriv kort, klart og klikkbart Skriv tekster som kan skummes Vær spesifikk om innholdet, men sørg samtidig for å bruke ord som alle kan forstå  Unngå:  lange ord lange setninger kryptiske eller lyriske overskrifter flere poenger i samme setning flere poenger i samme avsnitt VERSALER (store bokstaver)  Lengde på tekst:  overskrifter: maks. 8 ord setninger: 15-20 ord avsnitt: 40-80 ord  Skriv rett frem Formelt språk er ofte skrudd sammen slik at utsagnet (verbet) kommer sent i setningen. Det gjør at man må lese mange ord før man får verbet. Det krever mer av leseren som må huske hva som stod tidlig i setningen. Verbet bør stå så tidlig som mulig i setningen og bør stå så nært subjektet som mulig.\nEksempel:\nArbeidstaker har en del plikter som må oppfylles →\nArbeidstaker må oppfylle en del plikter\nUnngå verbalsubstantiver Verbalsubstantiver gjør teksten unødvendig tung å lese. Et verbalsubstantiv er et substantiv dannet av et verb, for eksempel at «å utrede» blir til «å foreta en utredning», der utredning er selve verbalsubstantivet. De fleste verbalsubstantiv slutter på «-ing» og «-else».\nEn tekst med mange verbalsubstantiver blir abstrakt fordi den fjerner seg fra de konkrete handlingene den egentlig beskriver. Teksten blir mer konkret når vi bruker verbene i stedet.\nEksempler:\n Ved avtaleinngåelsen → Da avtalen ble inngått Ny henvendelse → Kontakt oss Innmelding av feil → Meld inn feil  Skriv aktivt, ikke passivt: I lovspråk blir det ofte skrevet at noe skal gjøres og det er ikke ønskelig å si noe om hvem som skal gjøre det. I Altinn sine løsninger vil det gjerne være flere enn en person som skal gjøre noe, men vi kan skrive direkte til brukeren likevel.\nEksempel:\nForberedelser og planleggingsaktiviteter må gjennomføres før utviklingen av tjenesten(e) kan og bør starte →\nGjør forberedelser og planlegg godt før du utvikler tjenesten.\nOppdeling av tall Riktig og konsekvent oppdeling av tallene hjelper brukeren å lese og skille forskjellige typer nummer. Ingen av nummerne skal skilles med punktum, kun mellomrom. I felt hvor brukeren skal skrive inn lengre nummer er det hjelpsomt å indikere antall siffer.\n Organisasjonsnummer deles opp i tre og tre: 123 456 789 Bankkonto deles opp i fire, to og fem: 1234 56 78901 Personnummer deles opp i seks og fem: 123456 78901 Mobilnummer deles opp i tre, to og tre: 987 65 432 Fasttelefon og faks deles opp i to og to: 98 76 54 32  Tid og dato  Klokkeslett skriver vi kun med timer og minutter, aldri sekunder. Klokkeslett skrives slik: 13:45 Dato skal som hovedregel skrives slik: 05.06.2017 Unntaksvis kan datoer skrives slik i løpende tekst: 5. juni 2017  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/",
	"title": "Community",
	"tags": [],
	"description": "Vi bygger Altinn i lag med mange andre, helt åpent.",
	"content": "\r\rOm Altinn 3\rAltinn 3 er tredje generasjon plattform for å utvikle og kjøre digitale tjenester.\n\r\rBidra til utviklingen av Altinn\rSamarbeid, del og lær. Alt vi gjør er åpen kildekode på GitHub. Vi setter stor pris på dine kommentarer og bidrag!\n\r\rEndringslogg\rOversikt over endringer introdusert i Altinn 3.\n\r\rRoadmap for Altinn\rHøynivå roadmap og funksjonell beskrivelse for Altinn.\n\r\rDevOps\rHvordan vi gjør DevOps\n\r\rPresentasjoner og Altinn kaffe\rThe Altinn-kaffe meeting series is a low threshold meeting series, where app owners (and potential app owners) can learn more about what we\u0026#39;re doing in Altinn 3. It\u0026#39;s also designed to gather information on how Altinn can help app owners realise their Altinn 3 potential. Slides mainly in Norwegian.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/",
	"title": "Endringslogg",
	"tags": [],
	"description": "Oversikt over endringer introdusert i Altinn 3.",
	"content": "\rEndringslogg for app frontend\rOversikt over endringer introdusert i app frontend.\n\r\rEndringslogg for app nuget pakker\rOversikt over endringer introdusert i App Nuget-pakker.\n\r\rEndringslogg for deployment\rOversikt over endringer introdusert i helm-chart for deployment.\n\r\rStorage Interface endringslogg\rOversikt over endringer introdusert i Altinn.Platform.Storage.Interface NuGet package.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/propose-component/",
	"title": "Foreslå en ny komponent",
	"tags": [],
	"description": "Om dere har behov for en komponent eller funksjonalitet som vi ikke tilbyr ønsker vi at behovet blir meldt som en feature request før utviklingen starter.",
	"content": "Opprett en Feature request in github.\nBeskriv komponenten, forklar hvorfor den vil være nyttig og i hvilken sammenheng den trengs. Review av forslag\nAltinn går gjennom forslaget for å kontrollere at en eventuell ny komponent oppfyller visse kriterier. Etter gjennomgangen vil Altinn gi deg beskjed om beslutningen og anbefalingene. Planlegg utviklingen\nEt medlem av teamet vil kontakte deg for å finne ut i samarbeid hvem som skal fortsette utviklingen.  Kriterier Når et nytt forslag tas inn til vurdering ser vi først og fremst på hva som faktisk er behovet og hva komponenten skal løse. Er det en ny komponent som trengs eller har vi eksisterende funksjonalitet som kan endres eller utvides?\nDersom løsningen er en ny komponent, ønsker vi å sikre best mulig kvalitet på denne ved å imøtekomme følgende kriterier:\n Brukbar - Forslaget skal tilfredsstille brukernes behov, være forståelig, gjenkjennelig og forhindre at det oppstår problemer. Tilgjengelig - Forslaget skal følge standarden i WCAG 2.1. Konsekvent - Forslaget skal gjenbruke eksisterende stiler og komponenter i designsystemet der det er relevant. Brukere skal ikke trenge å lure på om forskjellige ord, situasjoner eller handlinger betyr det samme. Allsidig - En ny komponent bør utformes slik at den kan brukes i andre tilsvarende scenarioer og tjenester.  \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/input/",
	"title": "Input",
	"tags": [],
	"description": "Inputfelt brukes når brukeren skal føre inn tekst eller tall.",
	"content": "Vanlig inputfelt Retningslinjer:  Et inputfelt skal alltid ha en tilhørende label med forklarende tekst. Ta en vurdering på om ekstra beskrivelser og hjelpetekster må kobles til input elementet. To inputfelt kan plasseres ved siden av hverandre dersom de på et eller annet vis hører sammen. Se eksempel under. Deaktivert felt bør unngås. Dersom et felt ikke kan redigeres bør informasjonen heller presenteres i tekst.  Eksempel på bruk: \rBredde på inputfelt Bredden på inputfeltet burde reflektere det som forventes av input fra brukeren. Vi har laget tre standard størrelser som burde dekke de fleste scenarioer og som skal fungere på forskjellige skjermstørrelser. Les om hvordan du endrer størrelsen her\nLite input Brukes til for eksempel telefonnummer, postnummer og årstall\n\u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innergrid\u0026#34;: { \u0026#34;xs\u0026#34;:5, \u0026#34;sm\u0026#34;:3, \u0026#34;md\u0026#34;:2 } } Medium input Brukes til for eksempel kommune og land\n\u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innergrid\u0026#34;: { \u0026#34;xs\u0026#34;:8, \u0026#34;sm\u0026#34;:6, \u0026#34;md\u0026#34;:6 } } Stor input Brukes til for eksempel navn, e-post adresse og en URL\n\u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innergrid\u0026#34;: { \u0026#34;sm\u0026#34;:10 } }  Stort tekstfelt Stort tekstfelt benyttes når brukeren skal fylle inn en lengre beskrivelse. De samme retningslinjene som inputfelt gjelder.\nEksempel på bruk: \r Adresse For adresse finnes det et fast oppsett der postnr og poststed er sidestilt under datofeltet. Postfelt fylles ut automatisk basert på postnr-input.\nEksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/",
	"title": "Logikk",
	"tags": [],
	"description": "Hvordan legge til, endre og konfigurere applikasjonslogikk som validering, kalkulering, dynamikk m.m.",
	"content": "\rGenerelt\rOversikt over logikkfiler og hvordan de kan brukes.\n\r\rTjenester\rHvordan benytte enkelte bortgjemte tjenester og klienter i app template bibliotekene.\n\r\rDataprosessering\rHvordan legge til kalkuleringer og annen dataprosessering?\n\r\rDynamikk\rHvordan legge til dynamikk?\n\r\rInstansiering\rHvordan legge til logikk som skal kjøres ved instansiering?\n\r\rKalkuleringer\rHvordan legge til kalkuleringer?\n\r\rValidering\rHvordan legge til logikk for å validere skjemadata?\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/losningsforslag/",
	"title": "Løsningsforslag",
	"tags": ["apps", "training", "solution", "losningsforslag"],
	"description": "Løsningsforslag og forklaring på forståelsessjekker",
	"content": "Løsingsforslag - Applikasjonskode  Bolk 1 Bolk 2 Bolk 3 Bolk 4 Bolk 5 Bolk 6  Bolk 1 - Forståelsessjekk: Laste opp datamodell Hvilken data er det tjenesteeier ønsker å samle inn her? Datamodellen består av ett hovedelement: innflytter. Dette elementet består igjen av en del underobjekter som_Fornavn_, _Etternavn_, og _Mellomnavn_. I tillegg er det noen sammensatte elementer som _Adresse_,_Kontaktinformasjon_ og _Arbeidsinformasjon_.\nHvilken effekt har \u0026lt;minOccurs\u0026gt; i datamodellen? Du vil se at feltet har ulik verdi for Inflytter.Fornavn og Inflytter.Mellomnavn minOccurs_ sier noe om hvor mange ganger objektet minst må ære nevnt.\nminOccurs = 0 vil si at feltet ikke er påkrevd, minOccurs=1 vil si at man forventer at det dukker oppminumum én gang i modellen.\nHvilke andre egenskaper er satt på feltet Innflytter.Mellomnavn? nilable=true er definert på mellomnavn-feltet. Det vil si at det er tillatt med en nullverdi på mellomnavn.\nDet er blitt generert en .C#, .metadata.json og .schema.json fil i tillegg til .xsd filen som du lastet opp. Hva er sammenhengen mellom disse filene? De nevnte filene er alle generert ut ifra xsd-beskrivelsen av datamodellen. De beskriver alle dataen og datafeltenes egenskaper. Alle egenskaper er ikke overført i alle filene nødvendigvis, men summen av dem skal opprettholde det som er beskrevet i xsd-filen.\n C#-modellen benyttes av app backend til å deserialisere dataen og gjøre den tilgjengelig for prosessering og validering. .metadata.json benyttes i Altinn Studio for å enkelt kunne koble komponenter og dynamikk til datafeltene. .schema.json-filen benyttes av altinn-app-frontend for skjemavalidering på klientsiden.  Enkelte restriksjoner fra datamodellen overføres ikke til C#-filen, hvilke? Det er og lagt til nye egenskaper, hvilke?  minOccurs, maxOccurs er ikke overført til modellen. nillable er kun overført på enkelte typer som f.eks decimal. XmlElement.Order er innført som en dekorasjon på hver property.  Dette sørger for at rekkefølgen på elementene alltid vil bli den samme når dataen serialiseres til xml.    Bolk 1 - Forståelsessjekk: Sette opp komponenter Finner du igjen komponenten som er koblet til e-post-feltet? Det er flere måter å finne igjen et felt i FormLayout.json. Raskeste veien til mål er ofte å søke etter navnet på feltet som komponenten er koblet til. Dette finner du under dataModelBindigs.\nHvilken endring kreves i denne filen dersom e-post-feltet ikke lenger skal være påkrevd? For å gjøre et felt valgfritt kan man endre \u0026ldquo;required=true\u0026rdquo; til \u0026ldquo;required=false\u0026rdquo;\nVed å endre én linje i FormLayout.json er det mulig å endre komponenten knyttet til mellomnavn til et input felt for et langt svar. Hvilken endring kreves? Løsningen er å endre type-feltet fra Input til TextArea som vist nedenfor.\n{ \u0026#34;id\u0026#34;: \u0026#34;mellomnavn\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;innflytter.mellomnavn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Innflytter.Mellomnavn\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: false }, Bolk 1 - Forståelsessjekk: Redigere tekster Hvordan får du inn engelsk språkstøtte i applikasjonen? For alle nye repoer vil resources.nb.json autogenereresmappen config/texts. For å få støtte for engelsk i en applikasjon må file_resources.en.json_ opprettes. Merk at language popertyen øverst i filen må settes til **en**.\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [] } Hvis vi en dag skal støtte Ukrainsk, hvilken språkkode vil du da måtte annotere filen med? Ifølge listen over ISO 639-1 koder så er koden for ukrainsk uk.\nHvis en tekstnøkkel refert til i FormLayour.json ikke finnes i tekstressursene, hva vil vises da? Hvis nevnte tekstnøkkel ikke finnes i tekstressursfilen vil tekstnøkkelen vises i stedet.\nBolk 2 - Forståelsessjekk: Legge til infoside Hvilken fil i applikasjonsrepoet er det som må justeres på dersom du manuelt ønsker å endre siderekkefølgen på eksisterende sider? I App/ui/Settings.json ligger siderekkefølgen beskrevet.\nFor å justere på siderekkefølgen må listen beskrevet under pages.order endres til å representere ønsket siderekkefølge.\nHvis du ønsker å gi en side et annet navn, men ikke har Altinn Studio tilgjengelig, hvilke filer må oppdateres med det nye filnavnet?  Settings.json: endre navnet på siden under pages.order App/ui/layouts: endre filnavnet på siden som skal bytte navn  Hvordan oppnår du at teksten bryter dersom tekststrengen ikke er lang nok til å naturlig brytes? Alle tekstressurser støtter markdown og dermed html-notasjon, så ved å benytte \u0026lt;br/\u0026gt; vil man kunne tvinge tekstbrytning.\nBolk 2 - Forståelsessjekk: Alternativ arbeidsflyt Hvis en bruker går tilbake og endrer svaret sitt på infosiden, får den da opp datainnsamlingssidene? Hvis ikke. Hvilke endringer kan du gjøre for å støtte dette i din applikasjon? I App/logic/App.cs finnes metoden GetPageOrder. Denne kalles fra frontend når man forlater en komponent som har konfigurert \u0026quot;triggers\u0026quot;: [\u0026quot;calculatePageOrder\u0026quot;] i layout filen.\nSe over løsningsforslaget for bolken for hvordan dette gjøres. Filer av interesse er App/ui/layouts/info.json og App/logic/App.cs.\nDersom man har sporvalg på et senere tidspunkt i en arbeidsflyt og en sluttbruker endrer et valg. Hva skjer med skjemdataen man tidligere har fylt ut, dersom siden skjules for sluttbrukeren? Dersom du har denne typen logikk i en applikasjon der man kan fortsette til innsending for flere spor bør dataen på siden(e) som nå blir skjult for bruker nullstilles.\nBolk 2 - Forståelsessjekk: Preutfylling av personopplysninger Er det mulig å endre en prefillverdi når den først er satt? Ja, dersom man ikke gjør noen endringer vil en standardkomponent med prefilldata være redigerbar.\nHvordan kan man hindre at en prefillverdi endres av sluttbrukeren? Komponenten kan settes til readonly. Alternativt kan man kjøre valideringer av dataen serverside for å verifisere at dataen i feltet matcher dataen fra prefillkilden. Dette kan gjøres i prosesserings eller valideringslogikken til applikasjonen.\nIkke alle norske innbyggere har et personnr, noen får tildelt et D-nummer. Hvordan må koden din justeres for å ta hensyn til dette dersom alder skal baseres på et f-nr eller d-nr som sluttbruker selv taster inn? Et D-nummer er ellevesifret, som ordinære fødselsnummer, og består av en modifisert sekssifret fødselsdato og et femsifret personnummer. Fødselsdatoen modifiseres ved at det legges til 4 på det første sifferet: en person født 1. januar 1980 får dermed fødselsdato 410180, mens en som er født 31. januar 1980 får 710180.\rÉn måte å gå fra et vilkårlig f- eller d-nummer til en streng for fødselsdato på formatet dd-MM-yy er:\npublic static string GetDOB(string fOrDNumber){ List\u0026lt;string\u0026gt; firstCharsInDNumber = new(){\u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34; }; var fOrDNumberArray = fOrDNumber.ToCharArray(); char[] dobArray = new char[6]; Array.Copy(fOrDNumberArray, dobArray, 6); char firstChar = dobArray[0]; int firstInt = 0; if(firstCharsInDNumber.Contains(firstChar.ToString())) { firstInt = firstChar - 4; dobArray[0] = (char)firstInt; } string dobString = $\u0026#34;{dobArray[0]}{dobArray[1]}.{dobArray[2]}{dobArray[3]}.{dobArray[4]}{dobArray[5]}\u0026#34;; // verify that it is a valid date  DateTime.ParseExact(dobString, \u0026#34;dd.MM.yy\u0026#34;, CultureInfo.InvariantCulture); return dobString; } Bolk 3 - Forståelsessjekk: Deploye applikasjon Er det mulig å ha to versjoner av en applikasjon i TT02 samtidig? Nei, det er kun mulig å ha én versjon av applikasjonen ute i et miljø av gangen. Deployer man en annen versjon vil eksisterende versjon av applikasjonen overskrives.\nHva skjer hvis man deployer samme versjon av applikasjonen til miljøet en gang til? Da vil alle operasjoner i forbindelse med deploy kjøres igjen. Man lagrer ressurstekster og annen metadata i Altinn Platform, og deploy pipeline for å rulle ut applikasjonen i clusteret vil og kjøre.\nDet vil dog ikke bli spunnet opp nye poder i forbindelse med dette da det ikke er noen reelle endringer på tjenesten som kjører i miljøet.\nVil applikasjonen være tilgjengelig umiddelbart etter deploy? Ja, tjenesten vil være tilgjengelig umiddelbart etter deploy. Dersom status er grønn i Altinn Studio skal du kunne nå applikasjonen.\nEr det mulig å fjerne en applikasjon fra miljøet hvis den først er blitt deployet? Per mars 2022 er det ikke mulig for en tjenesteeier å selv fjerne en applikasjon fra et miljø når den først er deployet. Da må man kontakte support. Det vil i løpet av året bli tilgjengeliggjort funksjonalitet for at tjenesteeier selv kan gjøre denne operasjonen.\nBolk 4 - Forståelsesssjekk: Innsamling av arbeidsopplysninger Hva er forskjellen på statiske og dynamiske options? Statiske options er definert build time, og vil, som navnet tilsier, være statiske under hele sin levetid. Dynamiske options hentes ut runtime og kan dermed hente verdi basert på tiden på døgnet eller andre dynamiske verdier.\nHva vil være et bruksområde for sikrede dynamiske options? Options er by default åpent tilgjengelige og API\u0026rsquo;et vil være mulig å nå for personer som ikke er logget inn i appen. Det er heller ingen restriksjoner på roller eller annet. For enkelte caser så kan det tenkes at man ønsker å eksponere options som er sensitive. Her kommer sikrede dynamiske options til sin rett hvor man får automatisk verifisering at den som gjør kallet har Instance.Read rettigheter.\nBolk 4 - Forståelsesssjekk: Differensiert datagrunnlag for offentlig og privat sektor Om en option-liste er satt opp med en mapping mot datamodellen - hva skjer når det aktuell feltet endrer verdi? Om et felt i mappingen oppdateres så vil app-frontend gjøre et nytt kall for å hente ut options-listen. Dette muliggjør å dynamisk vise valg som er skreddersydd til brukerens tidligere utfylte data.\nHva skjer med valgt verdi på et felt som er koblet til en option-liste som hentes på nytt fra server siden? Om brukeren f.eks har valgt kommune fra en nedtrekksliste over kommuner som er satt opp med en mapping på Fylke, går tilbake og endrer feltet Fylke så vil det valgte svaret i kommune-listen bli fjernet.\nBolk 4 - Forståelsessjekk: Skreddersydd tilbud for IT-kompetanse Om du legger til en ny funksjon i RuleHandlerHelper - hvor kjøres disse funksjonene? Vil dynamikk fungere uten denne definert? Funksjoner definert i RuleHandlerHelper.js kjøres som støttefunksjoner når man kobler opp dynamikken i Altinn Studio. Dynamikk kan settes opp uten disse definert og vil fortsatt fungere om man har satt opp funksjonene i RuleHanlderObject.js og definisjonene ligger i RuleConfiguration.json.\nOm du legger til en ny funksjon i RuleHandlerObject - hvor kjøres disse funksjonene? Vil dynamikk fungere uten denne definert? Funksjoner definert i RuleHandlerObject.js er faktisk dynamikk som lastes av app-frontend runtime og kjøres som en del av applikasjonsflyten som treffer sluttbruker. Dynamikk vil ikke fungere uten denne definert.\nHva er sammenhengen mellom funksjoner definert i RuleHandlerObject og filen RuleConfiguration.json? RuleConfiguration.json er en konfigurasjon som forteller noe om hvilke felter den aktuelle regelen i RuleHandlerObject skal treffe og eventuell effekt funksjonen skal ha. En funksjon definert i RuleHandlerObject kan settes opp flere ganger i RuleConfiguration.json. Man kan nesten tenke på det som \u0026ldquo;instanser\u0026rdquo; av funksjonen.\nBolk 5 - Forståelsessjekk: Utvide prosess med et bekreftelsessteg Hvilke Altinn-spesifikke egenskaper er satt på hver prosesstask? altinn:tasktype er definert for hver task.\nHvilke begrensninger vil en ekstern BPMN editor ha når man skal redigere prosessbeskrivelsen til en Altinn App? Altinn-spesifikke egenskaper vil trolig ikke bli importert eller eksportert når man jobber med modellen.\nVil prosessflyten kunne gå begge veier? Fra utfylling til bekreftelse og fra bekreftelse til utfylling? SequenceFlow i bpmn-filen beskriver kun at flyten går én fei, fra utfylling og til bekreftelse. Flyten vil dermed ikke kunne gå begge veier.\nBolk 5 - Forståelsessjekk: Legge til autorisasjonsregler for bekreftelsessteget Hva vil skje når prosessflyten går videre til bekreftelse-steget uten at autoriasjonsreglene er blitt oppdatert? Applikasjonen vil vise \u0026ldquo;Ukjent feil\u0026rdquo; når brukeren trykker på send inn knappen.\nHva skjer dersom du ikke spesifiserer hvilke roller som har lov til å utføre en aksjon i en autorisasjonsregel? Da vil alle brukere, både med og uten roller, har tilattelse til å utføre confirm operasjonen for applikasjonen.\nBolk 5 - Forståelsessjekk: Validering av innsender Hvilken endring ville du foreslått for kunden for å kunne oppfylle dette kravet uten å legge inn egendefinerte valideringen på dette steget? Ved å heller endere policy til at kun rollen PRIV. som kun delegeres til en privatperson på vegne av en selv, har tilattelse til aksjonen confirm vil autorisasjonsreglene gjøre sjekken som nå er lagt inn som egen validering automatisk.\nBolk 6 - Forståelsessjekk: Repeterende grupper Hvilket felt i datamodellen er det som bestemmer om et element er repeterende? Feltet maxOccurs i xsd-modellen sier noe om et felt er repeterende. Om maxOccurs \u0026gt; 1 vil man i praksis se på dette elementet som en liste.\nHvor mange repetisjoner er tillatt for feltet TidligereBosteder? Det er tillatt 10 repetisjoner for TidligereBosteder.\nBolk 6 - Forståelsessjekk: Validering Når kjøres valideringer serverside? Valideringer på serversiden kjøres som standard kun i det brukeren velger å bevege seg videre fra et steg. Denne oppførselen kan overstyres, og det er mulig å trigge valideringer både på enkelte felter og f.eks ved sidebytte mellom ulike sider.\nHvorfor burde valideringer som legges til på klientsiden også dupliseres serverside? Klientside-valideringer bør anses som et hjelpemiddel for bedre bruksopplevelse og ikke som en garanti på at data leveres på riktig format. Ondsinnede kan komme seg forbi disse valideringene, og klientside-valideringer vil ikke bli kjørt om man f.eks benytter seg av api\u0026rsquo;ene direkte. Derfor bør valideringer som legges på frontend alltid gjenspeiles i logikken backend.\nBolk 6 - Forståelsessjekk: Dataprosessering Når blir Data processing kjørt? Data processing blir kjørt hver gang brukeren enten leser eller skriver data. Det vil si at hver gang brukeren endrer et gitt felt så vil logikken kjøres. Dette stller derfor krav til apputvikler at optimaliserer koden som kjøres og unngår tunge og komplekse operasjoner på hver kalkulering.\nHva skiller ProcessDataWrite og ProcessDataRead? ProcessDataWrite kjøres i det brukeren skriver data, altså når brukeren har fylt inn et felt eller oppdaterer en eksisterende verdi. ProcessDataRead kjøres i det brukeren leser data fra databasen, f.eks når man navigerer seg til en tidligere instans av applikasjonen og henter opp tildigere utfylt data.\nHva er forskjellen på DataProcessing og Calculations? Kjært barn har mange navn - også i dette tilfellet. DataProcessing og calculations er samme navn på samme konsept. I nugetpakkene før 4.7.0 gikk dette under navnet calculations eller kalkuleringer, mens dette nå omtales som DataProcessing.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/metadata/",
	"title": "App metadata",
	"tags": ["api", "translate-to-norwegian"],
	"description": "App API for å få metadata informasjon for appen.",
	"content": "Overview The endpoints documented here are all for accessing metadata on the app itself and the data types that are allowed in an instance of the app. Additional endpoints provides access to text resources.\nGet app metadata Endpoint for downloading a copy of the application metadata document.\nGET {basePath}/api/v1/applicationmetadata Get Application texts Get text resources for the application for a specific language code. If the requested language isn\u0026rsquo;t available, norsk bokmål (nb) will be returned as default. The langaugeCode URL path element should follow the ISO 639-1 standard\nGET {basePath}/api/v1/texts/{languageCode} Note that the texts are cached in Platform Storage for 60 minutes before being retrieved from the database again.\nGet model JSON schema Download the JSON schema for a specific model. The id parameter must have the name of a JSON Schema in the app. This is usually a generated name based on values in the original XSD uploaded on the app. E.g: Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\nGET {basePath}/api/jsonschema/{id} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/summary/",
	"title": "Oppsummeringsvisning",
	"tags": [],
	"description": "Hvordan sette opp visning av oppsummering av utfylt skjema.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\rMERK: PDF-genereringen har per nå ikke støtte for oppsummerings-komponenten. For at PDF-generering skal fungere må enten alle oppsummerings-komponentene, eller hele oppsummerings-siden(e) ekskluderes fra PDF. Dette gjøres i Settings.json-filen knyttet til layout-filene.\n\rOppsett Visning av oppsummering settes opp på samme måte som øvrige skjema-komponenter i et skjema. Man kan velge å ha oppsummeringen på en egen side, eller på samme side som andre skjema-komponenter.\nOppsummerings-komponenten er meget enkel, og refererer til komponent som skal oppsummeres, og siden denne ligger på. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;\u0026lt;komponent-id\u0026gt;\u0026#34;,  \u0026#34;pageRef\u0026#34;: \u0026#34;\u0026lt;side komponenten er definert på\u0026gt;\u0026#34; }, Komponenten viser oppsummering av data fra den spesifiserte komponenten. I tillegg får sluttbruker mulighet til å gå tilbake til den aktuelle komponenten/siden for å gjøre endringer.\nVisningen er litt forskjellig avhengig av hva slags skjemakomponent oppsummeringen refererer til.\nMerk: PDF-generering støtter ikke oppsummering side, så må den ekskluderes ved å endre layout/ui/Settings.json\n\u0026#34;pages\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [ \u0026#34;navn-til-oppsummering-side\u0026#34; ] } Enkel skjemakomponent Dette er skjemakomponenter som kun er knyttet til 1 felt i datamodellen. F.eks. Input, Dropdown, Checkbox/Radio, osv.\nOppsummeringen viser ledeteksten til skjemakomponenten, og tilknyttet data. Dersom det er en aktiv feilmelding knyttet til skjemakomponenten, vil dette også vises.\nAdressekomponent Denne komponenten har flere felter som inngår. Visningen er lik som for en enkel skjemakomponent, slik at feltene blir slått sammen til en enkel tekst.\nFilvedlegg Oppsummeringsvisningen for filvedlegg viser en liste over de vedleggene som er lastet opp for den aktuelle komponenten.\nRepeterende grupper Grupper i grupper Oppsummering støttes også for repeterende grupper inne i repeterende grupper. Vi støtter kun ett nivå av grupper i grupper. I dette tilfellet vises oppsummeringen av hvert innslag av gruppen på øverst nivå som en egen kategori, og gruppen på nederste nivå vises på samme måte som vanlige repeterende grupper. Kategorier Det er mulig å gruppere oppsummeringene i forskjellige kategorier, for å gjøre en ev. oppsummeringsside mer oversiktlig. Dette gjøres ved å bruke den eksisterende gruppe-komponenten, uten å sette den opp som en repeterende gruppe.\nFeltene i oppsummeringen vises da med en tittel, som settes i title-feltet for textResourceBindings for gruppe-komponenten. Se eksempel under.\n{ \u0026#34;id\u0026#34;: \u0026#34;personalia-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Personalia\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-1\u0026#34;, \u0026#34;summary-2\u0026#34;, \u0026#34;summary-3\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d566c79c-3e3e-445b-be25-a404508f6607\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;22a60bf0-d5b7-4b45-9ac9-c266b6ad3716\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d497737b-67b2-4e03-87a9-43f58579c938\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, Eksempel på oppsummeringsside Under er et eksempel på en oppsummeringsside, med oppsett i layout-filen. Da oppsummeringen settes opp i layout-filene på samme måte som andre komponenter, kan man også ha med andre skjemakomponenter som tekster ved behov.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layout.schema.v1.json\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;send-in-text\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;componentType\u0026#34;: 1, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;finish\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;personalia-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Personalia\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-1\u0026#34;, \u0026#34;summary-2\u0026#34;, \u0026#34;summary-3\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d566c79c-3e3e-445b-be25-a404508f6607\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;22a60bf0-d5b7-4b45-9ac9-c266b6ad3716\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d497737b-67b2-4e03-87a9-43f58579c938\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;drugs-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Rus- og dopingmidler\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-4\u0026#34;, \u0026#34;summary-5\u0026#34;, \u0026#34;summary-6\u0026#34;, \u0026#34;summary-7\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;064c0033-8996-4825-85fc-2a19fe654400\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-5\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;7f22e523-3f6d-4371-a5dd-233dc41af824\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-6\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;18a7c709-ae2f-48b3-b6f6-bd631f5d8d56\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-7\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;b7417cf9-f806-4835-a3d1-424c8d094d5f\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-group-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;arbeidserfaring-group\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;work\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-8\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;25f720db-5784-4c95-a530-43f0bf523466\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;attachment\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;312afa87-c2a9-4ef1-a681-26cc47462878\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/",
	"title": "Retningslinjer",
	"tags": [],
	"description": "Vi ønsker å oppnå helhetlige og konsistente brukeropplevelser ved å bruke gjenkjennbare og godt testede komponenter. For å oppnå dette ut i tjenestene, ber vi deg om å benytte retningslinjene på disse sidene.",
	"content": "Altinn har som mål å gjøre det enklere for innbyggere og næringsliv å være i kontakt med det offentlige uavhengig av digital kompetanse. Felles retningslinjer for design hjelper oss å skape konsistens på tvers av tjenester som lages i Altinn Studio.\n\rDesignprinsipper\rNår vi utvikler nye eller forbedrer eksisterende produkter følger vi et sett med prinsipper for å kunne sikre oss at vi leverer brukervennlige løsninger til alle. Vi anbefaler å følge disse prinsippene når du jobber med utvikling av nye tjenester.\n\r\rInngang til skjema\rFor å gjøre opplevelsen til brukeren best mulig bør du tenke over hvordan du lenker til Altinn-appen fra din etat.\n\r\rInnhold i skjema\rForklar brukeren hva som skal til for å fylle ut skjemaet riktig og fordel innholdet i flere steg.\n\r\rKonsistens på tvers av tjenester\rFor å være lett å bruke og unngå forvirring, bør samme interaksjonsmønstre følges på tvers av tjenester.\n\r\rUI-komponenter\rDe ulike komponentene er laget for at de skal passe sammen i en større helhet. Det er derfor viktig å følge retningslinjene for hvordan disse brukes for å oppnå et konsistent og gjenkjennbart uttrykk. UI-komponenter som foreløpig inngår i Altinns bibliotek finner du her.\n\r\rSpråk\rRetningslinjene skal sørge for at vi får et ensrettet språk og forståelig innhold i tjenestene som lages i Altinn.\n\r\rTilgjengelighet\rGod tilgjengelighet hjelper mennesker med funksjonshemninger å oppfatte innholdet vårt på en meningsfull måte. Ved å bruke Altinn 3 får du mye på kjøpet, men noen ting må du fortsatt huske på selv.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/styling/",
	"title": "Styling",
	"tags": [],
	"description": "Hvordan styre styling, formatering og grid-layout for en app.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\nMERK: for å benytte denne funksjonaliteten må man ha app-frontend versjon 3. Se denne lenken om endringer som må til i appen.\n\rSidestilte komponenter (grid) Det er mulig å sidestille komponenter i skjema. Denne funksjonaliteten baserer seg på grid systemet til Material-UI, og vil også være kjent om man er kjent med grid-systemet til boostrap. Grid systemet baserer seg på en oppbygning av containere i 12 deler, hvor man så kan tildele barn (items) av en grid-container en gitt andel av denne bredden. Material-UI tilbyr også muligheten til å dynamisk endre hvor stor andel av skjermen man ønsker å oppta basert på hvilken skjermstørrelse sluttbrukeren har. Følgende størrelser med tilhørende breakpoints er definert:\n xs: 0px sm: 600px md: 1024px lg: 1440px xl: 1920px  For å sidestille komponenter horisontalt må man gjøre noen små endringer i formlayout. Det er definert en egen property grid som man kan fylle inn bredde ønsket på de ulik størrelsene. Her er et eksempel hvor to input-felt har blitt satt til å ta halve skjermen (enkelte props er fjernet for lesbarhet):\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 6, } }, { \u0026#34;id\u0026#34;: \u0026#34;input-felt-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 6 } } } I komponentene over er størrelsen satt til 6 (altså halv bredde) for størrelse xs. Siden xs er den minste størrelsen tilgjengelig vil dette gjelde fra størrelse xs og opp, altså fra xs til xl. Oppsettet over vil gi følgende resultat:\nSiden man har 12 inndelinger tilgjengelig i sidebredden er det opp til apputvikler å tildele hvor stor andel komponenten skal ha. Om man ønsker at en komponent skal ta 2/12, en annen 6/12 og siste 4/12 så er det mulig. Det er viktig å tenke på brukeropplevelsen når man gjør slike endringer, og sidestilling av komponenter bør gjøres med omhu. Komponenter med lengre tekster og beskrivelser blir også fort små og uoversiktelige om disse sidestilles. Skal det benyttes lengre tekster og beskrivelser anbefales det at disse benytter full bredde av skjema.\nOm man i eksempelet over hadde ønsket at komponentene skulle ta hele bredden frem til skjermen ble større enn 960px så kunne man satt opp følgende layout:\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;sm\u0026#34;: 12, \u0026#34;md\u0026#34;: 6 } }, { \u0026#34;id\u0026#34;: \u0026#34;input-felt-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;sm\u0026#34;: 12, \u0026#34;md\u0026#34;: 6 } } } Da ville komponentene først legge seg sidestilt i det sluttbruker faktisk sitter på en skjerm som oppfyller kravet stilt.\ninnerGrid og labelGrid Utover det å sette bredde på grid i komponenten har vi også lagt til mulighet til å styre innerGrid og labelGrid. Dette gir deg mulighet til å påvirke på samme måte hvor stor bredde label og input skal ta. Dette brukes typisk når du vil gjøre input feltet mindre (for å gi en visuell markering av at det forventes kort svar), eller hvis du ønsker å vise label og input på samme linje (som i en tabell).\nDu kan tenke på komponenten på denne måten:\n\u0026lt;Grid id=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;Grid id=\u0026#34;labelGrid\u0026#34;\u0026gt; Komponentens tekster \u0026lt;/Grid\u0026gt; \u0026lt;Grid id=\u0026#34;innerGrid\u0026#34;\u0026gt; Komponentens input \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; Her vil det da være mulig å styre bredden til både ytterste grid og den innerste griden. Eksempel:\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innerGrid\u0026#34;: { \u0026#34;xs\u0026#34;: 6 } } } } Her har man satt at komponent griden skal ta hele bredden, mens man begrenser komponentens input til å kun ta halve bredden. InnerGrid vil kunne styres for komponentene:\n Kort svar (Input) Langt svar (TextArea) Filopplaster (FileUpload) Nedtrekksliste (Dropdown) Datovelger (Datepicker)  Eksempelet over vil gi følgende output:\nEn tabellvisning med sidestilt label vil komme frem hvis du setter labelGrid og innerGrid slik at summen blir 12 (eller mindre). Dette kan være lurt hvis du har en lang liste med relaterte spørsmål. Det er ofte lurt å ikke bruke et slikt layout på de minste skjermene, så bruk gjerne md\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;labelGrid\u0026#34;: { \u0026#34;md\u0026#34;: 8 }, \u0026#34;innerGrid\u0026#34;: { \u0026#34;md\u0026#34;: 4 } } } } Det vil se omtrent slik ut\nFormatering av tall Det er nå implementert støtte for å kunne spesifisere formatering av tall i inputfelt. Dette gjøres ved å legge til en property formatting på Input-komponenten. Formateringsmuligheter er dokumentert i et JSON-schema, og vil dukke opp automatisk i intellisense når man redigerer komponenten i f.eks. VSCode.\nEksempelet under vil resultere i et inputfelt for tall, hvor tallet vil bli formatert med , mellom hver tusen, og $ foran tallet.\nFormateringen er kun for visning i frontend, og tallene som legges inn i et inputfelt med formatering vil lagres uformatert.\r\r{ \u0026#34;id\u0026#34;: \u0026#34;numberComponent\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;number\u0026#34;, }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;someNumberField\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: false, \u0026#34;formatting\u0026#34;: { \u0026#34;number\u0026#34;: { \u0026#34;thousandSeparator\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;$\u0026#34; }  } }, Justering av tekst i input felter Når skjemaet inneholder en liste med tall som summeres er det vanlig å justere teksten i input feltet til høyre slik som når man summerer på papir og slik det vises i Excel. Dette kan gjøres ved å sette \u0026quot;align\u0026quot;: \u0026quot;right\u0026quot; under formatting på input componenten. Andre gyldige verdier er \u0026quot;center\u0026quot; og \u0026quot;left\u0026quot;.\n{ \u0026#34;id\u0026#34;: \u0026#34;numberComponent\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;formatting\u0026#34;: { \u0026#34;number\u0026#34;: { \u0026#34;thousandSeparator\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;kr \u0026#34; }, \u0026#34;align\u0026#34;:\u0026#34;right\u0026#34;  } }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/wcag/",
	"title": "Tilgjengelighet",
	"tags": [],
	"description": "God tilgjengelighet hjelper mennesker med funksjonshemninger å oppfatte innholdet vårt på en meningsfull måte. Ved å bruke Altinn 3 får du mye på kjøpet, men noen ting må du fortsatt huske på selv.",
	"content": "Forskrift om universell utforming av IKT-løsninger stiller krav om at nettsider må oppfylle 35 av 61 suksesskriterier i standarden Retningslinjer for tilgjengelig webinnhold (WCAG) 2.0. Sjekk ut minimumskravene på UU-tilsynet som er omfattet av forskriften.\nSjekkliste  Innholdsstruktur Sjekk at du har en logisk struktur på overskrifter (H1 - H4), og at du ikke har noen tomme overskriftselementer. Det er fort gjort å glemme et nivå. For å oppdage feil i innholdstrukturen kan det være nyttig å benytte “Wave” som er et utvidelsesverktøy til chrome. Last ned Wave til Chrome, installer og ikonet vil dukke opp øverst til høyre i nettleseren.    Forklarende tekster og hjelpetekst Sjekk at lenker, label og knapper har forklarende tekster. Ta en vurdering på om ekstra beskrivelser og hjelpetekster må kobles til input elementet.\n  Knapp vs lenke Det er viktig at man er bevisst på om det blir brukt knapper eller lenker, da skjermlesere kan få problemer med å tolke funksjonaliteten.\n  Feilmeldinger Du er selv ansvarlig for at korrekte feilmeldinger blir lagt inn på hvert av skjemafeltene.\n  NB: Skal du lage tjenester i egen løsning, der Altinns grensesnitt er usynlig for brukeren, må du selv huske på å ta hensyn til øvrige WCAG-krav.\n\r\rHvordan teste Det er viktig at dere tester at tjenesten deres er tilgjengelig for alle. Dette vil ikke bare hjelpe deres tjeneste, men det kan også belyse feil som har oppstått eller blitt oversett hos oss. Her er noen verktøy som kan brukes til å gjøre enkle tester.\nTastaturnavigasjon Sjekk at alle knapper og inputfelter kan nåes ved tastaturnavigasjon.\nSkjermleser Gå gjennom flyten med en skjermleser som hjelpemiddel. Her kan du forsikre deg om at alt blir lest opp riktig og at tekstene er beskrivende nok.\n  Mac: VoiceOver er forhåndsinstallert på Apples mobiler og PCer. VoiceOver Brukerveiledning\n  Windows: NVDA Screenreader er et gratis skjermleser verktøy laget av NV Access Om NVDA Screenreader\n  Kontrast Følgende fargekombinasjoner som er brukt på Altinn oppfyller kravene til kontrast i liten tekst. AA er minstekravet, mens AAA er anbefalt, særlig for løpende tekst.\n\rAA\rAAA\rAAA\r\rAA\rAA\r\rAAA\r\rAA\rAAA\rAAA\r\rAAA\r\rAA\r\rAA\rAAA\r\rAA\rAA\rAAA\rAAA\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/services/",
	"title": "Tjenester",
	"tags": [],
	"description": "Hvordan benytte enkelte bortgjemte tjenester og klienter i app template bibliotekene.",
	"content": "Personoppslag Tjenesten for personoppslag kan brukes til å verifisere et personnummer og til å hente informasjon om den identifiserte personen. Brukeren vil måtte oppgi både et personnummer og etternavnet til personen. Tjenesten vil da gjøre et oppslag på personnummeret og sjekke at etternavnet stemmer. Begge verdiene er obligatoriske og etternavnet brukes til å forhindre vasking av personnummer. Hvis brukeren oppgir feil informasjon for mange ganger vil brukeren bli sperret fra å gjøre flere oppslag i en liten periode.\nDe returnete persondataene kan brukes til å fylle ut andre felter i datamodellen.\nPersonoppslag eksempel Tjenesten kan benyttes fra alle \u0026ldquo;handlers\u0026rdquo; i logikk klassene i en app. Nedenfor har vi laget et eksempel som gjør oppslag i ProcessDataWrite metoden i DataProcessingHandler.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite( Instance instance, Guid? dataId, object data) { if (data is MessageV1 message) { Person person = await _personLookup.GetPerson( message.Personnummer, message.Etternavn, CancellationToken.None); message.Fornavn = person.FirstName; return true; } return false; } For at dette skal fungere må vi gjøre et par andre endringer i DataProcessingHandler.\nLegg til et privat felt _personLookup for tjenesten og oppdater klassens konstruktør til å ta inn en instanse av tjenesten som input. Set det private feltet i konstruktøren.\nprivate readonly IPersonLookup _personLookup; public DataProcessingHandler(IPersonLookup personLookup) { _personLookup = personLookup; } Endringene i DataProcessingHandler konstruktøren medfører at man også må gjøre endringer i konstruktøren til App klassen. Legg til IPersonLookup som input parameter og bruk verdien som input i konstruktøren til DataProcessingHandler.\npublic App( ... IText textService, IPersonLookup personLookup,  IHttpContextAccessor httpContextAccessor) : base(...) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); _dataProcessingHandler = new DataProcessingHandler(personLookup);  _instantiationHandler = new InstantiationHandler(profileService, registerService); _pdfHandler = new PdfHandler(); } Håndtering av feil Uten flere endringer enn de som er beskrevet over, vil app backend begynne å svare med statuskode 429 - TooManyRequests hvis brukeren har oppgitt feil data for mange ganger. Denne statuskoden er for øyeblikket ikke håndtert av frontend delen av app koden. Dette vil i utganspunktet resultere i \u0026ldquo;ukjent feil\u0026rdquo; som kan unngås ved å legge inn håndtering av exceptions. Det kan legges inn kode som fanger opp PlatformHttpException med en response med statuskode 429, men det er i dag ingen god innebygget mekanisme som kan brukes til å informere brukeren om hvorfor noe gikk galt. Det man eventuelt kan gjøre er å benytte et felt i datamodellen.\ntry { ... return true; } catch (PlatformHttpException phex) { switch (phex.Response.StatusCode) { case HttpStatusCode.TooManyRequests: // Add corrective messures  break; case HttpStatusCode.NotFound: // Add corrective messures  break; } throw; } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/images/",
	"title": "Bilder",
	"tags": [],
	"description": "Hvordan legge til og endre referanser til bilder.",
	"content": "MERK: bildekomponenten er enda ikke støttet i PDF-genereringen og vil derfor bli ignorert i PDF-visningen.\n\rLegge til bilder i applikasjonen Å legge til bilder gjøres i FormLayout.json ved bruk av bildekomponenten. Alternativ tekst for bildet er nyttig for situasjoner hvor bildet ikke kan lastes, eller for brukere som benytter skjermleser. Dette kan legges til som en tekst ressurs som er definert i resource.[språk].json.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;altTextImg\u0026#34;: \u0026#34;imgAltText\u0026#34; }, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;https://example.com/image_nb.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;center\u0026#34; } } ] } } Bildet kan også ha ulik kilde i forskjellige språk. Standardkilde er nb, og denne brukes for språk som ikke har oppgitt en egen kilde for bilder. Eksempel med forskjellig kilde for nb og en:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;altTextImg\u0026#34;: \u0026#34;imgAltText\u0026#34; }, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;https://example.com/image_nb.png\u0026#34;, \u0026#34;en\u0026#34;: \u0026#34;https://example.com/image_en.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;center\u0026#34; } } ] } } Hosting av bilder fra app Dersom bildet skal lastes fra appen, må man sette opp statisk hosting av filer i applikasjonen. Dette er automatisk satt opp for applikasjoner laget etter desember 2021. For eldre applikasjoner, følg beskrivelsen nedenfor. Dette konfigureres i App/Startup.cs, i Configure metoden. Dette vil så hoste alle filer som ligger i /app/wwwroot mappen. Om denne mappen ikke finnes må den opprettes. Ønsker du å referer til filen app/wwwroot/bilde_nb.png så vil denne kunne nås med følgende path: /org/app-name/bilde_nb.png\napplicationId er en variabel deklarert noen linjer opp og inneholder org/app-name fra applicationmetadata.json:\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // ...  app.UseRouting(); app.UseStaticFiles(\u0026#39;/\u0026#39; + applicationId);  app.UseAuthentication(); // ...  } I FormLayout.json må referansen til bildet være en relativ url som starter med /org/app-name som ble satt opp i static hosting. Du kan også bruke snarveien wwwroot (uten / først), som blir erstattet med /org/app-name før bildet lastes.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;altTextImg\u0026#34;: \u0026#34;imgAltText\u0026#34; }, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;wwwroot/bilde_nb.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;center\u0026#34; } } ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/date/",
	"title": "Dato",
	"tags": [],
	"description": "Datovelger benyttes i forbindelse med planlegging eller for datoer i nærliggende tid. For datoer lengre tilbake i tid brukes datofelt.",
	"content": "Datovelger I forbindelse med planlegging, eller for datoer i nærliggende tid kan du bruke datovelgeren.\nRetningslinjer:  Dersom du skal hente inn en fødselsdato eller andre datoer lengre tilbake i tid, er ikke datovelgeren et anbefalt alternativ, se studier fra gov.uk I disse tilfellene kan du heller bruke datofeltet. Legg til korrekt validering og gi brukeren informasjon om hva som er gyldige datoer å velge. Skal brukeren kunne velge datoer tilbake i tid? Innenfor en gitt periode?  Eksempel på bruk: \r Datofelt For datoer lengre tilbake i tid, eller datoer brukeren kjenner godt, bør datofelt benyttes. Tre tekstfelt er i disse tilfellene den enkleste måten for brukeren å fylle ut datoen. Dersom det er noe som skal planlegges eller tilfeller der en spesifikk dag er viktig, bruk datovelgeren i stedet.\n⚠️ Denne komponenten er ikke tilgjengelig i Altinn Studio enda.\n\r\rRetningslinjer:  Bruk alltid label på hver av de tre boksene (dag, måned, år), og ledetekst (legend) for hele input-gruppen. Om datagrunnlaget finnes, kan en spesifikk dato være foreslått i feltet. Ellers kan eksempelinnholdet være dagen i dag.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/",
	"title": "Endringslogg for deployment",
	"tags": [],
	"description": "Oversikt over endringer introdusert i helm-chart for deployment.",
	"content": "\rMigrering til versjonerte charts\rMigrering fra helm template filer til versjonert helm dependency.\n\r\rv1\rOversikt over endringer introdusert i v1 av deployment.\n\r\rv2\rOversikt over endringer introdusert i v2 av deployment.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/layout-sets/",
	"title": "Flere skjema i samme app (layout-sets)",
	"tags": [],
	"description": "Hvordan sette opp en app som inneholder flere ulike skjema.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\r\rOppsett For å få funksjonalitet for flere skjema i tjeneste, må nuget-versjon til pakkene app\u0026rsquo;en bruker oppgraderes til versjon 3.1.4 eller nyere. Se instrukser for hvordan det gjøres her.\nSentralt i løsningen er at man har flere layout-sets som består av en eller flere sider og configurasjon. Hvert layout-set består av tilsvarende filer som en skjema tjenester.\n|- App/\r|- ui/\r| - layout-sets.json\r|- skjema-a/\r|- Settings.json\r|- RuleHandler.js\r|- RuleConfiguration.json\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json\r|- skjema-b/\r|- Settings.json\r|- RuleHandler.js\r|- RuleConfiguration.json\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json I layout-set.json defineres det hvilke steg i prosessen (task) hvor et gitt layout-set skal brukes. Merk at id\u0026rsquo;en er case sensitiv, så om du har stor bokstav i mappenavnet må id\u0026rsquo;en reflektere dette. Vi anbefaler små bokstaver i mappenavn.\nEksempel:\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;rf0002\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;schema_4222_160523_forms_212_20160523\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_1\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;superform\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;schema_3161_140411_forms_1549_11554\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_2\u0026#34; ] } ] } "
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/instance/",
	"title": "Instance",
	"tags": ["api", "translate-to-norwegian"],
	"description": "An instance is a metadata container that is used to track the status and progress of one interaction between an app user and owner.",
	"content": "Instance The Instance model is the main model of an instance. An instance can be regarded as an envelope or folder where data is collected and exchanged between the application user and owner. The instance document is a way for Altinn and external parties to track the state of one specific data exchange.\nProperties    Name Description     id A gobally unique id for the instance. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the internal unique id of the instance owner and the second part is a generated UUID value.   instanceOwner A complex type identifying the owner of the instance. See InstanceOwner   appId The id for the app the instance is associated with. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the short name/identifier of the owner of the app and the second part is the app name.   org The short name of the app owner.   selfLinks A complex type containing a set of named URLs. See ResourceLinks   dueBefore This can be use by app owner to indicate a deadline for when the instance must be completed and submitted by a user that can represent the instance owner.   visibleAfter This can be used by app owner to have an instance become visible for app users at a given date and time. This way an instance can be created in advance and populated with data before being available to an application user.   process A complex type tracking the process state of the instance. See ProcessState   status A complex type with more state data. See InstanceStatus   completeConfirmations A list of complete confirmations. See CompleteConfirmation   data A list of data elements. This include all forms, attachments and other data types being collected. See DataElement   presentationTexts A dictionary with text values extracted from forms that are saved on the instance. Values are extracted based on PresentationField values stored in the application metadata document. Also see PresentationField   dataValues A dictionary with data values extracted from forms that are saved on the instance. Values are extracted based on configured data fields in the applicationmetadata document. Also see DataField   created The date and time when the instance was first initialized.   createdBy An idenfificator indicating who it was that created the instance.   lastChanged The date and time when the instance was last changed.   lastChangedBy An idenfificator indicating who it was that made the last change to the instance.    InstanceOwner The InstanceOwner model is a simple definition whose only porpose is to hold a universally known identification value of the instance owner.\nProperties    Name Description     partyId A value used internally by Altinn to uniquely identify an entity across Organisations, Persons and Self identified users.   personNumber If the instance owner is a person this field is populated with a person number from the National Population Register in Norway.   organisationNumber If the instance owner is an organisation this field is populated with an organisation number from the National Unit Register in Norway.   username If the instance owner is a self identified user this field is populated with a user name.    InstanceStatus The InstanceStatus model is used to hold key status related metadata about an instance. All information is also tracked through instance events, but this is an easily accessible summary of the last events.\nProperties    Name Description     archived The date and time for when an archived instance was archived.   softDeleted The date and time for when a deleted instance were moved to the recycle bin.   hardDeleted The date and time for when an instance became unrecoverable through any API. A few days later the instance and all its data will be physically deleted from storage and truly unrecoverable.   readStatus A field indicating whether an application user has opened the instance at any time. Used internally by the message box to indicate read status of elements.   substatus A property with human readable status information that will be displayed by the message box.    CompleteConfirmation The CompleteConfirmation model is a simple type for holding information about who and when a given stakeholder has told Altinn that the instance is no longer needed. They have obtained all the information they needed from the instance. The instance can be deleted permanently should an application user decide to to so. At the time of writing an instance can have only one stakeholder and that is the Application Owner.\nDataValues Data values are values either extracted from the instance data or other sources. The values are stored with the instance for easy access and can be used for example in routing logic on the receiving end.\nWhile data fields configured in the app metadata file will be extracted and automatically picked up by the application, there is also the option of adding values manually by using the UpdataDataValues method from the IInstance interface. You can mix and match data fields from configuration and by manually adding. It\u0026rsquo;s the UpdateDataValues method that is called under the hood in both cases. UpdateDataValues merges the incoming collection with what\u0026rsquo;s allready stored. However if yo specify the same id it will be overwritten by one or the other and you have no guaranties on which is stored.\nValues passed in to the UpdataDataValues can have any source and is not restricted to data stored in the application. It can be called from any place but it\u0026rsquo;s recomended to not call it more than strictly required. A good place is to override the RunProcessTaskEnd method from AppBase causing the method to be called when a task is completed.\nProperties    Name Description     stakeholderId The short name of an application owner.   confirmedOn The date and time for when the application owner confirmed that they consider the instance as no longer needed in Altinn.    ProcessState The process state model keeps track of the process of a specific instance.\nProperties    Name Description     started Date and time for when the process was initially started.   startEvent The name of the start event triggering the beginning of the process.   currentTask A complex model keeping track of current process step. See ProcessElementInfo   ended Date and time for when the process was finished.   endEvent The name of the end event that the process ended with.    ProcessElementInfo The process element info holds information about the current task in the process.\nProperties    Name Description     flow A step counter that increase every time the process moves forward.   started Date and time for when the instance entered the current step.   elementId The unique id of current process task.   name The name of the task. (Human readable.)   altinnTaskType The type of task.   validated A date and time for when the instance was validated as well as a value indicating if the task can be completed without additional changes and a new validation.    ResourceLinks The resource link model is should have a collection of URLs that can be used to obtain a copy of the instance document through different API. The propose is to make it easy to switch between API. Primarily when the original was obtain from the storage instance query API and you need to use the app API to perform changes on the instance.\nProperties    Name Description     apps Contains a URL for the endpoint to use to obtain a copy of the current instance document through the app API.   platform Contains a URL for the endpoint to use to obtain a copy of the current instance document through the Platform Storage API.    Complete example This example was created by instantiating an app running locally on a development machine using LocalTest. The process is at first step, Task_1, and it has a single data element which is the main form of the app.\n{ \u0026#34;id\u0026#34;: \u0026#34;1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;instanceOwner\u0026#34;: { \u0026#34;partyId\u0026#34;: \u0026#34;1337\u0026#34;, \u0026#34;personNumber\u0026#34;: \u0026#34;01039012345\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null, \u0026#34;username\u0026#34;: null }, \u0026#34;appId\u0026#34;: \u0026#34;ttd/bli-applikasjonseier\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://altinn3local.no/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34; }, \u0026#34;dueBefore\u0026#34;: null, \u0026#34;visibleAfter\u0026#34;: null, \u0026#34;process\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2020-11-18T15:56:41.5662973Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2020-11-18T15:56:41.5664762Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Utfylling\u0026#34;, \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;ended\u0026#34;: null, \u0026#34;validated\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2020-11-20T13:00:05.1800273+00:00\u0026#34;, \u0026#34;canCompleteTask\u0026#34;: true } }, \u0026#34;ended\u0026#34;: null, \u0026#34;endEvent\u0026#34;: null }, \u0026#34;status\u0026#34;: null, \u0026#34;completeConfirmations\u0026#34;: null, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;filename\u0026#34;: null, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/bli-applikasjonseier/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://altinn3local.no/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34; }, \u0026#34;size\u0026#34;: 401, \u0026#34;locked\u0026#34;: false, \u0026#34;refs\u0026#34;: [], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;createdBy\u0026#34;: null, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: null } ], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:42.1972942Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;1337\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:42.1972942Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;1337\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/",
	"title": "Konfigurasjon",
	"tags": [],
	"description": "Konfigurering av ulike aspekter av en app.",
	"content": "\r\rMeldingsboks\rKonfigurasjon av presentasjon av applikasjonsinstanser i meldingsboksen i Altinn.\n\r\rAutorisasjon\rHvordan definere autorisasjonsregler (tilgangsstyring) for en app.\n\r\rAktørtyper\rHvordan sørge for at kun bestemte typer aktører kan bruke en app.\n\r\rDatafelter på instansobjektet\rKonfigurasjon av datafelter for app.\n\r\rDefinere applikasjonsprosess\rHvordan definere prosessen til en app.\n\r\rSecrets\rHow to deal with secrets and sensitive data in an app.\n\r\reFormidling\rHvordan konfigurere eFormidling integrasjon for en app.\n\r\rEvents\rHvordan lage egendefinerte events for en app.\n\r\rSettings og miljøvariabler\rHvordan legge inn konfigurasjon- og miljøspesifikke verdier slik at de er tilgjengelig fra app-koden.\n\r\rKonfigurer appens oppførsel under oppstart\rHvordan konfigurere applikasjonens oppførsel under oppstart av app-frontend\n\r\rStateless applikasjon (innsynstjeneste)\rHvordan legge inn konfigurasjon for å styre oppførsel ved applikasjonens oppstart\n\r\rDeployment\rKonfigurering av deploy og kjøretids oppsett\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/messagebox/",
	"title": "Meldingsboks",
	"tags": [],
	"description": "Konfigurasjon av presentasjon av applikasjonsinstanser i meldingsboksen i Altinn.",
	"content": "\r\rPresentasjonsfelter\rKonfigurasjon av presentasjonsfelter for app.\n\r\rSkjule instanser\rKonfiurasjon for å skjule instanser fra meldingsboksen.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/technology/",
	"title": "Teknologi",
	"tags": [],
	"description": "Systemdokumentasjon for Altinn Studio, Altinn Apps og Altinn Platform.",
	"content": "Dokumentasjon for teknologi er foreløpig kun tilgjengelig på engelsk.\n\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/texts/",
	"title": "Tekster",
	"tags": [],
	"description": "Hvordan editere og formatere tekster, bruke variabler og legge til hjelpetekster.",
	"content": "Tekster lagres i ressursfiler i katalogen App/config/texts. Tekster kan være fra felles biblioteker, datamodellen eller manuelt lagt inn av utvikler.\nTekstressursene er tilgjengelig når man redigerer UI komponenter i skjemaet via Altinn Studio, og de vises til sluttbruker når skjemaet lastes inn i nettleser.\nTekster lagres i JSON-format og det er én fil pr språk. Format på filnavn for tekster er resource.[språk].json f.eks: resource.nb.json.\nFormatering av tekster Alle tekster kan formateres med markdown. Nedenfor er de mest benyttede formateringene beskrevet.\nMer omfattende dokumentasjon og tips til hvordan markdown kan benyttes finnes her: Markdown Cheatsheet.\nUthevede tekster Det er ekstremt enkelt å gjøre ord eller setninger fet eller kursiv i markdown.\nDette er en _kursiv tekst_ laget med understrek. Dette er også en *kurvis tekst* laget med stjerne. Dette er __fet tekst__ laget med understrek. Dette er også **fet tekst**, men laget med stjerner! Lenker Trykk [her](https://altinn.no) for å komme til Altinn. Overskrifter # Dette er en stor heading (H1) ## Dette er en litt mindre heading (H2) ### Og enda litt mindre (H3) #### Bitteliten heading (H4) Legge til og endre tekster i en app Man har to alternativer når man skal endre tekster i en app, enten gjøres det via Altinn Studio eller direkte i repository.\nTeksteditor i Altinn Studio Designer I den øverste navigeringsmenyen i Altinn Studio, velg Språk for å kunne redigere tekster. En oversikt over tekstene som allerede er tilgjengelig for applikasjonen listes opp.\nPå denne siden kan man redigere eksisterende tekster samt legge til nye teksressurser. Nye tekster legges til ved å trykke på Ny tekst, og fylle ut tekst og en unik nøkkel.\nLagre endringer i tekstene ved å trykke på Lagre tekster.\nLegge til og endre tekster i repository Dersom det er mange tekster som skal endres på en gang kan det være praktisk å redigere tekstene i JSON-struturen direkte i repoet. Enten via Altinn Studio Repos eller i en lokal klone i selvvalgt kodeeditor.\nTekstene ligger lagret i App/config/texts\nVariabler i tekster Variabler i tekster kan inkluderes ved å følge oppsettet nedenfor. Det er viktig at rekkefølgen på variablene er den samme som parameterne i teksten.\n{ \u0026#34;id\u0026#34;: \u0026#34;good.text.id\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Hello, {0}! Here is a second variable {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;datamodelField\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.\u0026lt;dataModelName\u0026gt;\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;settings key\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;applicationSettings\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;instance value key\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;instanceContext\u0026#34; } ] } Datakilder Det er per nå mulig å hente verdier fra 3 ulike datakilder.\n Datamodel\nVed å angi dataModel.\u0026lt;dataModelNavn\u0026gt; som datakilde kan man hente ut verdier fra felter i skjema som brukeren fyller ut. Data kan hentes fra felter uavhengig av om de er synlige eller ikke. Hvis bruker endrer på data i et felt referert i en variabel så vil teksten bli oppdatert når bruker forlater feltet. Instillinger\nVed å angi applicationSettings som datakilde kan man hente ut verdier fra en spesiell seksjon i appsettings.{miljø}.json filen(e) med navn FrontEndSettings. Dette er en dynamisk liste man kan utvide uten å måtte gjøre endringer i kode. Dette gjør det mulig å ha ulike verdier fra miljø til miljø ved å ha andre verdier i de ulike appsettings.{miljø}.json filene. Vær obs på ulik bruk av stor bokstav i starten av nøkkel mellom FrontEndSettings og applicationSettings. \u0026#34;FrontEndSettings\u0026#34;: { \u0026#34;HomeBaseUrl\u0026#34;: \u0026#34;https://www.testdirektoratet.no\u0026#34; },  Instans\nVed å angi instanceContext som datakilde kan man hente ut enkelte verdier fra den aktive instansen. Vi har altså ikke gitt tilgang til hele instanse objektet. Listen med egenskaper så langt er:  instanceOwnerPartyId inneholder avgiver sin party id. instanceId inneholder id\u0026rsquo;en til den aktive instansen. appId inneholder id\u0026rsquo;en til appen instansen er knyttet til.    Komplett eksempel: { \u0026#34;id\u0026#34;: \u0026#34;common.submitinfo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du leverer nå skjema for: {0} med organisasjonsnummer: {1}. Organisasjonens party id er {2}. [Link til oss]({3}).\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig.organisasjonsnavn\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig.organisasjonsnummer\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;instanceOwnerPartyId\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;instanceContext\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;homeBaseUrl\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;applicationSettings\u0026#34; } ] } Variabler i tekst - repeterende grupper For at variabler i tekst skal fungere med data som ligger i repeterende grupper, må oppsettet vist over endres litt for de aktuelle feltene, for å spesifisere den repeterende gruppen dataene ligger i.\nDette gjøres ved å legge til [{0}] etter den repeterende gruppen når man spesifiserer felt i datamodellen i key-parameteren. F.eks.:\n{ \u0026#34;id\u0026#34;: \u0026#34;common.submitinfo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du leverer nå skjema for: {0} med organisasjonsnummer: {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig[{0}].organisasjonsnavn\u0026#34;,  \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig[{0}].organisasjonsnummer\u0026#34;,  \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; } ] } Det er fullt mulig å kombinere variabler fra felter i repeterende gruppe med variabler fra felter utenom den repeterende gruppen. Det anbefales derimot ikke å kombinere variabler fra felter fra forskjellige repeterende grupper, med mindre man er helt sikker på at rekkefølgen på innslag i gruppene vil bli helt like.\nLegge til hjelpetekst Hjelpetekster er små tekstsnutter som gir en kort og konsis beskrivelse av hva sluttbrukeren er forventet å fylle ut i feltet som teksten er tilknyttet.\nSpråknøklene som peker på hjelpeteksten er definert i FormLayout.json. I app repoet finner du filen under App/ui/.\nNedenfor ser du et eksempel på en FormLayout.json uten hjelpetekster.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;componentType\u0026#34;: 0, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;appName\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;08d707a9-2475-4d23-bf76-f209fb434ec2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;componentType\u0026#34;: 7, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tilleggsopplysninger.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;tilleggsopplysninger.desc\u0026#34;, }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;omsetningsoppgaverTilleggsopplysninger.value\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;bd6589b6-e2ab-49ba-b39a-dd3f8b63e5de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Dersom du skulle ønske å legge til hjelpetekst på en av disse skjemakomponentene må du\n Legge til hjelpeteksten i tekstressursfilen som beskrevet her. Åpne FormLayout.json-filen. Legg til en binding til den nye hjelpeteksten med nøkkel \u0026quot;help\u0026quot; og verdi lik nøkkel til tekstressursen.  Slik ser hele filen ut etter å ha lagt til en hjelpetekst:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;componentType\u0026#34;: 0, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;appName\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;08d707a9-2475-4d23-bf76-f209fb434ec2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;componentType\u0026#34;: 7, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tilleggsopplysninger.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;tilleggsopplysninger.desc\u0026#34;, \u0026#34;help\u0026#34;: \u0026#34;tilleggsopplysninger.help\u0026#34;  }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;omsetningsoppgaverTilleggsopplysninger.value\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;bd6589b6-e2ab-49ba-b39a-dd3f8b63e5de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Endre applikasjonstittel Når man oppretter en applikasjon vil man ha en tekstressurs med label appName. Dette er tittelen på applikasjonen som vil gjenspeiles flere steder i løsningen vår. Blant annet når en sluttbruker fyller ut skjema, og når elementer skal vises i meldingsboksen på altinn.no.\nTittelen på applikasjonen skal ligge to steder i applikasjonsrepoet:\n  I tekstressurser med nøkkelen appName. Tjenesteeiere oppfordres til å legge inn tittel på bokmål, nynorsk og engelsk. Dersom tittel mangler i tekstressursene vil lagringsnavnet (navnet på repoet) vises til sluttbrukeren.\n  I applicationmetadata.json under property title. Denne filen ligger under App/config/.\n  Dersom man gjør endrer appName på applikasjonen sin lokalt er det viktig at også legge til den oppdatere tittelen i applicationmetadata.json også. Dersom tittel på applikasjonen endres i Altinn Studio enten på \u0026ldquo;Om\u0026rdquo; eller \u0026ldquo;Språk\u0026rdquo;-siden bli applicationmetadata.json oppdatert automatisk.\nEksempel på korrekt konfigurasjon for applikasjonstittel I App/config/applicationmetadata.json:\n\u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34;, \u0026#34;nn\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34;, \u0026#34;en\u0026#34;: \u0026#34;Auto deploy application\u0026#34; }, I App/config/texts/resource.nb.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34; }, . . . ] } I App/config/texts/resource.nn.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;nn\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34; }, . . . ] } I App/config/texts/resource.en.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Auto deploy application\u0026#34; }, . . . ] } Endre applikasjonseier tekst I applikasjonen så vises applikasjonsnavn og applikasjonseier-tekstene øverst i skjema.\nApplikasjonsnavn hentes som standard ut fra tekstene som er definert i altinn-orgs.json. Om det er ønskelig å endre på dette navnet kan det gjøres ved å legge til nøkkelen appOwner i tekstressursene. Denne vil da overstyre det som ligger på CDN.\nEksempel:\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appOwner\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Test Ministry\u0026#34; }, . . . ] } Endre tekster på kvitteringssiden for arkiv Tekster på kvitteringssiden kan overstyres av applikasjonen ved å spesifisere tekster i applikasjonens config/texts/resource.xx.json fil.\nOverstyring av tekster i kvitteringen vil ha påvirkning for alle kvitteringer for den gitte applikasjonen. Dette betyr at alle skjemaer som allerede er insendt vil også få det oppdaterte tekstene på kvitteringssiden. PDF filen som er generert vil ikke påvirkes av dette.\r\rMarkdown og variabler kan benyttes i kvitteringstekstene. Det er kun mulig å hente variabler fra Instance (Se Data Sources for detaljer)\nDette er tekstnøklene som kan brukes for å overstyre standardtekstene:\nreceipt_platform.attachments\rreceipt_platform.date_sent\rreceipt_platform.helper_text\rreceipt_platform.is_sent\rreceipt_platform.receipt\rreceipt_platform.receiver\rreceipt_platform.reference_number\rreceipt_platform.sender\rreceipt_platform.sent_content\rHvis du for eksempel vil overstyre hjelpeteksten, kan du legge dette til i config/texts/resource.nb.json filen i applikasjonen:\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receipt_platform.helper_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Min egendefinerte hjelpetekst\u0026#34; } ] } Bildet nedenfor viser hvilke tekstnøkler som styrer hvilken del av brukergrensesnittet:\nMerk! Disse tekstendringene vil ikke være synlige når du tester appen din lokalt, de synes kun i eksternt testmiljø, f.eks.TT02. Du vil se endringene når du åpner et allerede arkivert skjema fra Arkivet ved å trykke på knappen \u0026ldquo;Se innsendt skjema\u0026rdquo;. Per nå blir ikke disse modifiserte tekstene brukt under selve innsendingen av skjemaet (det ligger en sak på dette på github). "
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/develop-component/",
	"title": "Utvikle en komponent",
	"tags": [],
	"description": "Start gjerne utviklingen av ny funksjonalitet eller nye komponenter som er godkjent av Altinn. Vi setter pris på om du planlegger arbeidet ditt med oss før du begynner.",
	"content": "Før du starter utvikling av ny funksjonalitet kan det være lurt å sjekke om oppgaven allerede ligger i backloggen vår. Om du ikke finner den vil vi gjerne at du først foreslår ønsket funksjonalitet/komponent og starter en dialog med oss før utviklingen starter.\nVi stiller samme krav til eksterne bidrag som vi gjør til vår egne. Før utviklingen starter vil vi derfor gjerne være med å spesifisere hvordan komponenten skal løses både når det gjelder design og tekniske beslutninger. Det beste for å få til en bra flyt er en dialog.\nI dialog med deg vil vi:\n Finne ut hva komponenten skal dekke og diskutere løsningen Er det mangler i designskisser eller teknisk løsning som må utbedres Trenger du hjelp med design eller brukertesting  Utviklingshåndbok All informasjon du trenger for komme i gang finner du i vår utviklingshåndbok. Håndboken inneholder blant annet informasjon du trenger for å skrive konsistent kode og bygge nye komponenter.\nTilgjengelighetstest Apper bygget på Altinn 3 skal være tilgjengelig for alle og for å forsikre oss om dette skal vi oppfylle WCAG 2.1 rettningslinjene. Se kravene beskrevet på UU-tilsynet eller a11yproject.\nReview av komponent Når en pull request blir laget vil vi gjøre en review av komponenten din. Forhåpentligvis har vi blitt enige om hvordan komponenten skal løses på forhånd slik at ikke de store endringene blir i denne delen av prosessen.\n Testing WCAG-testing Code review Design review  Dersom vi finner noe som bør utbedres kontakter vi deg for videre utvikling.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/",
	"title": "Utvikling",
	"tags": [],
	"description": "Hvordan opprette og redigere apper i Altinn Studio.",
	"content": "\r\rData\rKonfigurering av datamodell, preutfylling og andre ting relatert til data i en app.\n\r\rApp brukergrensesnitt\rKonfigurering av komponenter, layouts, sider, grid, etc.\n\r\rLogikk\rHvordan legge til, endre og konfigurere applikasjonslogikk som validering, kalkulering, dynamikk m.m.\n\r\rKonfigurasjon\rKonfigurering av ulike aspekter av en app.\n\r\rAPI\rAppene som man utvikler i Altinn Studio kan både eksponere standard og custom APIer samt benytte seg av APIer. Slik gjør du det.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/",
	"title": "API",
	"tags": [],
	"description": "Appene som man utvikler i Altinn Studio kan både eksponere standard og custom APIer samt benytte seg av APIer. Slik gjør du det.",
	"content": "\r\rEksponere APIer fra en app\rMan kan legge til flere API enn det som er definert som standard API for applikasjoner utviklet i Altinn Studio.\n\r\rInstans\rHvordan gjøre endringer på applikasjonsinstanser\n\r\rKonsumere APIer i en app\rEn applikasjon kan konsumere åpne og lukkede API som er tilgjengelig via Internett.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/checkbox/",
	"title": "Avkrysningsboks",
	"tags": [],
	"description": "Avkrysningsbokser brukes i tilfeller der brukeren kan huke av ett eller flere alternativer fra en liste.",
	"content": "Dersom brukeren kun kan velge et av alternativene, bruk radioknapper i stedet.\nRetningslinjer:  Avkrysningsboksene skal stå foran tilhørende tekst, og skal aldri stå alene. Deaktiverte avkrysningsbokser bør unngås. Dersom et valg ikke er tilgjengelig bør det heller fjernes og forklares i tekst hvorfor det mangler.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/instances/",
	"title": "Instanser",
	"tags": ["api", "translate-to-norwegian"],
	"description": "App API å jobbe med forekomster av en app.",
	"content": "Overview An instance can be regarded as an envelope or folder where data is collected and exchanged between the application user and owner. The instance document is a way for Altinn and external parties to track the state of one specific data exchange. How long an instance lives and how many interactions there are between the application owner and user will vary from one app to another. Advanced apps will have their own documentation.\nbasePath\n{org}/{appname}/instances Get instance Endpoint for downloading the instance metadata document for a specific instance. The app API does not have an endpoint for listing instances. The Storage API in the Platform has a query endpoint that can be used for this purpose.\nUse this endpoint for instances that are active, and the owner party id and instance guid for the instance are known. External systems that work with an instance over multiple sessions might want to keep these values (or full URL) stored on their end to limit the need to query this information multiple times.\nGET {basePath}/{instanceOwnerPartyId}/{instanceGuid} Get active instances Endepunkt for å liste aktive instanser for en avgiver.\nDette endepunktet kan benyttes for å avgjøre om en ny instans av en app skal opprettes eller om det er mer hensiktsmessig å fortsette utfylling av en eksisterende instans. Merk at objektet som returneres er en liste med forenklede instansobjekt og at LastChangedBy inneholder navnet på den sist aktive entiteten i stedet for id.\n[ { \u0026#34;id\u0026#34;: \u0026#34;1337/bffd2c17-9d93-49f4-b504-3d0ece2402c7\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2021-09-23T10:19:43\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;Sophie Salt\u0026#34; }, { \u0026#34;instanceId\u0026#34;: \u0026#34;1337/agfd2c17-4d93-49f4-b504-3d0ece2402d8\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2021-07-11T22:14:02\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;Sophie Salt\u0026#34; } ] GET {basePath}/{instanceOwnerPartyId}/active Create instance Altinn assigns a unique identifier to all users that wish to report data. We call this id instanceOwner.partyId. If you do not know this, you should provide the official identity number, e.g national identification number for persons or organisation number for organisations, and in some case user name. This should be provided as part of the payload to the creation request. Altinn will look up this identifier and replace it with the instanceOwner.partyId. The official identity number will be stored in the instance metadata.\nData elements can be provided as part of the creation request, but can also be uploaded at a later time.\nThe client specifies the instance owner and may set a number of the metadata fields of the instance by attaching the following form:\n{ \u0026#34;appId\u0026#34; : \u0026#34;org/app\u0026#34;, \u0026#34;instanceOwner\u0026#34;: { \u0026#34;personNumber\u0026#34;: \u0026#34;12247918309\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;dueBefore\u0026#34;: \u0026#34;2019-06-01T12:00:00Z\u0026#34;, \u0026#34;visibleAfter\u0026#34;: \u0026#34;2019-05-20T00:00:00Z\u0026#34; } Notice that all dates must be expressed in Utc (Zulu) time zone and represented according to ISO 8601!\nData elements (files) can be attached to the initial request as a multipart/form-data or as attachments. The name of the parts must correspond to element types defined in the application metadata.\nPOST {basePath} A multipart/formdata should contain the instance json document and the data element files of the instance. The first part should be instance which contains the json template to create an instance from.\nThe subsequent parts must have a name that correspond to the element types defined in application metadata. They may have a filename. Hence the model1 and certificate names correspond to data types defined in the application metadata. If additional data elements are required they must be defined in the application metadata.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { ... } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;model1\u0026#34; \u0026lt;xml\u0026gt; ... \u0026lt;/xml\u0026gt; --abcdefg Content-Type: application/pdf Content-Disposition: form-data; name=\u0026#34;certificate\u0026#34;; filename=certificate.pdf %PDF-1.4 %Óëéá 1 0 obj ... --abcdefg-- This call will return the instance metadata document that was created.\nSimplified instansiation For scenarios where the multipart is not required there is a new API that is simpler. It supports both key-value prefilling and copying data from an archived instance.\nThe endpoint is available at\nPOST {basePath}/create Required body differs for the two features, and examples of the request body are available below.\nInstantiation with key-value prefill { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;personNumber\u0026#34;: \u0026#34;12247918309\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;prefill\u0026#34;: { \u0026#34;navnGarantist\u0026#34; : \u0026#34;Ole Hansen\u0026#34; }, \u0026#34;dueBefore\u0026#34;: \u0026#34;2019-06-01T12:00:00Z\u0026#34;, \u0026#34;visibleAfter\u0026#34;: \u0026#34;2019-05-20T00:00:00Z\u0026#34; } Instantiation from archived instance { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;partyId\u0026#34;:\u0026#34;50002108\u0026#34;, \u0026#34;personNumber\u0026#34;: null, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;sourceInstanceId\u0026#34;: \u0026#34;50002108/049622b8-ea06-40f6-9f1b-26ceb7566232\u0026#34; } Update sub status The instance sub status is used to give an end user further details about the state of their instance. Currently, only application owner is allowed to update substatus for an instance. Include the new substatus in the body of the requests as a json.\nPUT {basePath}/{instanceOwnerPartyId}/{instanceGuid}/substatus Request body\n{ \u0026#34;label\u0026#34;: \u0026#34;some.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beskrivelse i klarteskst\u0026#34; } The values can be referencing text resource names from the language files or be regular text.\nComplete instance Endpoint used by application owner to mark an instance as completed. Technically this only means that the instance is no longer needed by the application owner.\nAltinn will permanently delete an instance and all the data, if both application owner and a user with the necessary rights indicate on the instance that they no longer have a need for it.\nPOST {basePath}/{instanceOwnerPartyId}/{instanceGuid}/complete The request does not use the request body for anything even though it is a POST request.\nDelete instance Endpoint for marking an instance as deleted. This can be used by both application owner and user to delete an instance. The endpoint has an optional parameter called hard that can be used to indicate the type of delete that is wanted. Setting the parameter to false or simply omitting it, will move the instance to a recycle bin. Hard delete means that the instance will be unrecoverable.\nInstances that where active might be permanently deleted by Altinn within a few days. Archived instances will be permanently deleted if both application owner and a user with the necessary rights indicate on the instance that they no longer have a need for it.\nDELETE {basePath}/{instanceOwnerPartyId}/{instanceGuid}?hard=true The endpoint does not use the request body for anything.\nThere are no Application API endpoint for recovering instances in the recycle bin.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pdf/",
	"title": "PDF",
	"tags": [],
	"description": "Hvordan konfigurere generering av PDF.",
	"content": "Det er mulig å ekskludere enkelte komponenter, eller hele sider fra å bli med i pdf.\nDet er to måter å ekskludere data fra PDF på\n Via konfigurasjon i filen Settings.json under App/ui Programmatisk i filen PdfHandler.cs under App/logic/Print.  Dersom en side/komponent alltid skal ekskluderes fra PDF er det anbefalt å sette det opp i konfigurasjonsfilen. Dersom ekskludering av en side/komponent er avhengig av dynamikk må dette gjøres programmatisk.\n\rEkskludere sider I eksemplene nedenfor ekskluderes siden med id page2 fra PDF.\nKonfigurasjon { \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;pages\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [\u0026#34;page2\u0026#34;] } } Programmatisk public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data.GetType() == typeof(Skjema)) { layoutSettings.Pages ??= new(); layoutSettings.Pages.ExcludeFromPdf ??= new(); layoutSettings.Pages.ExcludeFromPdf.Add(\u0026#34;page2\u0026#34;); } return await Task.FromResult(layoutSettings); } Ekskludere komponenter I eksemplene nedenfor blir komponenten med id image-component-id ekskludert fra pdf.\nKonfigurasjon { \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;components\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [\u0026#34;image-component-id\u0026#34;] } } Programmatisk public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data.GetType() == typeof(Skjema)) { layoutSettings.Components ??= new(); layoutSettings.Components.ExcludeFromPdf ??= new(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;image-component-id\u0026#34;); } return await Task.FromResult(layoutSettings); } Ekskludere komponentinnslag i en repeterende gruppe Dersom du ønsker å ekskludere én eller flere komponenter fra et innslag i en repeterende gruppe gjøres dette ved å spesifisere indeksen av gruppeelementet i tillegg til komponent id.\nFormat for ekskludering: componentId-\u0026lt;groupIndex\u0026gt;.\nDersom komponenten skal ekskluderes for alle innslag i den repeterende gruppen kan intruksjonene i seksjonen over følges i stedet.\nI eksempelet nedenfor ekskluderes gruppeelement med indeks 1 og id ownerId fra PDF.\nProgrammatisk public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data.GetType() == typeof(Skjema)) { layoutSettings.Components ??= new(); layoutSettings.Components.ExcludeFromPdf ??= new(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;ownerId-1\u0026#34;); } return await Task.FromResult(layoutSettings); } Bildet illustrerer at komponenten med indeks 0 og 2 er bevart i PDF, mens komponent med indeks 1 er borte.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/",
	"title": "Testing av apper",
	"tags": [],
	"description": "Applikasjoner (apper) kan testes i testmiljø, eller lokalt.",
	"content": "\r\rTest av app lokalt\rBeskrivelse av hvordan test av app lokalt på egen maskin kan gjøres\n\r\rTest app i testmiljø\rBeskrivelse av hvordan test i testmiljø kan utføres.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/data-element/",
	"title": "DataElement",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Et DataElement er en metadatabeholder som brukes til å spore statusen til faktiske data blobs.",
	"content": "DataElement The data element model is the main model for metadata related to a specific data element. A data element can be any data associated with an instance. The two most common type of data is the actual form data and attachments.\nProperties    Name Description     id A globally unique id for the data element.   instanceGuid The globally unique id for the instance the data element is associated with.   dataType The name of the data type describing the requirements of the data element.   filename The data blob name if represented as a file.   contentType The mime-type of the content of the blob.   blobStoragePath The physical location of the data as it is stored in the Application owner storage account.   selfLinks A complex type containing a set of named links of how to obtain a copy of the data element.   size The number of bytes in the blob.   locked A value indicating whether the blob is read only.   refs A list of UUID values. Can be used to link related data elements.   isRead A boolean indicating if the dataElement has been read by a user.   created The date and time when the data element was first created.   createdBy An idenfificator indicating who it was that created the data element.   lastChanged The date and time when the data element was last changed.   lastChangedBy An idenfificator indicating who it was that made the last change to the data element.    Complete example This data element example is from the instance example.\n{ \u0026#34;id\u0026#34;: \u0026#34;8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;filename\u0026#34;: null, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/bli-applikasjonseier/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://altinn3local.no/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34; }, \u0026#34;size\u0026#34;: 401, \u0026#34;locked\u0026#34;: false, \u0026#34;refs\u0026#34;: [], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;createdBy\u0026#34;: null, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: null } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/radiobutton/",
	"title": "Radioknapp",
	"tags": [],
	"description": "Radioknapper brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder nedtrekksliste, så vær bevisst på når du bruker hvilken.",
	"content": "Radioknapper velges når:\n Du ikke har for mange valgalternativer (Maks 7) Det ikke er et tydelig anbefalt valg Når brukeren enkelt skal kunne sammenligne alternativene Du ønsker at brukeren skal lese alle alternativene Valgalternativene er ukjent for brukeren  Retningslinjer:  Radioknapper skal stå foran tilhørende tekst, og skal aldri stå alene. Deaktiverte radioknapper bør unngås. Dersom et valg ikke er tilgjengelig bør det heller fjernes og forklares i tekst hvorfor det mangler.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/widgets/",
	"title": "Widgets",
	"tags": [],
	"description": "Hvordan bruke sammensatte komponenter (widgets).",
	"content": "Hva er en widget? En widget er en kompleks komponent, sammensatt av en eller flere enkle skjemakomponenter - de skjemakomponentene som er tilgjengelige for bruk i Altinn Studio i dag. En widget er et verktøy i Altinn Studio som gjør det lettere å lage og gjenbruke layouts.\nHvordan bruke widgets Widgets er tilgjengelige i venstre-menyen i skjemaeditoren i Altinn Studio. Den kan dras inn i skjemasiden på samme måte som andre skjemakomponenter. Når en widget dras inn i skjema i Altinn Studio, legges de skjemakomponentene som er definert som del av widget\u0026rsquo;en til i layouten, sammen med ev. standard oppsett som knytning til datamodell, tekster, osv. Når en widget er dratt inn i skjema, vil man kun se de skjemakomponentene som den er laget av. Disse kan redigeres som normalt i skjemaeditoren. Dersom det er tekster definert for widget\u0026rsquo;en, disse legges til i ressursfilene for tekster automatisk.\nEksempel: Meldings-widget Tilgjengelige widgets Standard widgets Vi vil etter hvert kunne tilby en samling av forskjellige widgets, disse vil dukke opp automatisk i venstre-menyen i skjemaeditoren i Altinn Studio. Listen oppdateres etter hvert som nye widgets legges til. Per nå. er følgende widgets tilgjengelig:\n   Navn Beskrivelse Skjermbilde     Melding Inneholder komponentene som utgjør en standard melding:\n tittel\nmeldingstekst\nvedlegg\nnavigasjonsknapp\nTekstene er satt opp med referanse til felt i standard melding datamodell. Se her for mer info om meldinger.     Egendefinerte widgets I tillegg til standard widgets som kommer opp automatisk i Altinn Studio, er det også mulig å definere sine egne widgets. En widget består av 3 deler:\n Komponenter: Dette er liste over komponentene som skal inngå, inkl. definisjon av disse komponentene. Dette settes opp på samme måte som i layout-filene, man kan f.eks. kopiere ut komponenter direkte fra en layout-fil. Visnings-navn: Dette er teksten som vises i Altinn Studio, i menyen der widget\u0026rsquo;en ligger. Tekstressurser: Dette er valgfritt, og er en liste over tekstressurser på de språk som man ønsker å ha med. Nyttig om komponentene f.eks. skal ha noen standard tekster de bruker.  Se oppsett for meldings-widget for et konkret eksempel. Det fins også en widget-mal som kan lastes ned for å komme i gang.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/select/",
	"title": "Nedtrekksliste",
	"tags": [],
	"description": "Nedtrekksliste brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder radioknapper, så vær bevisst på når du bruker hvilken.",
	"content": "Nedtrekksliste velges når:\n Du har mange alternativer (mer enn 5) Du har et anbefalt valg som vises som forhåndsvalgt Det ikke er så viktig for brukeren å kunne sammlenligne alternativene Du ønsker ikke at brukeren skal trenge å lese alle alternativene Valgalternativene er kjent for brukeren  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/helptext/",
	"title": "Hjelpetekst",
	"tags": [],
	"description": "Hjelpetekster er små tekstsnutter som kan benyttes for å gi brukeren ekstra veiledning i utfylling av skjemafelter.",
	"content": "Man kan også benytte feltet til å forklare et regelverk, fremmede begreper, eller utdype hvorfor man ber om informasjonen.\nRetningslinjer:  Hjelpetekst plasseres i sammenheng med en label eller tittel som skal utdypes. Dersom innholdet er avgjørende informasjon for at brukeren skal kunne fylle ut skjemaet riktig, bør det heller plasseres i en infotekst i grensesnittet (under labelen).  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/error-message/",
	"title": "Feilmeldinger",
	"tags": [],
	"description": "Feilmeldinger forklarer brukeren hva som gikk galt og hvordan det kan rettes opp i.",
	"content": "Vær kort og tydelig i formuleringen av feilmeldingene og sørg for at brukeren vet hva som må gjøres for å komme videre. Å skrive \u0026ldquo;Feltet er ikke fyllt ut korrekt\u0026rdquo; gir ikke brukeren en forklaring på hva som er feil.\nEksempel på forklarende feilmeldinger:  \u0026ldquo;Postnummer må ha 4 siffer\u0026rdquo; \u0026ldquo;Du må velge minst ett leveringsalternativ\u0026rdquo; \u0026ldquo;For å sende inn skjemaet må du bekrefte at navnet er korrekt ved å huke av i avkrysningsboksen\u0026rdquo;  Les mer om å formidle feil i skjema på UU-tilsynets nettsider.\nRetningslinjer:  Feilmeldingstekst bør gjenta nøkkelord fra label Kravene for å fylle ut skjemaet riktig skal tydelig fremgå av skjemaet uten at brukeren trenger å få noen feilmeldinger fra valideringen for å forstå dette. Dersom skjemaet har feil når brukeren forsøker å gå videre, skal feilmeldingsboksen i toppen vise alle feilene og lenke til de feltene feilen gjelder. Feilene skal forsvinne etterhvert som de blir utbedret. ⚠️ NB: Denne funksjonaliteten er ikke tilgjengelig i Altinn Studio enda.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v3 av Altinn.Platform.Storage.Interface.",
	"content": "3.9.0 Utvidet EFormidlingContract med DPFShipmentType Utvidet  EFormidlingContract modellen har blitt utvidet med en ny egenskap DPFShipmentType. Verdien er en streng som representeres forsendelsestype hvis servicen er DPF.  3.8.0 Utvidet ProcessHistoryItem med performedBy Utvidet  ProcessHistoryItem modellen har blitt utvidet med en ny egenskap performedBy. Verdien er en streng og kan inneholde personnummer eller organisasjonsnummer som representerer entiteten som trigget eventet.  3.7.0 Utvidet PlatformUser med nationalIdentityNumber egenskap  PlatformUser modellen har blitt utvidet med en ny egenskap nationalIdentityNumber.  3.6.0 Utvidet InstanceOwner med username egenskap  InstanceOwner modellen har blitt utvidet med en ny egenskap username.  3.5.0 Lagt til CopyInstanceSettings på modellen Application  Application modellen har blitt utvidet med en ny egenskap for å holde på konfigurasjon knyttet til kopiering av instans. Egenskapen tillater å aktivere kopiering av instans, samt spesifisere ekskluderte datafelt og -typer.  3.4.0 Lagt til MessageBoxConfig på modellen Applicaton  Application modellen har blitt utvidet med en ny egenskap for å holde på en meldingsbokskonfigurasjon.  3.3.0 Lagt til Tags på modellen DataElement  DataElement modellen har blitt utvidet med en ny egenskap for å holde på en liste med stikkord (tags).  3.2.0 Innføring av ny modell OnEntryConfig  Innføring av en ny model, OnEntryConfig for å støtte definering av hva som skal skje når en bruker åpner opp en applikasjon. Modellen er lagt inn som en egenskap på Application.  3.0.1 Innføring av ny modell DataValues  Modellen DataValues er innført til å representere input til API endepunkt for registrering av tekster fra skjema direkte på en Instance.  3.0.0 Refactoring and model application/instance model changes Endringer som krever tilpassninger i app kode (breaking changes)  Modellen PresentationField har endret navn til DataField. Dette gjøres slik at den kan benyttes i flere sammenhenger. Bruken av modellen er utvidet til å representere et element i egenskapen DataFields på Application i tillegg til at den fortsatt brukes for å representere elementer i egenskapen PresentationFields. Det er ingen andre endringer i modellen eller hvordan den blir brukt.  Andre endringer  Application modellen er utvidet med en ny egenskap kalt DataFields og Instance er utvidet med korresponderende egenskap kalt DataValues for å holde verdiene identifisert basert på DataFields.  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/",
	"title": "v4",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v4 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v4.0.0.\n\r\rHva er nytt?\rOversikt over endringer som ble introdusert i versjon 4.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v3 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v3.0.0.\n\r\rHva er nytt?\rOversikt over endringer som ble introdusert i versjon 3.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/scenarios/authentication/",
	"title": "Autentisering",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Hvordan autentisere ved å bruke APIene.",
	"content": "Authentication for application owners Application owners should be authenticated with Maskinporten.\nAPI provisioning in Maskinporten API-provider To provide an API in maskinporten Altinn has to do two operations.\n As API-provider Altinn registres a scope in Maskinporten POST /scopes { \u0026#34;prefix\u0026#34;: \u0026#34;altinn\u0026#34;, \u0026#34;subscope\u0026#34;: \u0026#34;instances/metadata.read\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Clients can access metadata for all instances for all apps of the organisation\u0026#34; }  As API-provider Altinn has to give access to its scope for a given organisation PUT /scopes/access/889640782?scope=altinn:apps.read Here we have given organisation 889640782 access to the scope altinn:instances/metadata.read. The organisation must then create a client that uses the scope.\n  API-consumer To access the Altinn API an organisation must create a client.\n As API-consumer the organisation must create a client in Maskinporten with scopes provided by Altinn: POST /clients { \u0026#34;client_name\u0026#34;: \u0026#34;altinnOrgRead\u0026#34;, \u0026#34;client_type\u0026#34;: \u0026#34;CONFIDENTIAL\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Client for accessing the my orgs app data\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;altinn:instances/metadata.read\u0026#34; ],  \u0026#34;token_reference\u0026#34;: \u0026#34;SELF_CONTAINED\u0026#34; }   Scopes scope names must follow the following regexp:\n^([a-z0-9]+\\/?)+[a-z0-9]+(\\.[a-z0-9]+)?$? It means that we cannot have - or _ in scope names.\nAll instances scope altinn:serviceowner/instances.read altinn:serviceowner/instances.write This is the most general scope which can be given to an organisation by Altinn. It means that the application owner can create a client that can access all instances of apps issued by that application owner.\nClients with write scope will be able to instantiate applications through direct access to the app\u0026rsquo;s api, update metadata, update process state, upload data, validate data, and change process of an instance.\nClients with read token will only be allowed to read metadata, data and events information.\nExchange of JWT token Application owners register clients in Maskinporten and selects the scope they need.\nA client is authenticated by Maskinporten and are given a Maskinporten JWT access token.\nThis token has to be validated and replaced with an Altinn JWT access token which should be used to access the apis.\nMaskinporten JWT access token (input) Client provides a self-contained access-token.\nAutorization: Bearer eyJraWQiOiJIdFlaMU1UbFZXUGNCV0JQVWV3TmxZd1RCRklicU1Hb081OFJ4bmN6TWJNIiwiYWxnIjoiUlMyNTYifQ.eyJhdWQiOiJ0ZXN0X3JwIiwic2NvcGUiOiJ ... GET /authentication/api/v1/exchange/maskinporten The token looks something like this (after base64-decoding):\n{ \u0026#34;kid\u0026#34;: \u0026#34;HtYZ1MTlVWPcBWBPUewNlYwTBFIbqMGoO58RxnczMbM\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34; } . { \u0026#34;aud\u0026#34;: \u0026#34;https://tt02.altinn.no/maskinporten-api/\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;altinn:instances.write\u0026#34;, \u0026#34;iss\u0026#34;: \u0026#34;https://oidc-ver2.difi.no/idporten-oidc-provider/\u0026#34;, \u0026#34;client_amr\u0026#34;: \u0026#34;virksomhetssertifikat\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;exp\u0026#34;: 1571935870, \u0026#34;iat\u0026#34;: 1571923870, \u0026#34;client_id\u0026#34;: \u0026#34;0de19f7a-f5fa-45d1-874c-3d2e88ce97d9\u0026#34;, \u0026#34;client_orgno\u0026#34;: \u0026#34;974760673\u0026#34;,  \u0026#34;jti\u0026#34;: \u0026#34;U3HMLIY8b_X454CADQzfttSuWpCADPQhc57iZXVF_Ac\u0026#34;, \u0026#34;consumer\u0026#34;: { \u0026#34;authority\u0026#34;: \u0026#34;iso6523-actorid-upis\u0026#34;, \u0026#34;ID\u0026#34;: \u0026#34;0192:974760673\u0026#34; } } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Maksinporten provides the legal consumer (the client) in ISO 6523 format. The client_orgno claim is deprecated.\nThe Altinn JWT Access token (output) The convert operation validates the incoming token and generates a new JWT token with the same scope as the token. The scopes is copied. The orgNumber and org is added by the token converter.\n{ \u0026#34;scope\u0026#34;: \u0026#34;altinn:instances.read altinn:instances.write\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;exp\u0026#34;: 1571996946, \u0026#34;iat\u0026#34;: 1571995146, \u0026#34;client_id\u0026#34;: \u0026#34;0de19f7a-f5fa-45d1-874c-3d2e88ce97d9\u0026#34;, \u0026#34;client_orgno\u0026#34;: \u0026#34;974760673\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;BcNIAuZKXdjpECmmwalAm-pcBp0iNc56T6eXhlxNBZE\u0026#34;, \u0026#34;consumer\u0026#34;: { \u0026#34;authority\u0026#34;: \u0026#34;iso6523-actorid-upis\u0026#34;, \u0026#34;ID\u0026#34;: \u0026#34;0192:974760673\u0026#34; }, \u0026#34;org\u0026#34;: \u0026#34;brg\u0026#34;, \u0026#34;orgNumber\u0026#34;: 974760673,  \u0026#34;iss\u0026#34;: \u0026#34;https://platform.altinn.cloud/\u0026#34;, \u0026#34;AuthenticateMethod\u0026#34;: \u0026#34;maskinporten\u0026#34;, \u0026#34;AuthenticationLevel\u0026#34;: 3, \u0026#34;nbf\u0026#34;: 1571995146 } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Authentication for end user system End user systems should be authentication with ID-porten. When authenticated the system may exchange an access token provided by ID-porten with an Altinn token by instructions below.\nExchange of JWT token This token has to be validated and replaced with an Altinn JWT access token which should be used to access the apis.\nID-porten JWT access token (input) Autorization: Bearer eyJraWQiOiJjWmswME1rbTVIQzRnN3Z0NmNwUDVGSFpMS0pzdzhmQkFJdUZiUzRSVEQ0IiwiYWxnIjoiUlMyNTYifQ.eyJhdF9 ... GET /authentication/api/v1/exchange/id-porten The token looks something like this (after decoding):\n{ \u0026#34;kid\u0026#34;: \u0026#34;cZk00Mkm5HC4g7vt6cpP5FHZLKJsw8fBAIuFbS4RTD4\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34; } . { \u0026#34;at_hash\u0026#34;: \u0026#34;IF-jpSLtMjzoHdEhLq9pnw\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;PZcxQYOR_ylbrlj69pXn_HdTmrpDRpA3X0rTyOEyN5I=\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;Minid-PIN\u0026#34; ], \u0026#34;iss\u0026#34;: \u0026#34;https://oidc-ver2.difi.no/idporten-oidc-provider/\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;191080XXXXX\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;nonce\u0026#34;: \u0026#34;1584978003167642\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;bQDBkJmjrX3bx2agu4q7BS5QW6TPf9CHnJX11vEthZg\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;38e634d9-5682-44ae-9b60-db636efe3156\u0026#34;, \u0026#34;acr\u0026#34;: \u0026#34;Level3\u0026#34;, \u0026#34;auth_time\u0026#34;: 1584978021, \u0026#34;exp\u0026#34;: 1584978141, \u0026#34;iat\u0026#34;: 1584978021, \u0026#34;jti\u0026#34;: \u0026#34;_Og8JT1zMKzzHFB4WoVCdvqzmEpoY1hPhLa47bieJ94\u0026#34; } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; The Altinn JWT Access token (output) The exchange operation validates the incomming token and generates a new JWT token that contains user data retrieved from the database using the provided pid (person identification number) and pre-existing data from the ID-porten token.\npid is referred to as ssn (social security number) i Altinn Platform.\n{ \u0026#34;nameid\u0026#34;: \u0026#34;20000011\u0026#34;, \u0026#34;urn:altinn:userid\u0026#34;: \u0026#34;20000011\u0026#34;, \u0026#34;urn:altinn:username\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;urn:altinn:partyid\u0026#34;: 50002119, \u0026#34;urn:altinn:authenticatemethod\u0026#34;: \u0026#34;Minid-PIN\u0026#34;, \u0026#34;urn:altinn:authlevel\u0026#34;: 3, \u0026#34;amr\u0026#34;: \u0026#34;Minid-PIN\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;191080XXXXX\u0026#34;,  \u0026#34;locale\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;nonce\u0026#34;: \u0026#34;1585045781364132\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;BYSqEpVGRrh6rElmnzzTjcU0roC95rxNCC2kAsB2hmY\u0026#34;, \u0026#34;acr\u0026#34;: \u0026#34;Level3\u0026#34;, \u0026#34;auth_time\u0026#34;: 1585045793, \u0026#34;exp\u0026#34;: 1585047785, \u0026#34;iat\u0026#34;: 1585045985, \u0026#34;nbf\u0026#34;: 1585045985 } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Open ID Connect configuration This is work-in-progress. The response is still missing required information and might be inconsistent with actual authentication mechanisms.\r\rMetadata about Altinn as an Open ID provider is exposed as a .well-known endpoint as defined by OpenID Connect Discovery.\nThe primary porpose of this endpoint is to make available the Altinn signing certificate for the JSON Web Tokens being generated. It is recommended that clients of Altinn use this discovery endpoint to automatically have their systems updated when Altinn changes their signing certificate.\n   Environment URL     AT2x https://platform.at2x.altinn.cloud/authentication/api/v1/openid/.well-known/openid-configuration   YT01 https://platform.yt01.altinn.cloud/authentication/api/v1/openid/.well-known/openid-configuration   TT02 https://platform.tt02.altinn.no/authentication/api/v1/openid/.well-known/openid-configuration    "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorisation/",
	"title": "Autorisasjon",
	"tags": [],
	"description": "Hvordan definere autorisasjonsregler (tilgangsstyring) for en app.",
	"content": "Autorisasjonsregler for en applikasjon er definert i en XACML Policy-fil som ligger i applikasjonsrepoet. XACML Policy-en inneholder en eller flere regler som definerer hvem som kan gjennomføre ulike aksjoner på ulike ressurser.\nBeskrivelse av XACML-strukturen og definisjon av regler finnes her\nXACML-filen kan endres i en valgfri teksteditor.\nRegler i applikasjonsmalen Når det opprettes en app i Altinn Studio basert på den nåværende asp.net malen vil det følge med en autogenerert XACML policy-fil. Reglene som er definert i denne filen er kort beskrevet nedenfor.\nOvernevnte regler kan endres i policy.xml som ligger i App/config/authorization i applikasjonsrepoet. Detaljer om hvordan å konfigurere policy filen finnes her I tillegg vil du finne en del eksempelregler her.\nMerk at endringer i policyfilen gjøres på eget ansvar, og at det oppfordres til å alltid delegere leserettigheter dersom en entitet også har fått tildelt skriverettigheter.\r\rRettigheter for rolleinnhaver I denne filen er det definert regler som gir innehaver av rollene daglig leder (DAGL) og/eller regnskapsmedarbeider (REGNA) rettigheter til å instansiere, skrive, lese og slette instanser av applikasjonen.\nEn fullstendig liste over rolletyper finner du her .\nRettigheter for applikasjonseier Applikasjonseier (organisasjonen) har rettigheter til å instansiere, skrive og lese instanser av applikasjonen. Til slutt har de rettigheter til å markere på en instans at de er ferdig med den.\nPåkrevd autentiseringsnivå Påkrevd autentiseringsnivå er satt til 2 som default. Dette gjøres som en obligation i XACML Policy\nHvis nivået settes til 4 må man definere at tjenesteier kan nå det via nivå 3 for maskinporten. Dette for at maskinporten er definert som nivå 3. Se regelbibliotek for eksempel. Merk: Appen trenger nuget versjon 3.1.5 eller høyere versjon.\n\rRegelbibliotek\rBibliotek av autorisasjonsregler som kan brukes i en app. Husk å bytte ut tags ([ORG], [APP], [RULE_ID]) med din egen data.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/data-elements/",
	"title": "Data-elementer",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API å jobbe med dataelementene knyttet til en app instans.",
	"content": "Overview A data element consist of two parts: its metadata document and the actual data blob. This API work primarily with the blob while keeping the metadata document updated.\nbasePath\n{org}/{appname}/instances/{instanceOwnerPartyId}/{instanceGuid}/data Get data Endpoint for downloading the data blob.\nGET basePath/{dataGuid} Accept: application/{xml/json} The response will depend on the type of blob. There are currently 2 primary types: form data based on a model and attachments. An Accept header in a request will be considered only when the requested data element is connected to a data model. The header is then used to pick a serializer for the data.\nResponse with form data A response with form data will either be a json or xml serialized version of the data model depending on the Accept header in the request. The value application/xml will result in an XML document and the value application/json will result inn a JSON document.\nResponse with attachment A response with a file attachment will be a file stream. Content-Type will be the same as the original value given when the file was uploaded. The same is true for the file name.\nContent-Disposition: attachment; filename=cute_cat.png; filename*=UTF-8\u0026#39;\u0026#39;cute_cat.png Content-Length: 16994 Content-Type: image/png Upload data Endpoint for uploading a new data element on a specific instance.\nPOST basePath?dataType={data type name} The dataType parameter is required and should reference one of the data types defined on the application. Data types with an appLogic property are linked to a form and will have data validation and calculation rules associated with them. Data types without an appLogic property will be handeled as an attachment and streamed directly to storage.\nRequest Content-Type is handled a little differently between the two cases:\n If a request is uploading form data, the Content-Type is used by Altinn to deserialize the request into a strongly typed object. A request must either be application/json or application/xml. No other Content-Types are supported. Content-Type is not validated against allowed Content-Types on the data type. If a request is uploading an attachment, the validation of Content-Type will depend on the rules of the data type.  If the data type has no Content-Type requirements, there will be no validation and the request can contain any Content-Type. If the data type has Content-Type requirements, there is a new set of checks.  The request Content-Type must either be application/octet-stream or match the MIME type of the file being uploaded. Altinn will perform a mapping from file extension to MIME type before comparing with Content-Type. As an example we can see that .xml will map to text/xml and not application/xml. If the data type allow Content-Type application/octet-stream no further validation is performed. If not, the identified MIME type must match one of the allowed Content-Types on the data type.      Uploading form data as application/json Content-Type: application/json { \u0026#34;dataFormatProvider\u0026#34;: \u0026#34;SERES\u0026#34;, \u0026#34;dataFormatId\u0026#34;: \u0026#34;5703\u0026#34;, \u0026#34;dataFormatVersion\u0026#34;: \u0026#34;34553\u0026#34;, \u0026#34;Tjenesteeier\u0026#34;: null, \u0026#34;Kontaktperson\u0026#34;: { \u0026#34;navn\u0026#34;: \u0026#34;Sophie Salt\u0026#34;, \u0026#34;epost\u0026#34;: \u0026#34;1337@altinnstudiotestusers.com\u0026#34;, \u0026#34;telefonnummer\u0026#34;: \u0026#34;90001337\u0026#34; }, \u0026#34;OEnsketBruk\u0026#34;: null } Uploading form data as application/xml Content-Type: application/xml \u0026lt;BliTjenesteeier_M xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; dataFormatProvider=\u0026#34;SERES\u0026#34; dataFormatId=\u0026#34;5703\u0026#34; dataFormatVersion=\u0026#34;34553\u0026#34;\u0026gt; \u0026lt;Kontaktperson\u0026gt; \u0026lt;navn\u0026gt;Sophie Salt\u0026lt;/navn\u0026gt; \u0026lt;epost\u0026gt;1337@altinnstudiotestusers.com\u0026lt;/epost\u0026gt; \u0026lt;telefonnummer\u0026gt;90001337\u0026lt;/telefonnummer\u0026gt; \u0026lt;/Kontaktperson\u0026gt; \u0026lt;/BliTjenesteeier_M\u0026gt; Uploading an attachment An example of a request uploading a PDF file.\nContent-Type: application/pdf Content-Disposition: attachment; filename=\u0026#34;receipt.pdf\u0026#34;; filename*=UTF-8\u0026#39;\u0026#39;receipt.pdf Content-Length: 16994 %PDF-1.4 %Óëéá 1 0 obj ... Response example The endpoint returns the data element metadata document that was created.\n{ \u0026#34;id\u0026#34;: \u0026#34;692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;762011d1-d341-4c0a-8641-d8a104e83d30\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;org/app/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;{appPath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;{storagePath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34; }, \u0026#34;filename\u0026#34;: \u0026#34;default.xml\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-03-06T15:00:23Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;org23\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2019-03-07T15:00:23Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;org23\u0026#34;, \u0026#34;size\u0026#34;: 20001, \u0026#34;locked\u0026#34;: false } Replace data Endpoint for replacing the content of an existing data element with new data. The new data must match the data type of the data element it is replacing.\nPUT basePath/{dataGuid} The endpoint works exactly like the endpoint for uploading a new data element.\nDelete data Endpoint for deleting an existing data element. It is currently not possible to delete the data for a form this way.\nDELETE basePath/{dataGuid} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/",
	"title": "Datamodell i Altinn Studio",
	"tags": [],
	"description": "Slik importerer eller viser du datamodellen i Altinn Studio.",
	"content": "Det er planlagt datamodelleringsfunksjonalitet inn i Altinn Studio. Den midlertidige funksjonaliteten er derfor svært begrenset.\r\rLaste opp / vise datamodell Datamodellen definerer hvilke data som kan sendes inn via en app, og hvilket format det skal sendes på. Per nå må datamodellen være definert som en XSD i et eksternt verktøy - gjerne Seres Domeneklient.\nDet må lastes opp en datamodell for hver app.\n Åpne appen fra dashboardet Velg fanen Lage, og valget Datamodell i navigasjonsmenyen Klikk på Velg XSD og velg XSD-en i filvelgeren Klikk Last opp  Datamodellen blir da parset, og alle nødvendige filer generert og lagret i app-repositoryet. Disse filene kan vises ved å velge de ulike fanene på datamodellsiden.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/designer/",
	"title": "Designer",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Designer.",
	"content": "Designer er verktøyet du starer i etter å ha logget inn på https://altinn.studio. Det er et verktøy for å opprette, konfigurere og deploye apper.\nNavigere til en app Alle apper du har tilgang til å endre på vises på dashboardet. Gå til appen ved å klikke på appen. Dersom du ikke har en lokal klone av appen, vil du bli bedt om å opprette det.\nHvis du ønsker å gå til app-repositoryet når du er inne i en app i Designer, er det en lenke i menyen som ligger i profilmenyen øverst til høyre.\nRedigere en app Det er to navigasjonsmenyer - en toppmeny og en venstremeny.\nI toppmenyen kan du navigere mellom ulike funksjonelle områder av applikasjonen. I venstremenyen kan du navigere innad i området.\n Om  Om appen   Lage  Datamodell UI-Editor Tilgangsstyring   Språk  Tekster   Deploy  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/file-upload/",
	"title": "Filopplasting",
	"tags": [],
	"description": "Filopplasting tillater brukere å laste opp en eller flere filer.",
	"content": "Du bør ikke be brukeren laste opp vedlegg med mindre det faktisk har en avgjørende betydning for tjenesten. Sjekk først om informasjonen kan hentes inn på annet vis, kanskje gjennom API?\nRetningslinjer:  Vær så fleksibel som mulig i forhold til hvilke filtyper som kan lastes opp. Ikke alle har kompetanse til å endre filtypeformat eller komprimere filer. Dersom det er feil i opplastingen, vær så spesifikk som mulig i feilmeldingen. Å si at “formatet ikke er godkjent” holder ikke, det må spesifiseres nøyaktig hva som kreves. Har du behov for at brukeren laster opp vedlegg av ulike typer/kategorier, anbefaler vi å bruke flere steg med en filopplaster i hvert steg. Spesifiser i innledningen på hver side hva som skal legges ved, slik at brukeren ikke blir i tvil.  Eksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/instances/",
	"title": "Instanser",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Platform API for instanser.",
	"content": "Overview An instance works as a form of envelope or folder where data can be collected and exchanged between the user and owner of the application. The instance document is a way for Altinn and external parties to track the state of one specific data exchange. How long an instance can live and how many interactions there can be between the application owner and user will vary from one app to another. Advanced Apps will have their own documentation.\nbasePath = https://{hostname}/storage/api/v1/instances Query instances It is possible to query instances based on a number of query parameters.\nApplication owners can search for from a single application or across all applications that they have. Using this endpoint requires the scope \u0026lsquo;altinn:instances.read\u0026rsquo;. And query parameter \u0026lsquo;org\u0026rsquo; or \u0026lsquo;appId\u0026rsquo; must be included in the request.\nUsers can search for instances linked to either themselves or an instanceOwner they are authorized to read the instances of. Query parametr \u0026lsquo;instanceOwner.partyId\u0026rsquo; must be included in the request if using this endpoint as an end user.\nSearch for instances with a simple GET request towards the instances endpoint. Avaliable query paramters include:\n process.currentTask (string)\nSearch for instances at a specific step in its process. process.isComplete (bool)\nSearch for instances where the process is completed. process.endEvent (string)\nDeprecated. The parameter doesn\u0026rsquo;t have any code associated with it. process.ended (datetime)\nFilter instances based on ended date. instanceOwner.partyId (int)\nFilter instances based on the instance owner party id. lastChanged (datetime)\nFilter instances based on the last time they where worked on. created (datetime)\nFilter instances based on when they where initially created. visibleAfter (datetime)\nFilter instances based on when they became visible. dueBefore (datetime)\nFilter instances based on their due date. excludeConfirmedBy (string)\nExclude instances already confirmed by a specific stakeholder. Usually the short name of an application owner. isArchived (bool) Filter instances based on whether they are archived. isSoftDeleted (bool) Filter instances based on whether they are soft deleted. isHardDeleted (bool) Filter instances based on whether they are hard deleted. Note that hard deleted instances are only included if an application owner retrieves instances, and the results may include deleted drafts.  Some examples:\nGet all instances of application org/app, that is at process task with id Task_2 (which is Submit, see process definition), and has last changed date greater than 2019-05-01.\nGET {storagePath}/instances?appId=org/app\u0026amp;process.currentTask=Task_2\u0026amp;lastChanged=gt:2019-05-01 Get all instances of all applications of a given application owner org that has ended date greater than 2020-03-10.\nGET {storagePath}/instances?org=org\u0026amp;process.ended=gt:2020-03-10 Get all instances of all applications of a given application owner org that has not already been confirmed completed by org.\nGET {storagePath}/instances?org=org\u0026amp;excludeConfirmedBy=org Get all instances of an application that are at a specific process task e.g. Task_1.\nGET {storagePath}/instances?appId={org}/{app}\u0026amp;process.currentTask={taskId} On query parameters specifying date time you can use the following operators:\n gt: - greater than gte: - greater than or equal to lt: - less than lte: - less than or equal to eq: - equal (can also be blank)  They can be combined to define a range:\ndueBefore=gt:2019-02\u0026amp;dueBefore=lt:2019-03-01 The query returns a result object (page) which includes a collection of instances that matched the query. 100 instances is returned by default. Use size to get more or less instances per page. To get to the next page you have to use the continuationToken present in the next link.\nThe instances endpoint returns a query result object with information about how many total hits totalHits that the query matched and how many objects returned count.\nThe endpoint supports application/json.\nAccept: application/json { \u0026#34;totalHits\u0026#34;: 234, \u0026#34;count\u0026#34;: 50, \u0026#34;self\u0026#34;: \u0026#34;{storagePath}/instances?appId=org/app\u0026amp;size=50\u0026#34;, \u0026#34;next\u0026#34;: \u0026#34;{storagePath}/instances?appId=org/app\u0026amp;size=50\u0026amp;continuationToken=%257b%2522token%2522%253a%2522%252bRID%...\u0026#34; \u0026#34;instances\u0026#34;: [ {...}, {...}, ... ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/intro/",
	"title": "Intro for utviklere",
	"tags": [],
	"description": "Introduksjon",
	"content": "Altinn Studio aka. \u0026ldquo;Tjenester 3.0\u0026rdquo; What are we creating  A app development solution Altinn Studio: The development tool Altinn Platform: The supporting platform Altinn Apps: The solution to host the Apps   What technologies are we using  .NET Core : Backend / API React : Frontend Altinn Studio \u0026amp; App Docker: Apps are created as Docker Containers Kubernetes: The containers are hosted in Kubernetes Azure: We use Azure for Kubernetes hosting   Altinn Studio  Design frontend Define frontend logic Define datamodel for app Define app logic for backend Build \u0026amp; deploy app container Source Control for App files       Altinn Apps  Kubernetes Cluster where apps are hosted One cluster per Organisation   Altinn Platform  Supporting functionality Authentication Authorization Storage Register Profile   Documentation  The different solutions are described in detail on docs Terms Architecture   The End Tilbake\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/",
	"title": "Test av app lokalt",
	"tags": [],
	"description": "Beskrivelse av hvordan test av app lokalt på egen maskin kan gjøres",
	"content": "Dersom man skal skrive en del kode (f.eks. logikk), eller kjapt sjekke hvordan skjema ser ut kan det være nytting å kunne teste endringer uten å måtte deploye hele appen til testmiljø.\nNår appen lages, kommer den med alle nødvendige filer og oppsett til å kunne kjøres som en frittstående applikasjon. Ved å laste ned alle filene knyttet til appen fra repoet til appen, kan man kjøre appen lokalt på egen maskin, og på den måten enkelt teste endringer.\nI testmiljø bruker appen et sett med plattform-tjenester for å kunne hente ut/lagre data osv. Det er opprettet en forenklet versjon av disse tjenestene som kan settes opp og kjøres lokalt, og dette er nødvendig for at appen skal kunne testes lokalt.\nKjøre appen lokalt  Naviger til app repoet i Altinn Studio. Se her for hvordan man navigerer seg dit. Last ned alle filene i repoet   ved å bruke git clone kommandoen (les mer) ved å trykke på nedlastingsikonet (da lastes det ned som en zip-fil)  Se Altinn Studio på Github for informasjon om hvordan man laster ned og kjører den lokale plattformen,og hvordan man kjører appen.\n\rTesting av app API-er lokalt\rHvordan teste app-APIer lokalt.\n\r\rDebugging av app\rNår man kjører appene lokalt kan man debugge ved hjelp av ulike verktøy.\n\r\rTestbrukere lokalt\rVi har definert et lite sett med testbrukere som er tilgjengelig for lokal test.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/maskinporten/",
	"title": "Autentisere med Maskinporten",
	"tags": [],
	"description": "Beskrivelse av hvordan tjenesteeiers systemer kan benytte Maskinporten for å få tilgang til APIer.",
	"content": "Samarbeidsportalen I Min profil i Samarbeidsportalen så har du tilgang til selvbetjening for Maskinporten, og der kan du opprette nye integrasjoner (klienter).\n https://tt02.altinn.no er testmiljø for apper i Altinn, og det er koblet mot Ver 2-miljøet i Maskinporten. https://www.altinn.no er koblet mot Produksjon.  Tilgang som tjenesteeier For å kunne hente data fra Storage i Altinn 3 via API som tjenesteeier, så må man opprette en integrasjon (klient) i Maskinporten, med nødvendige scopes.\nFølgende scopes er opprettet av Altinn, og delegert til tjenesteeier. Disse scopene behøves for å benytte APIene relatert til instanser som tjenesteeier:\naltinn:serviceowner/instances.read altinn:serviceowner/instances.write Klienter med write scope kan bl.a. instansiere apper på vegne av bruker via appens eget API, laste opp data, oppdatere metadata og prosess-status. Klienter med read scope kan kun lese data, metadata og events.\nI de fleste tilfeller så vile en klient for tjenesteeier ha behov for begge scopene.\nOppretting av klient kan gjøres via API eller i Samarbeidsportalen.\nPOST https://integrasjon.difi.no/clients/ { \u0026#34;integration_type\u0026#34;: \u0026#34;maskinporten\u0026#34;, \u0026#34;client_name\u0026#34;: \u0026#34;DIHE testklient for instanser\u0026#34;, \u0026#34;client_type\u0026#34;: \u0026#34;CONFIDENTIAL\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Klient for å hente data fra mine apper\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;altinn:serviceowner/instances.read\u0026#34;, \u0026#34;altinn:serviceowner/instances.write\u0026#34; ], \u0026#34;token_reference\u0026#34;: \u0026#34;SELF_CONTAINED\u0026#34; } Mer informasjon  For mer informasjon, se dokumentasjon for API-konsument fra Maskinporten. Se også scenario for autentication for enda flere detaljer (på engelsk).  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/first-time-setup/",
	"title": "Opprette bruker i Altinn Studio",
	"tags": [],
	"description": "Konfigurer brukeren din i Altinn Studio for første gang.",
	"content": "Lag en bruker i Altinn Studio Din Altinn Studio bruker er personlig for deg og kan knyttes til en eller flere organisasjoner for å samarbeide med andre og få tilgang til eksisterende apper.\n\rVis/skjul innhold\r\rLag bruker med GitHub brukernavn\r\r\r Velg å logge inn på altinn.studio. På “Logg in”-siden, klikk på knappen “Har du en Github konto? Registrer deg med den her”.  Logg inn i GitHub hvis du ikke allerede er det.  Godkjenn at Altinn Studio bruker din GitHub-konto for å logge inn.  Lage en Altinn Studio bruker ved å fylle ut brukernavn, epost, passord, en captcha og klikk på “Fullfør”.\nBrukeren i Altinn Studio vil bli koblet til din GitHub-bruker og du er klar for å begynne arbeide med din første applikasjon.   \r\r \rVis/skjul innhold\r\rLag en bruker med epostadresse (uten GitHub)\r\r\r På “Logg inn”-siden, klikk på knappen “Behov for konto? Registrer deg nå.”  Lage en Altinn Studio bruker ved å fylle ut brukernavn, epostadresse, passord, en captcha og klikk på “Fullfør”. Du er nå klar for å begynne arbeide med din første applikasjon.   \r\r Bli del av en organisasjon Organisasjoner i Altinn Studio er det samme som tjenesteeiere i Altinn. De eier applikasjonene og gjør det mulig for flere innen samme organisasjon å samarbeide.\nFor å bli del av en organisasjon tar du kontakt med administrator for organisasjonen du arbeider for som legger deg til. Hvis du er usikker på hvem som er administrator eller du ikke vet om organisasjonen din er satt opp i Altinn Studio, kan du spørre Altinn Servicedesk om hjelp.\nOpprette en organisasjon Det er Altinn som oppretter organisasjoner i Altinn Studio. For å kunne få en organisasjon i Altinn studio må du ha en avtale med Altinn.\nSend en mail til Altinn Servicedesk med navn på organisasjonen og hvem som skal være administrator for å opprette en ny organisasjon. Det vil kunne ta noen dager å opprette organisasjonen og du vil få en mail så fort det er gjort.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/slide/",
	"title": "Presentasjon",
	"tags": [],
	"description": "En presentasjon om målsettinger og konsepter for Tjenester 3.0",
	"content": "Altinn Studio Aka. \u0026ldquo;Tjenester 3.0\u0026rdquo; Dagens løsning  Produksjonsatt sommeren 2010 Basert på InfoPath og SharePoint 115.000.000 skjema fylt ut 404 aktive innsendingstjenester i 2018   Bakgrunn og mål  Behov har vært kjent lenge POC utviklet i 2015 (men lagt på is grunnet manglende finansiering) Finansiering på Statsbudsjettet 2018 Startet opp igjen våren 2018    Hva er målet med prosjektet?  En modern utviklingsplattform Et effektivt utviklingsverktøy En moderne infrastruktur En plattform for gjenbruk En platform for deling av data og erfaringer   En moderne utviklingsplattform Altinn Studio er en åpen og modern utviklingsplattform\n Versjonering og samarbeid via Git Støtte for distribuert utvikling All programvare som benyttes er åpen kildekode. Også selve 3.0-plattformen. Funksjonalitet i Altinn tilgjengelig via API’er Moderne og populær teknologi, f.eks. React og Visual Studio Code Full selvbetjening Tekniske utviklere kan benytte best-of-breed utvikler-verktøy og teknologi, slik de er vant til.       Et effektivt utviklingsverktøy Altinn Studio tilbyr enkel, effektiv og 100% selvbetjent utvikling og forvaltning av tjenester, også for ikke-teknologer.\n Brukergrensesnitt (GUI) API’er Arbeidsflyt Logikk og dynamikk Datamodellering Konfigurasjon og tilgangsstyring Automatisert testing …   En moderne infrastruktur Altinn Studio (og tjenester som lages der) vil kjøre på en moderne infrastruktur.\n Docker containers for applikasjoner Kubernetes for orkestrering av containers  Dette gir isolering mellom applikasjoner (microservices), enklere skalering og understøtter “DevOps”.\n  Hva kan jeg gjøre med MVP?  Opprette bruker og logge inn i Altinn Studio  Lage (og finne igjen) en tjeneste  Finne tjenester fra andre organisasjoner  Laste opp en datamodell som fungerer i tjenesten (Seres eller OR)  Lage et skjemadesign med drag and drop av elementer (begrenset utvalg av komponenter)  Legge inn tekster/tekstnøkler for tjeneste  Legge inn regler for skjemalogikk (validering, kalkulering, dynamikk)  Bruke API-oppslag i tjenesten (forutsetter Ajax kall kodet i GUI)\n Endre på standardfil for arbeidsflyt  Endre på filer med versjonskontroll  Legge den ferdige tjenesten i test- og produksjonsmiljø  Tjenster 3.0 vs Tjenester 2.0  Skjemaverktøy  Egenutviklet vs InfoPath React vs SharPoint formserver Responsivt vs ikke responsivt   Arbeidsflyt  BPMN vs Custom   Tjenester som API  REST vs SOAP Individuell API vs Generelle   Ressurser  Isolerte vs delte Raskt skalerbar vs lang leveringstid   Dataformat  JSON/XML vs XML   Kontroll på logikk  Full kontroll på når ting skjer i plattformen i motsetning til Infopath   Shipment  Inntil videre kun pull-basert nedlasting av skjemadata.   Videre arbeid i MVP  Fokus på infrastruktur Skyløsninger Sikkerhet Deploy av tjenester Integrasjon med tjenesteeier Understøtte piloter   Detaljer løsning Tre nye løsninger\n Altinn Studio Altinn Apps Altinn Platform   Altinn Studio  Altinn Apps  Altinn Platform  Status Du kan følge utviklingen på Github. Motivasjon Se Archimate arkitekturmodell. The End Tilbake\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/data-elements/tags/",
	"title": "Tags",
	"tags": ["api"],
	"description": "App API for å manipulere stikkord på et data element",
	"content": "Oversikt API\u0026rsquo;et for tags (stikkord) på data elementer har endepunkter for å liste ut tags, legge til en tag, samt sletting av tag.\nbaseSti\n{org}/{appname}/instances/{instanceOwnerPartyId}/{instanceGuid}/data/{dataGuid}/ Hent tags Endepunkt for å laste ned listen med tags som allerede er lagt til på et data element.\nGET baseSti/tags Accept: application/json Legge til tag Endepunkt for å legge til en ny tag.\nPOST baseSti/tags Content-Type: application/json \u0026#34;bokstaver\u0026#34; API kallet må inneholde det nye ordet i anførselstegn. Dette er en JSON representasjon av en enkel tekst og Content-Type skal være application/json. Ordet kan inneholde bokstaver fra alle verdens språk.\nSvaret på et kall vil inneholde listen over alle tags lagt til på data elementet inkludert det nye ordet.\nSlett tag Endepunkt for å fjerne en tag fra et data element.\nDELETE baseSti/tags/{tag} Svaret vil gi http status kode 204 hvis operasjonen lykkes.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/stateless-data-elements/",
	"title": "Tilstandsløse data",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API til å arbeide med dateelementer uten tilstand som ikke er knyttet til en instans.",
	"content": "Overview A stateless data element is a data object based on a data model without relations to an instance, instance owner or a state. The data is never persisted anywhere, and the avilable endpoints simply creates, prefills and/or runs calculations on a data object before returning it to the caller.\nbasePath\n{org}/{app}/v1/data Create new data Endpoint for creating a new stateless dataelement based on a data type.\nPOST basePath?dataType=[dataTypeId] Accept: application/{xml/json} The dataType parameter is required and should reference one of the data types defined on the application that requires app logic.\nIf prefill or calculations are defined for the data type, these will be run on the data element before it is returned.\nResponse A response with the data element in the body will be returned if a valid data type is provided.\nCalculate data Endpoint for running calculations on a data element.\nPUT basePath?dataType=[dataTypeId] Accept: application/{xml/json} The dataType parameter is required and should reference one of the data types defined on the application that requires app logic.\nThe Content-Type is used by Altinn to deserialize the request into a strongly typed object. A request must either be application/json or application/xml. No other Content-Types are supported. Content-Type is not validated against allowed Content-Types on the data type.\nProviding data as application/json Content-Type: application/json { \u0026#34;dataFormatProvider\u0026#34;: \u0026#34;SERES\u0026#34;, \u0026#34;dataFormatId\u0026#34;: \u0026#34;5703\u0026#34;, \u0026#34;dataFormatVersion\u0026#34;: \u0026#34;34553\u0026#34;, \u0026#34;Tjenesteeier\u0026#34;: null, \u0026#34;Kontaktperson\u0026#34;: { \u0026#34;navn\u0026#34;: \u0026#34;Sophie Salt\u0026#34;, \u0026#34;epost\u0026#34;: \u0026#34;1337@altinnstudiotestusers.com\u0026#34;, \u0026#34;telefonnummer\u0026#34;: \u0026#34;90001337\u0026#34; }, \u0026#34;OEnsketBruk\u0026#34;: null } Providing data as application/xml Content-Type: application/xml \u0026lt;BliTjenesteeier_M xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; dataFormatProvider=\u0026#34;SERES\u0026#34; dataFormatId=\u0026#34;5703\u0026#34; dataFormatVersion=\u0026#34;34553\u0026#34;\u0026gt; \u0026lt;Kontaktperson\u0026gt; \u0026lt;navn\u0026gt;Sophie Salt\u0026lt;/navn\u0026gt; \u0026lt;epost\u0026gt;1337@altinnstudiotestusers.com\u0026lt;/epost\u0026gt; \u0026lt;telefonnummer\u0026gt;90001337\u0026lt;/telefonnummer\u0026gt; \u0026lt;/Kontaktperson\u0026gt; \u0026lt;/BliTjenesteeier_M\u0026gt; "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/v2/",
	"title": "v2",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i v2 av Altinn.Platform.Storage.Interface.",
	"content": "2.5.10 Dependency on .NETStandard2.0  The package was changed to depend on .NetStandard2.0 in place of .NetStandard2.1. This should ensure that applications based on .NET Framework 4.7 can use the package.  2.5.9 Expanded the eFormidlingContract with SecurityLevel  eFormidlingContract model was given a new property holding security level information. #5740  2.5.8 Extended eFormidlingContract with additional parameters  eFormidlingContract model was given three new properties to support eFormidling in apps. #5740  2.5.7 Extended eFormidlingContract with a new property: sendAfterTaskId  eFormidlingContract model was given a new property to identify which task should trigger an eFormidling shipment. #5740  2.5.6 Adjustments around PresentationField and texts  Fixes to how PresentationFields were annotated. New class PresentationTexts to hold a list of texts generated by presentation field rules on an instance.  2.5.5 Added PresentationFields to Application  New class PresentationField to represent a data extraction rule. Instance model was given a new property called presentationFields. #5638  2.5.4 Fix the OpenAPI specification of ReadStatus  ReadStatus was changed to be defined as a string. #5637  2.5.3 eFormidling support  Added a new model to support integration with eFormidling.  2.5.2 Dependency on .NETStandard2.1  The package was changed to depend on .NetStandard2.1 in place of .NETCoreApp3.1. The dependency to the Microsoft.AspNetCore.Mvc.NewtonsoftJson package was removed and there is now instead a direct dependency to the Newtonsoft.Json package.  2.5.1 DataElement IsRead is true by default  The value of IsRead is changed to have default value true.  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v3 av app frontend.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i app frontend i v3.0.0\n\r\rHva er nytt?\rOversikt over endringer som ble introdusert i v3 av app frontend.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/picture-component/",
	"title": "Bilde",
	"tags": [],
	"description": "Bruk bilder og illustrasjoner for å fremheve poenger eller illustrere konsepter som er vanskelig å beskrive med tekst",
	"content": "Retningslinjer:  Du må legge til alternative tekster som beskriver bildet. Hvis bilde bare er dekorativt, er det best å ikke inkludere en alternativ tekst. Ikke bruk bilder for bildets skyld, spør det selv om dette er noe som illustrerer et poeng eller øker forståelsen av det du prøver å formidle Test om bildet skalerer bra på forskjellige skjermstørrelser som mobil og nettbrett. Et bilde som ser bra ut på en PC kan fort ta veldig mye plass på en mindre skjerm Unngå bilder med tekst i, dette kan ikke leses av skjermlesere  Hvordan skrive en god alternativ tekst Det er viktig at måten vi skriver alternative tekster er konsekvente. Vi anbefaler derfor at vi følger måten UUtilsynet foreslår.\n aldri start med \u0026ldquo;bilde av\u0026hellip;\u0026rdquo; skriv kort og begynn med det viktigste avslutt ved å si om det er foto, illustrasjon eller grafikk  Eksempel \u0026ldquo;Tre gamle tretraller. Foto.\u0026rdquo;\nEksempel på bruk: \r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/partytype/",
	"title": "Aktørtyper",
	"tags": [],
	"description": "Hvordan sørge for at kun bestemte typer aktører kan bruke en app.",
	"content": "Avgrense tilgang i Altinn Studio designer I Altinn Studio designer finner du mulighet for å styre hvilke aktørtyper som har tilgang til en app i kategorien \u0026ldquo;Lage\u0026rdquo; i toppmenyen, på siden \u0026ldquo;Tilgangsstyring\u0026rdquo; representert ved låshull-ikonet. På denne siden krysser du av for de aktørtypene en app er tilgjengelig for. Hvis ingen (eller alle) aktørtyper er valgt, vil alle ha tilgang. Valget \u0026ldquo;Virksomhet\u0026rdquo; benyttes for tilfeller der det skal rapporteres på hovedenhet.\nSkjermdumpen under viser innstillingene for at alle organisasjonsnummer (både hovedenheter og underenheter) skal kunne bruke appen.\nJustere i applicationmetadata.json Hvis du foretrekker å jobbe i kode, finner du muligheten til å justere hvilke aktørtyper som kan benytte en app i applicationmetadata.json som ligger i mappa App/config i app-repositoryet. Eksempelet under viser samme innstillinger som skjermdumpen.\n\u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: false, \u0026#34;organisation\u0026#34;: true, \u0026#34;person\u0026#34;: false, \u0026#34;subUnit\u0026#34;: true }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/dashboard/",
	"title": "Dashboard i Altinn Studio",
	"tags": [],
	"description": "Hvordan bruke dashboardet i Altinn Studio",
	"content": "Kontekst I dashboardet har man mulighet til å sette hvilken kontekst man ønsker å filtrere applikasjoner på. Dette gjøres ved å klikke på profilikonet til høyre i dashboardet.\nHer vil man få opp en meny over hvilke kontekster man kan filtrere på. Konteksten kan være en organisasjon man er del av, alle, eller seg selv.\nVelger man en gitt organisajon vil det kun være disse appene som er synlig i listen i dashboardet.\nFavoritter Fra dashboardet har man enkel tilgang til sine favoritter. Favorittene i dashboardet gjenspeiler \u0026ldquo;Star\u0026rdquo;-konseptet i Gitea, og markerer du et repository som starred i gitea vil det dukke opp som favoritt i dashboardet. Disse applikasjonene vil alltid ligge øverst i dashboardet og vil være synlige uavhengig av valgt kontekst.\nFor å legge til eller fjerne en favorittmarkering kan man toggle stjerne-ikonet.\nSøk Fra dashboardet kan man gjøre et søk blant de applikasjonene man har tilgang til. Dette gjøres fra søkefeltet, og resultatet vil dukke opp i listen under.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/copy-app/",
	"title": "Kopier app i Altinn Studio",
	"tags": [],
	"description": "Slik oppretter man en kopi av applikasjon i Altinn Studio.",
	"content": "I Altinn Studio har man mulighet til å lage en kopi av en eksisterende applikasjon innad i en organisasjon. Dette gjøres fra dashboardet. Merk: for å ha mulighet til å lage en kopi i en org må du ha rettigheter til å opprette nye repositories. Medlemmer av teamene \u0026ldquo;Owners\u0026rdquo; og \u0026ldquo;Developers\u0026rdquo; har disse rettighetene. Dersom du mangler skrivetilgang må du ta kontakt med personen som har administratorrettigheter for din organisasjon.\n  Klikk på \u0026ldquo;\u0026hellip;\u0026quot;-ikonet til høyre i raden til applikasjonen du ønsker kopiere.\n  Velg \u0026ldquo;Lag kopi\u0026rdquo; fra menyen.\n  Legg inn navnet du ønsker den nye applikasjonen skal ha. Dette navnet brukes til å identifisere appen, og brukes også som navn på repository, og i URL-er og API-er. Navnet bør være kort og beskrivende som for eksempel \u0026ldquo;sykmelding\u0026rdquo; eller \u0026ldquo;lokalvalg-2019\u0026rdquo;. Navnet kan ikke endres etter at appen er publisert.\n  Opprett kopien ved å klikke \u0026ldquo;Lag kopi\u0026rdquo;.\n  Når applikasjonen har blitt kopiert vil du bli sendt til din nye applikasjon.\n  For at den kopierte applikasjonen skal være klar til å brukes trengs det en liten endring i koden. Denne endringen har automatisk blitt lagt inn som en pull request mot repositoriet ditt. For å navigere til repo klikk på profil-ikonet i høyre hjørne og velg \u0026ldquo;Åpne repository\u0026rdquo;.   Naviger så til fanen \u0026ldquo;Pull requests\u0026rdquo; og se at det ligger klar en pull request med navnet \u0026ldquo;Auto-generated: Final changes for cloning app.\u0026rdquo;.   Klikk deg inn på denne og se over at endringene stemmer overens med det nye navnet på applikasjonen din.\n  Om alt ser greit ut så kan endringen merges ved å klikke på \u0026ldquo;Merge pull request\u0026rdquo;.\n  Siste steget som trengs er nå å pulle endringene dine til studio. Naviger så til fanen med den ny appen din og klikk \u0026ldquo;Pull\u0026rdquo; for å hente endringene du nettopp merget.   Voila! Du er nå klar til å utvikle på den kopierte appen.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/create-app/",
	"title": "Opprette app i Altinn Studio",
	"tags": [],
	"description": "Slik oppretter man en ny applikasjon i Altinn Studio.",
	"content": "Altinn Studio brukes til å opprette applikasjoner (apps). En app kan være alt fra enkle skjemaer til større applikasjoner med både API-er og UI, og alt derimellom.\nDu lager en ny app fra dashboardet i Altinn Studio.\n  Klikk på \u0026ldquo;ny app\u0026quot;-knappen i det øvre høyre hjørnet av dashboardet.\n  Velg hvem som skal være eier av appen. Hvis du ikke har tilgang for noen organisasjoner, må du velge deg selv så du lager appen i din sandkasse.\n  Legg inn navnet på appen.\nDette navnet brukes til å identifisere appen, og brukes også som navn på repository, og i URL-er og API-er Det er noen regler knyttet til navngivning av en applikasjon, utover dette bør være kort og beskrivende som for eksempel \u0026ldquo;sykmelding\u0026rdquo; eller \u0026ldquo;lokalvalg-2019\u0026rdquo;.\nNavnet kan ikke endres etter at appen er gått i produksjon.\n Regler for navngivning av applikasjon\n Kan kun inneholde lowercase alfanumeriske tegn og bindestrek (-), Navnet må begynne med en bokstav Navnet må ende med en bokstav eller et tall     Opprett appen ved å klikke \u0026ldquo;Opprett applikasjon\u0026rdquo;.\n  Når apppen er opprettet vil du videresendes til den nyopprettede appen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/migrate-services/",
	"title": "Migrere tjenester",
	"tags": [],
	"description": "Fra Altinn 2 til Altinn 3.",
	"content": "Migrere en eksisterende tjeneste til Altinn 3 Gjør deg kjent med Tjenesteeier-funksjonalitet i Altinn 3.\n Opprett bruker og app i Altinn Studio.\nNår bruker er opprettet kan du be om å bli en del av en organisasjon. Dette for å kunne samarbeide med andre i organisasjonen og ha tilgang til å kjøre deploy av apper. Utvikle app/tjeneste.\nHer finner du veiledninger som er nyttige når man utvikler en app i Altinn Studio. Se også punkt 9. Laste opp datamodell.\nDet er mulig å gjenbruke datamodeller som er basert på InfoPath uten for store endringer. Slik importerer du datamodellen i Altinn Studio. Kombiner UI editor og kodeverktøy.\nAltinn Studio UI editor gjør det enkelt å legge til og flytte skjema komponenter. Kodeverktøy er enklere å bruke når man skal redigere koden. Test lokalt.\nLokalt test miljø er en effektiv måte å teste apper uten å måtte kjøre en delploy. Test app i testmiljø.\nUnder fanen Deploy i Altinn Studio kan du bygge og deploye app. Når Appen er klart kan du logge inn i test miljøet med en testbruker for å kjøre tjenesten. Sette opp App i produksjonsmiljø og bestille om skjema-side.\nFør man setter app i produksjon må man ha tilgang til et produksjonsmiljø. Nyttig informasjon på om skjema-side gjør bruker av tjenesten selvhjulpen og Altinn brukerservice i stand til å hjelpe brukere. Tilrettelegge system for mottak av data.\nDet finnes standardiserte mønstre basert på REST-API for å sende og motta data fra/til dine interne systemer. Autentisering skjer med Maskinporten og du laster ned data ved pull fra database, og laster opp data direkte mot API i den enkelte applikasjon. Vår referanseapplikasjon Altinn CLI​ viser disse mønstrene og kan brukes for å komme i gang. Konvertere fra tjenster med Altinn2-converter.\nAltinn2-converter er et komandolinje basert verktøy for å konvertere Altinn 2 tjenester til Altinn 3 apps. Dette verktøyet har status som Proof of concept (POC) og kan derfor mangle en del funksjonalitet.  Lag en skisse av skjema For å migrere en utvalgt tjeneste kan det være nyttig å lage seg en skisse av tjenesten slik at man gjør seg kjent med designelementer i Altinn 3, og slik at man har en referanse å se til når man utvikler løsningen. Slik gjør du dette.\n\rVis/skjul innhold\r\rLage en skisse av skjema i Figma.\r\r\r Gå inn på nettsiden https://www.figma.com/ og lag deg en bruker. Figma kan installeres lokalt eller brukes i din nettleser. Altinn har et åpent design kit for eksterne og det finner du her. Gå inn på denne siden for å få mer informasjon om hvordan du kan komme i gang med Figma.  \r\r "
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/process/",
	"title": "Prosess",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API endepunkter for å lede en instans gjennom prosessen som er definert.",
	"content": "Overview All apps have a process definition that specifies start events, end events, tasks and the allowed flows (transitions) between these. A process is started by the application, which selects a start event to start and follows the sequence flow to the first task and creates a current task object to holde the process state.\nA process is represented by an process modell in BPMN/XML notation. Each task has an unique id, which is used to refer to the task in the api.\nProcess model Get the application\u0026rsquo;s process model.\nGET {appPath}/process Returns the bpmn file defining the process.\n\u0026lt;bpmn2:process id=\u0026#34;Process_1\u0026#34; isExecutable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;bpmn2:startEvent id=\u0026#34;StartEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn2:outgoing\u0026gt;Flow_1\u0026lt;/bpmn2:outgoing\u0026gt; \u0026lt;/bpmn2:startEvent\u0026gt; \u0026lt;bpmn2:task id=\u0026#34;Task_1\u0026#34; name=\u0026#34;Utfylling\u0026#34; altinn:tasktype=\u0026#34;data\u0026#34;\u0026gt;  \u0026lt;bpmn2:incoming\u0026gt;Flow_1\u0026lt;/bpmn2:incoming\u0026gt; \u0026lt;bpmn2:outgoing\u0026gt;Flow_2\u0026lt;/bpmn2:outgoing\u0026gt; \u0026lt;/bpmn2:task\u0026gt; \u0026lt;bpmn2:endEvent id=\u0026#34;EndEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn2:incoming\u0026gt;Flow_2\u0026lt;/bpmn2:incoming\u0026gt; \u0026lt;/bpmn2:endEvent\u0026gt; \u0026lt;bpmn2:sequenceFlow id=\u0026#34;Flow_1\u0026#34; sourceRef=\u0026#34;StartEvent_1\u0026#34; targetRef=\u0026#34;data_1\u0026#34; /\u0026gt; \u0026lt;bpmn2:sequenceFlow id=\u0026#34;Flow_2\u0026#34; sourceRef=\u0026#34;Task_1\u0026#34; targetRef=\u0026#34;EndEvent_1\u0026#34; /\u0026gt; \u0026lt;/bpmn2:process\u0026gt; Altinn specific task types Application developers can in their BPMN Definition specify some altinn specific task types, see altinn:tasktype, which signify the behaviour of the task. So far we have defined the following:\n data - user is asked to fill inn one or more data elements, e.g. upload data or fill in forms submit - user is asked if he should submit the information which has been filled in on previous tasks payment - user is asked to pay a specific amount signing - user is asked to provide a digital signature external - task is handled by an external entity, user must wait until they have completed the task.  Get process state of a specific instance GET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process For an ongoing process this process state can look like the json below. It indicates that the process was started at a given date time and that it\u0026rsquo;s current task is Task_1. The flow number indicates the sequence of process events/tasks that occurs during the execution of the process. Notice that same task can be visited multiple times in a process if there is a sequence flow that allows that.\n{ \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-10T32:22.00Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Fyll ut\u0026#34;, \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;validated\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2019-10-04T12:00.00Z\u0026#34;, \u0026#34;canCompleteTask\u0026#34;: true } } For an ended process the following will be returned:\n{ \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-10T14:01:22.034Z\u0026#34;, \u0026#34;endEvent\u0026#34;: \u0026#34;EndEvent_1\u0026#34; } Process events The system will generate a number of process related events, which can be found in the instances event history.\n Start Event StartTask Event EndTask Event End Event  Start Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:Start\u0026#34;, \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34; }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-10T14:01:22.034Z\u0026#34;, } StartTask Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:StartTask\u0026#34;,  \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-01T13:22.01Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Fyll ut MVA rapport\u0026#34;, \u0026#34;altinnTaskId\u0026#34;: \u0026#34;data\u0026#34; } }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-01T13:22.01Z\u0026#34;, } EndTask Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:EndTask\u0026#34;,  \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2017-10-01T13:22.00Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;altinnTaskId\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34; } }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34;, } End Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:EndEvent\u0026#34;,  \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2017-10-01T13:22.00Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-05T08:15:23.544Z\u0026#34;, \u0026#34;endEvent\u0026#34;: \u0026#34;EndEvent_1\u0026#34; }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-05T08:15:23.544Z\u0026#34;, } Get process history of a specific instance Based on the process events the history of the instance\u0026rsquo;s process is generated. The following illustrates an ended process:\nGET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/history \u0026#34;processHistory\u0026#34;: [ { \u0026#34;eventType\u0026#34;: \u0026#34;process_StartEvent\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;occured\u0026#34;: \u0026#34;2020-01-21T13:49:09.3109169Z\u0026#34; }, { \u0026#34;eventType\u0026#34;: \u0026#34;process_StartTask\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;started\u0026#34;: \u0026#34;2020-01-21T13:49:09.4264322Z\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2020-01-21T13:49:39.66609Z\u0026#34; }, { \u0026#34;eventType\u0026#34;: \u0026#34;process_EndEvent\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;EndEvent_1\u0026#34;, \u0026#34;occured\u0026#34;: \u0026#34;2020-01-21T13:49:39.7681248Z\u0026#34; } ] } Start Process To start a process one can post start to the process endpoint.\nPOST {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/start[?startEvent=StartEvent_1] This will start the process and move the process state to the first task from the given start. If process has more than one start event, then the client has to chose which one to start with the startEvent query parameter.\nComplete and move to next task The process logic attempts to finish the current task and then moves the process forward to the next task in the flow. The cannot always select the next task, especially when more than one tasks can be chosen. In this case the client must chose which process element id to select.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next[?id=Task_2] Complete the process The complete process method will attempt to complete the process for an instance. Hence, the app will move the process from one task to the next until it reaches an valid end state.\nIf a task\u0026rsquo;s exit condition is not met, the process will be stopped in the last valid task. And the user must manually fix the problem and complete the process.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/completeProcess Get the next tasks in a process Returns an list of the next tasks/events that can be reached from the current task.\nGET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next Start a task If you are at a specific task and want to start the next task you can try to put next to the process endpoint. The process controller then tries to close the current task and start the wanted task. Updates process state accordingly. If exit condition of current task is not met, an error will be returned. If the task is not directly reachable by the flow, an error will be returned.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next?id=Task_2 "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/apps/",
	"title": "Apps infrastruktur tilganger",
	"tags": [],
	"description": "Hvordan bestille tilganger til Altinn Apps infrastruktur.",
	"content": "Tilgang til logger og hemmeligheter Det er definert to forskjellige typer roller for tilgang i driftsmiljøene i Altinn Apps.\n Developer gir tilgang til Application Insights der applikasjonslogger samles for tjenesteeier sine applikasjoner i miljøet. Operations gir tilgang til Key Vault for å laste opp hemmeligheter som sertifikater, passord og api-nøkler.  Disse rollene er videre delt opp i tilgang til test (TT02) og produksjon (prod). En bruker kan tildeles en eller flere roller.\nTjenesteeiere kan bestille følgende tilganger for sine ressurser i miljøene TT02 og produksjon:\n Test Developer Test Operations Prod Developer Prod Operations  For å få aksess til disse rollene må autoriserte bestillere hos Tjenesteeier, bestille dette på vår Selvbetjeningsportal. Velg Support, så ny sak. Her skal du finne skjemaet Apps under menyvalget Bestilling/tilganger.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/datafields/",
	"title": "Datafelter på instansobjektet",
	"tags": [],
	"description": "Konfigurasjon av datafelter for app.",
	"content": "I noen tilfeller kan det være nyttig å legge ekstra informasjon på instansobjektet f. eks. for å kunne basere ruting av instans til rett system i bakkant hos tjenesteeier.\nDette kan gjøres på to måter, ved konfigurasjon eller manuelt. Ved konfigurasjon vil systemet ekstrahere data fra skjemafeltene og legge disse på instansobjektet. Man er da begrenset til skjemafelter, men slipper å programmere dette selv. Hvis man velger å gjøre det manuelt har man frihet til å legge på de dataene man selv ønsker f. eks. fra eksterne apier, kalkuleringer, faste strenger etc.\nDet er også mulig å benyttes seg av begge metoder så lenge man benytter seg av forskjellige id\u0026rsquo;er på datafeltene. De konfigurerte verdiene vil da flettes sammen med de manuelle på instansen.\nDatafelter er på mange måter tilsvarende presentasjonsfelter. Men der hvor bruken av presentasjonsfelter er forhåndsbestemt (benyttes i meldingsboksen til Altinn), er bruken av datafelter opp til den enkelte applikasjonseier.\nKonfigurasjon Konfigurasjon av datafelter gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn dataFields med følgende underfelter\n   Navn Beskrivelse     id Id på datafeltet. Benyttes til å identifisere feltet når den er lagret på instansen.   path Datamodell path til skjemafeltet. Denne verdien er den samme som bindes til en komponent i layoutfilen til appen.   dataTypeId Id på datamodellen som verdien skal hentes fra.    Konfigurasjonen til en app med to definerte datafelter vil se slik ut:\n\u0026#34;dataFields\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;AnsettelseAntAar\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.Arbeidsforhold-grp-8856.AnsattAar-datadef-33267.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;Navn\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.OpplysningerOmArbeidstakeren-grp-8855.AnsattNavn-datadef-1223.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }] Resultatet vil være en liste på instansobjektet med verdier fra de konfigurerte feltete:\n\u0026#34;dataValues\u0026#34;: { \u0026#34;AnsettelseAntAar\u0026#34;: 10, \u0026#34;Navn\u0026#34;: \u0026#34;Ola Nordmann\u0026#34; } Legg merke til at det på instansobjektet heter dataValues mens når det konfigureres heter dataFields, det er fordi dataValueser resultatet av konfigureringen som gjøres på dataFields.\nManuelt For å legge til dataverdier manuelt benyttes metoden UpdateDataValues fra IInstance interfacet. Det er den samme metoden som kalles når dataverdier populeres fra konfigurasjon og den sørger for å flette sammen verdiene til en liste.\nMerk at det er applikasjonsutvikler sitt ansvar å sørge for unike id'er hvis man kombinerer dataverdier fra konfgiurasjon og manuelt.\rHar man ikke unike id'er vil verdier overskrives, og man har ingen garanti for hvilken som blir lagret på instansen.\r\rEksemplet under viser hvordan man kan sette datavedier manuelt. I dette tilfellet gjøres det ved å gjøre legge inn kode i RunProcessTaskEnd i App.cs som kjører når en task avsluttes.\npublic override async Task RunProcessTaskEnd(string taskId, Instance instance) { var customDataValues = new DataValues() { Values = new Dictionary\u0026lt;string, string\u0026gt;() { { \u0026#34;customKey\u0026#34;, \u0026#34;customValue\u0026#34; } } }; var (instanceOwnerPartyId, instanceGuid) = InstanceHelper.DeconstructInstanceIdFromUrl(_httpContextAccessor.HttpContext.Request.Path.Value); await _instanceService.UpdateDataValues(instanceOwnerPartyId, instanceGuid, customDataValues); await Task.CompletedTask; } Man bør også tenke gjennom når man trenger disse verdiene på instansobjektet slik at man ikke gjør unødvendige api kall og dermed får en dårligere ytelse på applikasjonen.\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/deploy/",
	"title": "Test app i testmiljø",
	"tags": [],
	"description": "Beskrivelse av hvordan test i testmiljø kan utføres.",
	"content": "Klargjøring av app og deploy til testmiljø gjøres fra Deploy-fanen i Altinn Studio.\nBygge app Før en app kan deployes til testmiljø, må alle nødvendige filer samles sammen i en pakke som kan deplpoyes. Dette gjøres ved å bygge appen.\nMerk at det er filene fra app-repoet som benyttes i bygget. Dersom en har gjort endringer på en app i Altinn Studio så må disse sendes til repoet for at endringene skal bli med i bygg-pakken.\rDette gjøres ved å velge _Push_ fra _Lage_-fanen i Altinn Studio.\r\rNår en app er klar til test, kan den bygges ved å gå til Deploy-fanen i Altinn Studio (inne på den appen som skal deployes).\nPå høyre side vises et panel for å bygge appen.\nMerk at det kun er mulig å bygge ny versjon av appen dersom det faktisk er gjort endringer i appen. Dersom det er gjort endringer og det ikke er mulig å bygge ny versjon, pass på at endringene har blitt sendt til app repoet.\r\r Skriv inn versjonsnummer for den versjonen av appen som skal bygges. Må være unikt (altså ikke brukt tidligere for denne appen). Skriv inn beskrivelse for denne versjonen av app\u0026rsquo;en. Trykk på Bygg versjon for å starte bygget.  Status for bygget vises under Tidligere bygg av applikasjonen. Når status er grønn, er denne versjonen av app\u0026rsquo;en klar til å bli deployet til testmiljø.\nDeploy av app til testmiljø Når en app er bygget ferdig kan den deployes til testmiljø. Dette gjøres fra Deploy-fanen. Der vises en oversikt over tilgjengelige miljø, i tilegg til en oversikt over hvilke versjoner av appen som er i de forskjellige miljøene.\n Velg versjonen av appen som skal deployes fra nedtrekkslisten som ligger under det aktuelle miljøet. Trykk på Deploy ny versjon.  Valgt versjon vil da deployes til valgt miljø. Her er det mulig å deploye ny versjon, eller rulle tilbake til en eldre versjon om det er ønsket.\nTeste app i testmiljø Logg inn i testmiljø med testbruker. Bruk lenken som vises over hvert miljø i Deploy-fanen for å komme til ønsket testmiljø og starte ny instans av appen.\nAlle instanser vil være synlig i meldingsboks/arkiv til valgt aktør, på samme måte som dagens tjenester (som er basert på Altinn II).\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/id-porten/",
	"title": "Autentisere med ID-porten",
	"tags": [],
	"description": "Beskrivelse av hvordan systemer kan benytte ID-porten for å få tilgang til APIer i Altinn 3.",
	"content": "Systemer for sluttbrukere kan autentisere brukere via ID-porten. Dette for å kunne benytte API fra applikasjoner kjørende i Altinn Apps og enkelte funksjoner i Altinn Platform på vegne av sluttbruker.\nDet er i hoveddsak to typer systemer hvor dette er aktuelt. Dette er webbaserte løsninger og tykke klienter.\nFelles for begge løsninger er at sluttbruker vil logge inn via nettleser i ID-porten med den autentiseringsmekanismen de ønsker.\nDette er for eksempel:\n Min-ID BankID på mobil BankId  Systemet må forespøre et sett med scopes i ID-porten som sluttbruker må akseptere at systemet kan utføre på vegne av sluttbruker.\nDet er disse scopene som tildels avgrenser hva systemet kan utføre på vegne av sluttbruker.\nScopene som er definert og relevant for Altinn 3 er:\n altinn:instances.meta - Se oversikt over innboks og arkiv i Altinn altinn:instances.read - Lese innholdet i innboks og arkiv i Altinn for alle elementer som sluttbruker er autorisert for altinn:instances.write - Fylle ut, signere og sende inn skjema i Altinn for alle elementer sluttbruker er autorisert for altinn:lookup - Benytte innsynstjenester i Altinn altinn:reportees - Se hvem du kan representere i Altinn  Bildet nedenfor viser hvordan sluttbruker må bekrefte tilgangen.\nFor detaljer om scope og opplisting av alle scopes tilgjengelig se dokumentasjon fra ID-porten.\nDet er disse scopene som avgjør hva sluttbruker kan utføre. Bildet nedenfor viser hvordan sluttbruker må bekrefte tilgangen.\nNår pålogging er gjennomført vil systemet ha tilgang til et ID-token, refresh token og et access token.\nDette access tokenet har begrenset levetid, men kan fornyes med ved hjelp av refresh token.\nWeb baserte systemer Webbaserte systemer består av løsninger med en webbasert frontend som kjører i nettleser, samt serverside kode.\nSe detaljer hos ID-porten.\nTykke klienter Med tykke klienter mener vi applikasjoner som installeres og kjøres lokalt på en datamaskin og ikke i nettleser.\nDisse må likevel benytte seg av nettleser for å logge inn.\nSe detaljer hos ID porten.\nVeksling av access token til Altinn token Access-tokenet som utstedes fra ID-porten må veksles inn i et Altinn-token før det kan benyttes mot Altinns API\u0026rsquo;er.\nDette Altinn-tokenet vil ha samme levetid som access-tokenet.\nFlytdiagrammet nedenfor viser hvordan tokenet veksles inn.\nSe detaljer i Altinns API dokumentasjon.\nSluttbrukere har i Altinn mulighet til å få oversikt over alle systemer og hvilke tilganger de har.\nPå denne måten kan man trekke langvarige tilganger. Systemet vil da bli avvist neste gang det prøver å refresehe access-token.\nBildet nedenfor viser hvordan dette vil bli i Altinn (ikke satt i produksjon enda).\nEt system som har fått tilgang til et token fra ID-porten vil kunne utføre handlinger som bruker er autorisert kun begrenset av bruksområdet til scope. Det betyr at hvis system har fått scope for innsending av skjema så vil systemet kunne sende inn alle skjema for alle avgivere som sluttbruker er autorisert for. Det er derfor viktig at sluttbruker kan stole på systemet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/instance-events/",
	"title": "Instance events",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Plattform API for å jobbe med instans-hendelser.",
	"content": "Instance events All instance events, e.g. creation, read, save, change process state, \u0026hellip;\nGET {storagePath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/events Example of event data.\n{ \u0026#34;id\u0026#34;:\u0026#34;6dff32bc-0928-4ae8-937c-b362d6941c89\u0026#34;, \u0026#34;instanceId\u0026#34;: \u0026#34;60238/5c6b1a71-2e1f-447a-ae2f-d1807dcffbfb\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;deleted\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-05-02T13:08:21.981476Z\u0026#34;, \u0026#34;instanceOwnerPartyId\u0026#34;: \u0026#34;60238\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;userId\u0026#34;: 338829, \u0026#34;authenticationLevel\u0026#34;: 1, \u0026#34;enduserSystemId\u0026#34;: 2 }, \u0026#34;process\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-05-01T12:45:01.3233Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;Start_22\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;elementId\u0026#34;: \u0026#34;Task_2\u0026#34; } } } Application events (for application owners)  WARNING: This section will be redesigned\n Selected instance events. Created, first read, change process state. Optinally specified by application developer.\nEvents can be queried. May be piped.\nGET {storagePath}/applications/org/app/events?created=gte:2019-03-30\u0026amp;process.currentTask=Task_2 "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/",
	"title": "Navigasjon i Altinn Studio",
	"tags": [],
	"description": "Slik navigerer du mellom de ulike delene av Altinn Studio.",
	"content": "Som bruker av Altinn Studio kan du bruke ulike verktøy, avhengig av kompetanse, preferanser og kompleksiteten på det du skal utvikle. Hvordan du navigerer er ulikt mellom verktøyene.\n\rDesigner\rSlik navigerer du i Altinn Studio Designer.\n\r\rRepos\rSlik navigerer du i Altinn Studio Repos.\n\r\rCode\rSlik navigerer du i Altinn Studio Code.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/messagebox/presentationfields/",
	"title": "Presentasjonsfelter",
	"tags": [],
	"description": "Konfigurasjon av presentasjonsfelter for app.",
	"content": "I noen tilfeller kan det være nyttig med presentasjonsfelter for å enklere kunne skille mellom flere instanser av samme applikasjon.\nVed å konfigurere presentasjonsfelter på en applikasjon vil man hente ut verdier fra skjemadataene og legge dette på instansobjektet. Disse verdiene benyttes i meldingsboksen i Altinn til å berrike tittelen til instansen med dataverdiene.\nKonfigurasjon Konfigurasjon av presentasjonsfelter gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn presentationField med følgende underfelter\n   Navn Beskrivelse     id Id på presentasjonsfeltet. Benyttes til å identifisere presentasjonsteksten når den er lagret på instansen.   path Datamodell path til presentasjonsfeltet. Denne verdien er den samme som bindes til en komponent i layoutfilen til appen.   dataTypeId Id på datamodellen som verdien skal hentes fra.    Konfigurasjonen til en app med to definerte presentasjonsfelter vil se slik ut:\n\u0026#34;presentationFields\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Ansettelse\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.Arbeidsforhold-grp-8856.AnsattAar-datadef-33267.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;Navn\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.OpplysningerOmArbeidstakeren-grp-8855.AnsattNavn-datadef-1223.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }] Resultat Resultatet i meldingsboksen vil være tittel på applikasjonen med påfølgende presentasjonstekster i en kommaseparert liste.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/prefill/",
	"title": "Preutfylling av data (prefill)",
	"tags": [],
	"description": "Hvordan konfigurere prefill for en app.",
	"content": "Altinn tilbyr i dag tre fremgangsmåter for å preutfylle data i en app for en sluttbruker. Disse metodene kan kombineres fritt for å oppnå ønsket resultat\nPrefill fra nasjonale register og brukerprofil Altinn apps støtter prefill med data fra Enhetsregisteret, Folkeregisteret og brukerprofil i Altinn.\nVed å følge beskrivelsen nedenfor vil man under instansiering av et skjema preutfylle datamodellen med de definerte verdiene hentet fra Altinns database.\nOppsett av prefill i applikasjons repository Opprett en ny json-fil i app repoet under App/models. Navnet på filen skal inneholde navnet på datamodellen og ha postfix \u0026ldquo;.prefill.json\u0026rdquo;. Dersom datamodellen din heter appModel skal du nå kunne finne disse tre filene i mappen: appModel.metadata.json, appModel.schema.json, appModel.prefill.json\nLim inn innholdet nedenfor i filen.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/prefill/prefill.schema.v1.json\u0026#34;, \u0026#34;allowOverwrite\u0026#34;: true, \u0026#34;ER\u0026#34;: { }, \u0026#34;DSF\u0026#34;: { }, \u0026#34;UserProfile\u0026#34;: { } } Konfigurering av prefill.json   $schema peker på json schema definisjonen til filen. Nåværende versjon er v1.\nVisual Studio Code vil pga. denne validere og tilby intellisense/autocomplete når du editerer filen lokalt.\n  allowOverwrite avgjør om prefill definert i denne filen kan overskrive et felt i datamodellen dersom det allerede har en verdi.\n  ER her legger man inn felter fra datamodellen som skal preutfylles med data fra enhetsregisteret. Felt som preutfylles med ER-data vil kun få en verdi dersom man instansierer på vegne av en organisasjon. Instansiering vil feile dersom man forsøker å preutfylle ER-data, men ikke har en organisasjon tilgjengelig.\n  Eksempelet nedenfor vil populere feltet Datamodell.Organisasjon.Organisasjonsnummer med organisasjonsnummeret hentet fra enhetsregisteret.\n\u0026#34;ER\u0026#34;: { \u0026#34;OrgNumber\u0026#34;:\u0026#34;Datamodell.Organisasjon.Organisasjonsnummer\u0026#34; }  DSF her legger man inn felter fra datamodellen som skal preutfylles med data fra folkeregistret. Feltet som preutfylles med DSF-data vil kun få en verdi dersom man instansierer på vegne av en person. Instansiering vil feile dersom man forsøker å preutfylle DSF-data, men ikke har en person tilgjengelig.  Eksempelet nedenfor vil populere feltet Datamodell.Person.Nummer med telefonnummer henter fra folkeregistret.\n\u0026#34;DSF\u0026#34;: { \u0026#34;TelephoneNumber\u0026#34;:\u0026#34;Datamodell.Person.Nummer\u0026#34; }  UserProfile her legger man inn telter fra datamodellen som skal preutfylles med data fra brukerens profil i Altinn. Merk at det er den innloggede brukeren om instansierer man henter ut data for.  Eksempelet nedenfor vil populere feltet _Datamodell.Bruker.Epost med epost hentet fra brukerens profil i Altinn.\n\u0026#34;UserProfile\u0026#34;: { \u0026#34;Email\u0026#34;:\u0026#34;Datamodell.Bruker.Epost\u0026#34; } Tilgjengelige prefill verdier JSON-schema definisjonen av prefill-filen er også tilgjengelig her.\nBruken av et schema gjør at editorer, f.eks. Visual Studio Code, kan validere og tilby intellisense for raskere editering.\nFolkeregisteret Personedataen som eksponeres er den tilknyttet personen som skjemaet instansieres på vegne av. Dersom Ola Nordman instansierer et skjema på vegne av Kari Nordmann vil det være Kari sin data som eksponeres. Tilgjengelige verdier for prefill inkluderer:\n SSN Name FirstName MiddleName LastName TelephoneNumber MobileNumber MailingAddress MailingPostalCode MailingPostalCity AddressMunicipalNumber AddressMunicipalName AddressStreetName AddressHouseNumber AddressHouseLetter AddressPostalCode AddressCity  Enhetsregisteret Enheten som eksponeres er den tilknyttet organisasjons som et skjema blir instansiert på vegne av. Tilgjengelige verdier for prefill inkluderer:\n OrgNumber Name UnitType TelephoneNumber MobileNumber FaxNumber EMailAddress InternetAddress MailingAddress MailingPostalCode MailingPostalCity BusinessAddress BusinessPostalCode BusinessPostalCity  Brukerprofil Brukerprofilen som eksponeres er profilen til den som instansierer tjenesten. Dersom Ola Nordmann instansierer et skjema på vegne av Kari Nordmann vil dataen som hentes ut herfra være knyttet til Ola. For objektene Party.Organization og Party.Person vil man finne igjen samme feltene som man ser i ER og DSF-prefill. Merk at Party.Organization vil være null om brukeren er logget inn som en privatperson, og tilsvarende for Party.Person om man er logget inn med en virksomhetsbruker. Preutfyllingen vil feile om objektet man preutfyller fra ikke finnes, så om man ønsker å dynamisk preutfylle basert på disse verdiene må dette settes opp som egendefinert prefill.. Tilgjengelige verdier for prefill inkluderer:\n UserId UserName PhoneNumber Email PartyId Party.PartyId Party.PartyTypeName Party.OrgNumber Party.SSN Party.UnitType Party.Name Party.isDeleted Party.OnlyHierarchyElementWithNoAccess Party.Person Party.Organization Party.ChildParties UserType ProfileSettingPreference.Language ProfileSettingPreference.PreSelectedPartyId ProfileSettingsPreference.DoNotPromptForParty  Egendefinert prefill Altinn apps muliggjør prefill av en instans med egendefinert data, det være seg resultet fra et API-kall, beregninger gjort under instansiering, eller annen logikk. Dette implementeres i metoden DataCreation i filen InstansiationHandler.cs som finnes i applikasjonsrepoet under App/logic.\nEksempelet nedenfor populerer feltet Bruker.FulltNavn i modellen Datamodell med verdien \u0026ldquo;Test Testesen\u0026rdquo;.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; model.Bruker.FulltNavn = \u0026#34;Test Testesen\u0026#34;;  } } Bytt ut Datamodell med navnet på C# klassen som er blitt generert basert på xsd-en som ble lastet opp i Altinn Studio. Dersom du bruker en egnet kodeeditor vil du kunne definere felter som skal populeres ved bruk av intellisense.\nVær oppmerksom på at dersom du har komplekse typer i modellen din, må disse instansieres før man kan tilegne en verdi til ett av typens underelementer. Se eksempel nedenfor der vi legger til grunn at \u0026lsquo;Bruker\u0026rsquo; og \u0026lsquo;Name\u0026rsquo; er egne C# klasser.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; Bruker b = new Bruker(); b.Navn = new Name(); b.Navn.FulltNavn = \u0026#34;Test Testesen\u0026#34;; } } Instansiering med prefill Altinn apper støtter instansiering med prefill. Skjemadataen legges ved i en multipart i instansieringsrequesten som sendes til appen. Nedenfor ser du et eksempel på en request for å instansiere en app med prefill for partyId 12345.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; Body: --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;PartyId\u0026#34; : \u0026#34;12345\u0026#34;  } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;Endring-av-navn\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;1533\u0026#34; spesifikasjonsnummer=\u0026#34;11172\u0026#34; blankettnummer=\u0026#34;RF-1453\u0026#34; tittel=\u0026#34;Endring av navn\u0026#34; gruppeid=\u0026#34;9308\u0026#34;\u0026gt; \u0026lt;Innledning-grp-9309 gruppeid=\u0026#34;9309\u0026#34;\u0026gt; \u0026lt;NavneendringenGjelderFor-grp-9310 gruppeid=\u0026#34;9310\u0026#34;\u0026gt; \u0026lt;SubjektFornavnFolkeregistrert-datadef-34730 orid=\u0026#34;34730\u0026#34;\u0026gt;Ola Nordmann\u0026lt;/SubjektFornavnFolkeregistrert-datadef-34730\u0026gt; \u0026lt;/NavneendringenGjelderFor-grp-9310\u0026gt; \u0026lt;Kontaktinformasjon-grp-9311 gruppeid=\u0026#34;9311\u0026#34;\u0026gt; \u0026lt;MelderFultnavn orid=\u0026#34;34735\u0026#34;\u0026gt;LANGØY MADS\u0026lt;/MelderFultnavn\u0026gt; \u0026lt;/Kontaktinformasjon-grp-9311\u0026gt; \u0026lt;/Innledning-grp-9309\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/",
	"title": "Definere applikasjonsprosess",
	"tags": [],
	"description": "Hvordan definere prosessen til en app.",
	"content": "En applikasjon har definert en prosess som styrer flyten. Prosessen er definert som BPMN 2.0.\nStøttede prosess-task-typer Nåværende applikasjonsmal støtter følgende tasks.\n Data (Data) (Tilsvarer utfyllingssteg i Altinn II) Bekreftelse (Confirmation) Feedback  Fremtidige prosess-tasker (tentativ)  Signering (Signing) Betaling (Payment) Parallellsignering (Paralell Signing) Brukerstyrt signering (User Controlled Signing) Ekstern validering (External Validation)  Endre prosessen For å endre på prosessen kan du manuelt redigere BPMN-filen med en valgfri XML- eller BPMN-editor. Den ligger lagret i app-repoet som App/config/process/process.bpmn.\n\rAutomatisk sletting\rEn applikasjon kan konfigureres til å slette alle spor når prosessen er slutt.\n\r\rMelding\rHvordan sette opp en melding i Altinn Studio.\n\r\rTilpasse visninger av steg\rHvordan tilpasse visninger i forskjellige steg av en prosess.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/repos/",
	"title": "Repos",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Repos.",
	"content": "Repos er verktøyet der appene er lagret som Git repositoryer, og kan bli funnet på https://altinn.studio/repos.\nHovedmeny Hovedmenyen øverst inneholder disse elementene:\n Altinn-logoen - tilbake til Altinn Studio-dashboardet. Dashboard - Lister ut dine aktiviteter og de repositoryene og organisasjonene du har tilgang til. Du kan også se dashboard for den enkelte organisasjonen. Issues - Lister ut åpne og lukkede issues som er relevant for deg. Pull requests - Lister ut åpne og lukkede pull requests som er relevant for deg. Utforsk - Gir deg tilgang til å se alle repositoryer, brukere og organisasjoner  Navigere innad i et repository Når du har navigert til et repository dukker det opp et nytt sett menyvalg som er relevant for repositoryet.\n Kode - innholdet, alle filer appen består av Issues - \u0026ldquo;saker\u0026rdquo; for repositoryet Pull Requests - for repositoryet Releases - opprettet for repositoryet Aktivitet - hva har skjedd i repositoryet  Hvis du vil til Designer for det aktuelle repositoryet, er det et valg for dette i toppmenyen:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/messagebox/hide_instances/",
	"title": "Skjule instanser",
	"tags": [],
	"description": "Konfiurasjon for å skjule instanser fra meldingsboksen.",
	"content": "For applikasjoner med en kompleks appflyt kan det være nyttig å skjule instanser fra meldingsboksen under deler av prosessen eller for hele prosessen.\nKonfigurasjon Konfigurasjonen har tilbakevirkende kraft på tidligere opprettede instanser.\r\rKonfigurasjon av skjuling fra meldingsboks gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn messageBoxConfiguration med følgende underfeltet hideSettings.\nHideSettings kan igjen bestå av én av to properties\n   Navn Beskrivelse     hideOnTask En liste med tasker der instanser skal skjules fra meldingsboksen.   hideAlways En boolean som indikerer om instansen alltid skal skjules fra meldingsboksen.    Eksempler Konfigurasjonen til en app der instanser skal skjules på Task_1 og Task_3, men være synlig på alle andre prosess-steg:\n\u0026#34;messageBoxConfig\u0026#34;: { \u0026#34;hideSettings\u0026#34;: { \u0026#34;hideOnTask\u0026#34;:[\u0026#34;Task_1\u0026#34;, \u0026#34;Task_3\u0026#34;] } } Konfigurasjonen til en app der instanser aldri skal vises i meldingsboksen.\n\u0026#34;messageBoxConfig\u0026#34;: { \u0026#34;hideSettings\u0026#34;: { \u0026#34;hideAlways\u0026#34;:true } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/studio/",
	"title": "Altinn Studio tilganger",
	"tags": [],
	"description": "Hvordan konfigurere tilganger for team i Altinn Studio.",
	"content": "Tilgangsstyring for organisasjonen Som eier av en organisasjon i Altinn Studio har man mulighet til å konfigurere tilgangene til de øvrige brukerne knyttet til organisasjonen. Dette gjøres via Gitea på følgende lenke: https://altinn.studio/repos/org/{organisasjonens kortnavn}/teams/\nDet er definert fire standard team som legger føringer for hva en bruker har tillatelse til å gjøre innad i en organisasjon i Altinn Studio. Ved behov kan man som eier kan man legge til/fjerne brukere i team, opprette nye team og endre konfigurasjon på eksisterende team.\nOwners Beskrivelse Medlemmer i dette teamet kan tenkes på som administrator for organisasjonen. De vil kunne administrere tilgangsstyringen for alle team og repositories knyttet til organisasjonen.\nSom medlem i dette teamet kan man blant annet:\n opprette/slette team legge til og fjerne brukere i ulike team endre konfigurasjon for team  Konfigurasjon Dette teamet ligger inne som standard i alle organisasjoner og det er ikke mulig å endre konfigurasjonen for dette teamet.\nDeploy-Production Beskrivelse Medlemmer i dette teamet kan deploye applikasjoner til produksjonsmiljøet.\nØvrige rettigheter kan defineres fritt av owners. Default konfigurasjon inkluderer rettigheter for:\n Lesetilgang i samtlige repositories Kan ikke opprette nye repositories Full tilgang til alle områder i Gitea  Konfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, muligheten til å deploye til produksjonsmiljø er ikke avhengig av øvrig config.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\n Lese samtlige repositories Aksessere alle områder i Gitea  Deploy-TT02 Beskrivelse Medlemmer i dette teamet kan deploye applikasjoner til testmiljøet.\nØvrige rettigheter kan defineres fritt av owners. Default konfigurasjon inkluderer rettigheter for:\n Lesetilgang i samtlige repositories Kan ikke opprette nye repositories Full tilgang til alle områder i Gitea  Konfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, muligheten til å deploye til testmiljø er ikke avhengig av øvrig config.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\n Lese samtlige repositories Aksessere alle områder i Gitea  Devs Beskrivelse Medlemmer i dette teamet jobber med å utvikle applikasjoner og har tilgang til samtlige repositories.\nKonfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, avhengig av hvor mye frihet man ønsker at apputvikleren skal ha. Merk at det blant annet er mulig å spesifisere hvilke(t) repository teamet skal ha tilgang til.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\n Opprette nye repositories Skrive til samtlige repositories Aksessere alle områder i Gitea  Tilgangsstyring for repository En administrator for organisasjonen kan også styre hvem som har tilgang til det enkelte repository. Det gjøres ved at man går til repositoryet i Gitea, og går til fanen Collaboration under Innstillinger. Tilgang kan gis både til team og enkeltbrukere. For å holde oversikt anbefaler vi primært å sette opp team for tilgangsstyring. For å gi et team tilgang, søk det fram og klikk Add Team.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/",
	"title": "Tilganger",
	"tags": [],
	"description": "Hvordan man får tilganger til Altinn Studio, hemmeligheter og applikasjonslogger.",
	"content": "\r\rApps infrastruktur tilganger\rHvordan bestille tilganger til Altinn Apps infrastruktur.\n\r\rAltinn Studio tilganger\rHvordan konfigurere tilganger for team i Altinn Studio.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/validation/",
	"title": "Validering",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Validering API-endepunktene for instanser og dataelementer.",
	"content": "Overview There are multiple endpoints that can trigger validation and provide feedback regarding the state of an instance and its data. Some of them validates data already uploaded and stored in Altinn while others can validate input.\nValidate stored instance This action will validate an entire instance including the all data elements already uploaded and stored in Altinn. Validation will be performed based on current task in the process. Validation will ensure that all required data elements, as defined by the application metadata, have been uploaded and are valid. If the result of the validation is that nothing is missing or wrong, the action will update the instance with information indicating that the instance is valid. The response will be an empty array. In the case of validation issues the response will provide an array of the identified issues. Validation of a full instance use validation of data as described in the chapter below.\nGET https://{org}.apps.at21.altinn.cloud/{org}/{app}/instances/{instanceOwnerPartyId}/{instanceId}/validate Example response:\n[ { \u0026#34;severity\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;INSTANCE\u0026#34;, \u0026#34;targetId\u0026#34;: null, \u0026#34;field\u0026#34;: null, \u0026#34;code\u0026#34;: \u0026#34;TooManyDataElementsOfType\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;TooManyDataElementsOfType\u0026#34; } ] Validate stored data This action will validate a specific data element already uploaded and stored in Altinn. The logic validates that the data element has the correct Content-Type, that it isn\u0026rsquo;t too large and so on. Data elements with a model bound to them will be validated against the model (Schema).\nValidation will also check that the data element being validated is required for the current task in the process. If the data is validated during a task different from what is intended, the validator will give a warning.\nGET https://{org}.apps.at21.altinn.cloud/{org}/{app}/instances/{instanceOwnerPartyId}/{instanceId}/data/{dataid}/validate Example response:\n[ { \u0026#34;severity\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;targetId\u0026#34;: null, \u0026#34;field\u0026#34;: null, \u0026#34;code\u0026#34;: \u0026#34;MissingContentType\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MissingContentType\u0026#34; } ] Validate data The application will provide a method to validate the datamodel without creating a instance of the data. Data must be provided as formdata. The validate method takes a data file of an dataType and performs validation on that file. It returns a validation report.\nPUT {appPath}/validate?dataType=modelA "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/local-dev/",
	"title": "Lokal utvikling",
	"tags": [],
	"description": "Hvordan komme i gang med lokal utvikling",
	"content": "Under utvikling av en applikasjon vil man måtte jobbe både i Altinn Studio og i et lokalt utviklingsmiljø. Her er en oversikt over hvordan du kommer i gang med lokal utvikling.\nForberedelser Følg stegene beskrevet på GitHub for å klargjøre ditt lokale utviklingsmiljø for utvikling og testing av Altinn apps\nHvordan klone applikasjonen til et lokalt utviklingsmiljø   Finn applikasjonen du vil jobbe med lokalt i Dashboardet i Altinn Studio\n  Navigér til repositoriet ved å trykke på Repository-knappen   Kopiér lenken til repoet (den blå firkanten), enten manuelt eller ved å trykke på knappen markert med en rød sirkel.   Åpne en terminal i ditt lokale utviklingsmiljø\n Naviger til ønsket lokasjon for applikasjonsrepoet Skriv kommandoen git clone og lim inn URLen du kopierte i forrige steg  $git clone https://altinn.studio/repos/ORG/APP.git  I terminalen skal du se en output som likner dette  Cloning into \u0026#39;APP\u0026#39;... remote: Enumerating objects: 982, done. remote: Counting objects: 100% (982/982), done. remote: Compressing objects: 100% (950/950), done. remote: Total 982 (delta 600), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (982/982), 166.38 KiB | 1.51 MiB/s, done. Resolving deltas: 100% (600/600), done.   Du vil nå se at det er opprettet en mappe der innholdet i applikasjonsrepoet nå er klonet inn. Nå er det bare å åpne ditt foretrukne utviklingsverktøy og komme i gang med utviklingen.\nHvordan synkronisere endringer i Altinn Studio Laste opp endringer til master  Trykk på Push på Lage-siden til applikasjonen i Altinn Studio  Legg inn en beskrivende tekst for endringen(e) og trykk Valider endringer  Vent på at endringene valideres  Oppstår det en konklikt trykker du på Løs konflikt og følger instruksjonene   Trykk push for å laste opp endringene til master  Har alt gått bra vil du se denne bekreftelsen.   Laste ned endringer fra master  Trykk på Pull på Lage-siden til applikasjonen i Altinn Studio  Har alt gått bra vil du se denne bekreftelsen.   Hvordan synkronisere endringer i lokalt utviklingsmiljø Sykronisering av endringer gjort i det lokale utviklingsmiljøet kan gjøres på flere måter. Mange utviklingsverktøy har gode integrasjoner for nettopp dette, sjekk gjerne om ditt verktøy har den typen støtte.\nNedenfor er det beskrevet hvordan man kan synkronisere endringer fra kommandolinjen.\nLaste opp endringer til master   Navigér til applikasjonsrepoet ditt i en terminal.\n  Legg til filene du ønsker å pushe til master med kommandoen git add {sti til filen} Kommandoen kan kjøres for enkelt filer, flere filer samtidig eller en mappe\n  Commit endringene med en fornuftlig melding med kommandoen git commit -m {commit-melding}\n  Push endringene til master med kommandoen git push\n  Laste ned endringer fra master Navigér til applikasjonsrepoet ditt i en terminal og kjør kommandoen git pull.\nLes mer om git pull her\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/code/",
	"title": "Code",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Code.",
	"content": "Selv om vi har støtte for å redigere kode og konfigurasjonsfiler direkte i Altinn Studio Repos, er det ofte mer behagelig å gjøre det lokalt på din maskin.\nFor å gjøre dette må du laste ned og installere et koderedigeringsverktøy.\nVi anbefaler Visual Studio Code, men det er fritt fram hvilket verktøy du velger.\nFinne adressen til et repo URL-en til et gitt app repository er strukturert slik, så bytt ut owner og repo-navn:\nhttps://altinn.studio/repos/owner/repo.git.\nDu kan finne URL-en ved å navigere til repositoryet. Klikk ikonet til høyre for å kopiere.\nDu kan også finne samme URL i en popup i Designer hvis du klikker på \u0026ldquo;Clone\u0026rdquo;-knappen.\nKlone koden Etter at du har åpnet Visual Studio Code, åpne den integrerte terminalen (ctrl + ø) og skriv klone-kommandoen. Husk å få med riktig organisasjon og repo-navn.\ngit clone https://altinn.studio/repos/owner/repo Om du ikke er kjent med Visual Studio Code eller Git arbeidsflyt, er det god dokumentasjon her:\nhttps://code.visualstudio.com/docs/getstarted/introvideos https://code.visualstudio.com/docs/editor/versioncontrol#_git-support\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/options/",
	"title": "Kodelister (options)",
	"tags": [],
	"description": "Hvordan konfigurere options/kodelister for en app.",
	"content": "Altinn tilbyr i dag to ulike måter en app kan eksponere kodelister - statisk og dynamisk. Dette gjøres gjennom et options-api som er eksponert av appen, og kodelisten vil være tilgjengelig på endepunktet {org}/{app}/api/options/{optionsId}. Checkbox, Dropdown og RadioButton komponenter vil automatisk kunne hente ut en slik liste om man kobler denne komponenten til en slik options-id.\nStatisk kodeliste fra app-repo Ved å legge json-lister i options mappen i app repo vil appen automatisk lese denne filen og eksponere det gjennom options-apiet. Options filene må ligge under App/options/ og vil bli differensiert ved hjelp av navngivningen på json-filen. F.eks land.json. Her vil da optionsId være land, og vil være eksponert gjennom endepunktet {org}/{app}/api/options/land. Kodelistene må være på et spesifikt format. Eksempel på en kodeliste som inneholder land (App/options/land.json):\n[ { \u0026#34;value\u0026#34;: \u0026#34;norway\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Norge\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;denmark\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Danmark\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;sweden\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;country.label.sweden\u0026#34; } ] label feltet kan inneholde en tekstnøkkel til teskstressursene eller ren tekst.\nDynamisk kodeliste generert runtime I app-templaten har man også mulighet til å ha dynamisk kodelister som bestemmes under kjøringen av appen. Dette muligjør det å eksponere dynamiske verdier som kan filtreres eller hentes fra andre kilder. Dynamiske kodelister kan enten være åpne, dvs. alle brukere når de, eller de kan være sikret gjennom at du må ha tilgang til instansen for å se de.\nI versjoner eldre enn 4.24.0 ble dette gjort ved å legge til kode i metoden GetOptions i App.cs. Denne metoden er nå erstattet ved at man legger til egne klasser for hver kodeliste som implementerer et interface og at man registrerer denne i applikasjonen sin \u0026lsquo;dependency injection cointainer\u0026rsquo;. Dette gir bedre skille mellom de ulike kodelistene, muliggjør å sende avhengigheter inn i konstruktøren til klassen, sende inn språk og andre parametere og generelt håndtere alle aspekter av implementeringen slik du selv ønsker det.\nFor kodelister som er åpne implementerer man IAppOptionsProvider interfacet, mens for kodelister som skal være sikret implementerer man IInstanceAppOptionsProvider. Fremgangsmåten er den samme for begge to og modellen som returneres er lik. Men implementeringen holdes adskilt for ikke å eksponere verdier som skulle vært sikret.\nÅpne dynamiske kodelister Under finner du et eksempel på hvordan dette kan settes opp for en åpen kodeliste. Her vil man få ut den oppsatte kodelisten i det appen får et kall mot {org}/{app}/api/options/countries.\nusing Altinn.App.Common.Models; using Altinn.App.PlatformServices.Options; using System.Collections.Generic; using System.Threading.Tasks; namespace Altinn.App.Core { public class CountryAppOptionsProvider : IAppOptionsProvider { public string Id { get; set; } = \u0026#34;countries\u0026#34;; public Task\u0026lt;AppOptions\u0026gt; GetAppOptionsAsync(string language, Dictionary\u0026lt;string, string\u0026gt; keyValuePairs) { var options = new AppOptions { Options = new List\u0026lt;AppOption\u0026gt; { new AppOption { Label = \u0026#34;Norway\u0026#34;, Value = \u0026#34;47\u0026#34; }, new AppOption { Label = \u0026#34;Sweden\u0026#34;, Value = \u0026#34;46\u0026#34; } } }; return Task.FromResult(options); } } } For at denne implementasjonen skal plukkes opp av applikasjonen må den registreres i Startup.cs:\nservices.AddTransient\u0026lt;IAppOptionsProvider, CountryAppOptionsProvider\u0026gt;(); Legg merke til at du kan ha mange implementasjoner av dette interfacet. Den rette implementasjonen finnes gjennom å se på hvilken kodeliste id det spørres etter.\nInterfacene har en egenskap Id, som skal settes til til den id\u0026rsquo;en man skal spørre etter, og en metode GetAppOptionsAsync som returnerer selve kodelisten. Denne metoden tar i mot språk og en liste med key/value par som typisk er query parametre som plukkes opp av kontrolleren og sendes inn. Selv om språk kunne vært et key/value par og sånn sett hvert i listen, så er denne lagt utenfor for å være eksplisitt på språk.\n Språkkoder bør baseres på ISO 639-1 standarden eller W3C IANA Language Subtag Registry standarden. Sistnevnte bygger på ISO 639-1 standarden men garanterer at alle kodene er unike, noe ISO 639-1 ikke gjør.\n Sikrede dynamiske kodelister MERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.27.0 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\n\rOm du ønsker å eksponere kodelister som inneholder sensitive data som man ikke ønsker skal være tilgjengelige i et åpent API kan man benytte IInstanceAppOptionsProvider. Disse kodelistene validerer at brukeren har lesetilgang definert i applikasjonens policy.xaml-fil. Under finner du et eksempel på man setter opp en sikret kodeliste. Interfacet IInstanceAppOptionsProvider må implementeres og en secure boolean må legges på komponenten. Her vil man få ut den oppsatte kodelisten i det appen får et kall mot /{org}/{app}/instances/{instanceOwnerId}/{instanceGUID}/options/children.\nusing System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Common.Models; using Altinn.App.PlatformServices.Models; namespace Altinn.App.Core { public class ChildrenAppOptionsProvider : IInstanceAppOptionsProvider { public string Id { get; set; } = \u0026#34;children\u0026#34;; public Task\u0026lt;AppOptions\u0026gt; GetInstanceAppOptionsAsync(InstanceIdentifier instanceIdentifier, string language, Dictionary\u0026lt;string, string\u0026gt; keyValuePairs) { // ...  // Some custom code to get the list of children from the instance owner  // ...  var options = new AppOptions { Options = new List\u0026lt;AppOption\u0026gt; { new AppOption { Label = \u0026#34;Ole\u0026#34;, Value = \u0026#34;1\u0026#34; }, new AppOption { Label = \u0026#34;Dole\u0026#34;, Value = \u0026#34;2\u0026#34; }, new AppOption { Label = \u0026#34;Doffen\u0026#34;, Value = \u0026#34;3\u0026#34; } } }; return Task.FromResult(options); } } } For at denne implementasjonen skal plukkes opp av applikasjonen må den registreres i Startup.cs:\nservices.AddTransient\u0026lt;IInstanceAppOptionsProvider, ChildrenAppOptionsProvider\u0026gt;(); Legg merke til at du kan ha mange implementasjoner av dette interfacet. Den rette implementasjonen finnes gjennom å se på hvilken kodeliste id det spørres etter.\nInterfacene har en egenskap Id, som skal settes til til den id\u0026rsquo;en man skal spørre etter, og en metode GetAppOptionsAsync som returnerer selve kodelisten. Denne metoden tar i mot språk og en liste med key/value par som typisk er query parametre som plukkes opp av kontrolleren og sendes inn. Selv om språk kunne vært et key/value par og sånn sett hvert i listen, så er denne lagt utenfor for å være eksplisitt på språk.\nSiste konfigurasjon som trengs er å legge til secure-boolean på den aktuelle komponenten. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;dropdown-component\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Some title\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Some description\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;some.field\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;children\u0026#34;, \u0026#34;secure\u0026#34;: true  } Koble en komponent til kodeliste Dette gjøres ved å legge til feltet optionsId som referer til hvilken option (kodeliste) man ønsker refere til. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;8e6f7b2f-fcf0-438d-8336-c1a8e1e03f44\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;componentType\u0026#34;: 4, \u0026#34;textResourceBindings\u0026#34;: {}, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;optionsId\u0026#34;: \u0026#34;biler\u0026#34;, } Sende med query parametere ved henting av options Options støtter query parameters når det gjøres api kall. language er satt opp automatisk, men man kan også legge til egendefinerte parametere ved å sette opp mapping på den aktuelle komponenten.\n{ \u0026#34;id\u0026#34;: \u0026#34;c66d7b69-2e18-4786-af44-1fa913853618\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;NyGarantiLoyvetype\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;soknad.nyGaranti.loyvetype\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;loyvetyper\u0026#34;, \u0026#34;mapping\u0026#34;: { \u0026#34;soknad.transportorOrgnummer\u0026#34;: \u0026#34;orgnummer\u0026#34; } }, I eksempelet over vil det bli satt på et query parameter orgnummer={nr}, hvor {nr} er verdien på feltet soknad.transportorOrgnummer. Om man setter opp en kobling til et datafelt og dette feltet endrer seg så vil app-frontend hente options på nytt. På denne måten kan man dynamisk styre hvilke valg som vises basert på informasjon gitt av sluttbruker.\nUnder PDF-generering vil appen prøve å kalle det samme options-endepunktet som app-frontend gjør. Vi har foreløpig en svakhet ved at eventuelle mapping-parametere ikke blir inkludert i denne forespørselen, se issue [#7903.](https://github.com/Altinn/altinn-studio/issues/7903)\rEn mulig workaround her er å returnere en tom array i det PDF-generatoren spør om options med tomme query-parametere, eksempel:\nstring someArg = keyValuePairs.GetValueOrDefault(\u0026#34;someArg\u0026#34;); string someOtherArg = keyValuePairs.GetValueOrDefault(\u0026#34;someOtherArg\u0026#34;); if (string.IsNullOrEmpty(someArg) || string.IsNullOrEmpty(someOtherArg)) { return await Task.FromResult(new List\u0026lt;AppOption\u0026gt;()); } Merk at dette vil resultere i at PDF vil vise verdien valgt og ikke label som sluttbrukers svar.\n\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/secrets/",
	"title": "Secrets",
	"tags": ["translate-to-english"],
	"description": "How to deal with secrets and sensitive data in an app.",
	"content": "Administrasjon av hemmeligheter i Azure Som applikasjonsutvikler administrerer man selv hemmelighetene som applikasjonen benytter i Azure Key Vault.\nRutiner for bestilling av tilgang til din organisasjons ressurser er beskrevet her.\nKonfigurer støtte for hemmeligheter i din app For å tilgjengeliggjøre hemmeligheter i applikasjonen må det gjøres oppdateringer i helm charten tilknyttet applikasjonen.\nI applikasjonsrepoet ditt finner du filen values.yaml i mappen deployment.\nUnder seksjonen volumeMounts legger du til følgende linjer:\n- name: altinn-appsettings-secret mountPath: \u0026#34;/altinn-appsettings-secret\u0026#34; Under seksjonen volumes legger du til følgende linjer:\n- name: altinn-appsettings-secret secret: secretName: altinn-appsettings-secret Vær påpasselig med innrykk når du jobber i _values.yaml_.\rI yaml skal indents være mellomrom og ikke tab, benytter du tab vil ikke din yaml være gyldig.\r\rSiste del av filen skal se omtrent slik ut når du har gjort ferdig alle endringer.\nHvordan benytte hemmeligheter i applikasjonen Servicen ISecret er eksponert i applikasjonen og kan dependency injectes i den klassen der du har behov for å hente ut en hemmelighet.\nLokal mock For å kunne kjøre tjenesten din lokalt uten å koble seg til Azure Key vault må man opprette filen secrets.json under mappen App. I Json strukturen kan man legge inn dummydata for hemmelighetene man har behov for. Har man lastet opp en hemmelighet i Key Vault med navnet \u0026ldquo;secretId\u0026rdquo; vil innholdet i json-filen se slik ut\n{ \u0026#34;secretId\u0026#34;: \u0026#34;local cecret dummy data\u0026#34; } Type hemmeligheter Secret - lagres som en streng direkte i keyvault. F.eks et sertifikat som er base64 encoded eller et token. Key - Nøkkel Certificate - et sertifikat\nKodeeksempel I denne seksjonen finner du et eksempel på hvordan man benytter en hemmelighet til å populere et skjemafelt under instansiering.\nLogikken er implementert i InstantiationHandler.cs\nusing Altinn.App.Models; using Altinn.App.Services.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; using System.Threading.Tasks; namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; private ISecrets _secretsService; /// \u0026lt;summary\u0026gt;  /// Set up access to profile and register services  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;profileService\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;registerService\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  public InstantiationHandler(IProfile profileService, IRegister registerService, ISecrets secretsService) { _profileService = profileService; _registerService = registerService; _secretsService = secretsService; } /// \u0026lt;summary\u0026gt;  /// Run events related to instantiation  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;remarks\u0026gt;  /// For example custom prefill.  /// \u0026lt;/remarks\u0026gt;  /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;Instance information\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data object created\u0026lt;/param\u0026gt;  public async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Skjema)) { Skjema model = (Skjema)data; model.etatid = await _secretsService_.GetSecretAsync(\u0026#34;secretId\u0026#34;); } await Task.CompletedTask; } } }   Den private variabelen for servicen inkluderes i klassen\nprivate ISecrets _secretsService;   ISecrets servicen dependency injectes inn i klassen. Og den private variabelen blir assignet en verdi.\npublic InstantiationHandler(IProfile profileService, IRegister registerService, ISecrets secretsService) { _profileService = profileService; _registerService = registerService; _secretsService = secretsService; }   I metoden der man har behov for hemmeligheten kaller man på servicen. secretId vil være navnet på hemmeligheten i KeyVault evt. i lokal mock.\nawait _secretsService_.GetSecretAsync(\u0026#34;secretId\u0026#34;);   Dersom du prøver å bygge løsningen nå vil det feile.\nISecrets vil mangle der InstantiationHandler instansieres. Naviger til App.cs og dependency inject servicen inn i konstruktøren til App.\nVidere må tjenesten legges til i kallet der InstantiationHandler instansieres som vist nedenfor.\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, ISecrets secretsService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService, secretsService); }   "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/eformidling/",
	"title": "eFormidling",
	"tags": [],
	"description": "Hvordan konfigurere eFormidling integrasjon for en app.",
	"content": "Aktivere integrasjon med eFormidling i applikasjonen din For at applikasjonen din skal kunne sende instansdata videre til eFormidling må den referere til nugetversjon = 4.22.0.\r[Se hvordan du oppdaterer nugetreferanser for applikasjonen din her](../update/#nuget-pakker).\r\rDersom man har behov for integrasjon med eFormidling i applikasjonen må dette aktiveres.\nI filen appsettings.json i mappen App må følgende legges til i seksjonen AppSettings\n\u0026#34;EnableEFormidling\u0026#34;: true I tillegg må det i samme fil opprettes en ny seksjon; EFormidlingClientSettings. Innholdet i kodesnutten nedenfor kan kopieres i sin helhet. Denne setter opp url til integrasjonspunktet. Lenken peker på mocken som kan kjøres opp lokalt. Les mer om oppsettet av eFormidlings mocken her.\nNår en app deployes til TT02 eller produksjon vil denne verdien overskrives og peke mot integrasjonspunktet i Altinn Platform.\n\u0026#34;EFormidlingClientSettings\u0026#34;: { \u0026#34;BaseUrl\u0026#34;: \u0026#34;http://localhost:9093/api/\u0026#34; } Dersom det ikke er ønskelig å teste integrasjonen med eFormidling når man kjører applikasjonen lokalt kan man overstyre denne konfigurasjonen i appsettings.Development.json.\nOpprett AppSettings seksjonen dersom den ikke finnes og sett EnableEFormidling til false.\n\u0026#34;AppSettings\u0026#34;: { \u0026#34;EnableEFormidling\u0026#34;: false } Legge til støtte for eFormidling i App.cs Neste steg for å få støtte for eFormidling i tjenesten din er å tilgjengeliggjøre services som appen behøver. Endringene skal alle gjøres i filen App.cs som ligger i mappen _App/logic.\nØverst i filen, blant bibliotekreferansene legges disse tre linjene til.\nusing Altinn.Common.EFormidlingClient.Models; using Altinn.Common.EFormidlingClient; using Altinn.Common.AccessTokenClient.Services; Videre skal vi injecte services i konstruktøren til både klassen og base klassen.\nKonstruktøren vil se ut som eksempelet nedenfor, men hvilke services som sendes med kan variere fra tjeneste til tjeneste, så her er kun et eksempel på det vanligste oppsettet.\npublic App( IAppResources appResourcesService, (...) IHttpContextAccessor httpContextAccessor):base( appResourcesService, (...) httpContextAccessor) Listen med services i konstruktøren skal utvides med de fire servicene vist nedenfor.\nIEFormidlingClient eformidlingClient, IOptions\u0026lt;AppSettings\u0026gt; appsettings, IAccessTokenGenerator tokenGenerator, IOptions\u0026lt;PlatformSettings\u0026gt; platformSettings Videre skal disse servicene sendes med videre til baseklassen, da er det kun navnene som sendes med og ikke typene.\neformidlingClient, appsettings, platformSettings, tokenGenerator Endelig resultat skal se slik ut:\npublic App( IAppResources appResourcesService, (...) IHttpContextAccessor httpContextAccessor, IEFormidlingClient eformidlingClient, IOptions\u0026lt;AppSettings\u0026gt; appsettings, IAccessTokenGenerator tokenGenerator, IOptions\u0026lt;PlatformSettings\u0026gt; platformSettings):base( appResourcesService, (...) httpContextAccessor, eformidlingClient, appsettings, platformSettings, tokenGenerator) Konfigurere nøkkelverdier for eFormidling i applikasjonen din Det kreves en del metadata om eFormidlingsforsendelsen og denne defineres i applicationmetadata.json_. Filen finner du i repoet under mappen _App/config_.\nOpprett seksjonen eFormidling og fyll ut verdier for følgende parametre.\n   Id Beskrivelse     serviceId Id som spesifiserer type forsendelse DPO, DPV, DPI eller DPF*   dpfShipmentType Forsendelsestype som benyttes til routing på mottakersiden   process Id som settes på scopet i StandardBusinessDocumentHeader**   dataTypes Liste av data typer som automatisk skal legges ved forsendelsen   sendAfterTaskId Id på tasken som skal avsluttes før forsendelsen sendes. Det er anbefalt at dette er et confirmation steg   receiver Organisasjonsnummer til mottaker. Støtter kun norske virksomheter. Kan sløyfes og defineres i applogikken   standard DocumentIdentification standard   type Id på meldingstypen   typeVersion Versjon av meldingstypen   securityLevel Sikkerhetsnivå som settes på StandardBusinessDocument    * per Januar 2022 støttes kun DPF.\n** tilgjengelige prosesser for mottaker er tilgjengelig på https://platform.altinn.no/eformidling/api/capabilities/{mottaker-orgnummer}\nEt eksempel for en konfigurasjon i application metadata:\n\u0026#34;eFormidling\u0026#34;: { \u0026#34;serviceId\u0026#34;: \u0026#34;DPF\u0026#34;, \u0026#34;dpfShipmentType\u0026#34;: \u0026#34;altinn3.skjema\u0026#34;, \u0026#34;process\u0026#34;: \u0026#34;urn:no:difi:profile:arkivmelding:administrasjon:ver1.0\u0026#34;, \u0026#34;dataTypes\u0026#34;: [ \u0026#34;ref-data-as-pdf\u0026#34; ], \u0026#34;sendAfterTaskId\u0026#34;: \u0026#34;Task_2\u0026#34;, \u0026#34;receiver\u0026#34;: \u0026#34;910075918\u0026#34;, \u0026#34;standard\u0026#34;: \u0026#34;urn:no:difi:arkivmelding:xsd::arkivmelding\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;arkivmelding\u0026#34;, \u0026#34;typeVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;securityLevel\u0026#34;: 3 } Generering av metadata til forsendelsen i applikasjonen Apputvikler er selv ansvarlig for å sette opp meldingen til en forsendelse som skal via eFormidling. Les om de ulike meldingstypene tilgjengelig i eFormidling.\nDette gjøres ved å legge til funksjonen nedenfor i App.cs.\nForventet output fra denne metoden er en tuppel som inneholder navnet på metadatafilen som første element og en stream med metadataen som andre element.\n/// \u0026lt;inheritdoc /\u0026gt; public override async Task\u0026lt;(string, Stream)\u0026gt; GenerateEFormidlingMetadata(Instance instance) { Altinn.Common.EFormidlingClient.Models.Arkivmelding arkivmelding = new (); // bygg opp arkivmeldingen eller annet metadataobjekt her.  MemoryStream stream = new MemoryStream(); XmlSerializer serializer = new XmlSerializer(typeof(Altinn.Common.EFormidlingClient.Models.Arkivmelding)); serializer.Serialize(stream, arkivmelding); stream.Position = 0; StreamContent streamContent = new StreamContent(stream); streamContent.Headers.ContentType = MediaTypeHeaderValue.Parse(\u0026#34;application/xml\u0026#34;); return await Task.FromResult((\u0026#34;arkivmelding.xml\u0026#34;, stream)); } Sette mottaker for forsendelse i applikasjonslogikken I App.cs kan man overstyre metoden som henter ut mottaker av forsendelsen fra applicationmetadata.json_. Denne funksjonaliteten kan benyttes dersom mottaker av forsendelsen skal avgjøres dynamisk.\nDet må tre steg til for å sette mottaker i applikasjonslogikken, og alle endringer gjøres i App.cs.\n Øverst i filen må det legges til en referanse til eFormidlings biblioteket.  using Altinn.Common.EFormidlingClient.Models.SBD;  Legg til denne funksjonen i klassen. Forventet output fra denne metoden er en liste som inneholder minst ett receiver-objekt.\npublic override async Task\u0026lt;List\u0026lt;Receiver\u0026gt;\u0026gt; GetEFormidlingReceivers(Instance instance) { Identifier identifier = new Identifier { Authority = \u0026#34;iso6523-actorid-upis\u0026#34; }; // 0192 prefix for all Norwegian organisations.  identifier.Value = \u0026#34;[INSERT ORGANISATION NUMBER HERE WITH PREFIX `0192:`]\u0026#34; ; Receiver receiver = new Receiver { Identifier = identifier }; return new List\u0026lt;Receiver\u0026gt; { receiver }; }   Legg til egen logikk for å populere identifier.Value i funksjonen. Merk at det kun er norske organisasjonsnummer som støttes, og at prefiksen 0192: er påkrevd før organisasjonsnummeret.\n  Lokal test av applikasjon med eFormidling Det er mulig å teste eFormidlingsintegrasjonen i applikasjonen lokalt på utviklingsmiljøet ditt. I tillegg til Altinn Localtest og applikasjonen er det to ting som må kjøre:\n eFormidling integrasjonspunkt mock av eFormidling  Forberedelser   Installer siste versjon av Java. Finn nedlastingslenke og beskrivelse av nødvendige steg her\n  Det skal nå lastes ned en rekke filer. Finn en egnet plassering for eFormidling lokalt på maskinen din og navigér dit i en terminal.\n  Klon repoet som inneholder eFormidling mocken med følgende commando\ngit clone --branch development https://github.com/felleslosninger/efm-mocks.git   Last ned integrasjonspunktet herfra. Dette kan plasseres på samme nivå som mappen efm-mocks.\n  Kjøre eFormidling lokalt  Åpne en terminal og navigér til efm-mocks (Command prompt eller bash er anbefalt, PowerShell funker ikke. ) Kjør docker-compose up -d Navigér til mappen der integrasjonspunkt-filen ligger Kjør kommandoen java -Xmx2g -Dspring.profiles.active=mock -jar integrasjonspunkt-2.2.0.jar Dersom du har en nyere versjon av integrasjonspunktet enn 2.2.0 må kommandoen siste ledd i siste linje justeres for dette.  Verifiser at eFormidling er satt opp korrekt Dette steget krever node og npm på maskinen din, men er ikke nødvendig for å bruke mocken.\n Åpne en terminal og navigér til efm-mocks/tests/ Kjør npm i Navigér inn i mappen next-move Kjør node NextMove.js dpf Verifiser i en broswer på localhost:8001 at det er nye innslag i tabellen med de sendte meldingene.  Les mer om mockløsningen her\nTest av eFormidling integrasjon i testmiljø Det oppfordres til grundig testing av eFormidlingsintegrasjonen i applikasjonene.\rDet er lagt inn sikringer og retry mekanismer for å få en forsendelse fram til\rmottaker dersom feil skyldes svakheter i nettverksforbindelse.\rI tilfellet ugyldige forsendelser, herunder manglende vedlegg eller feil i arkivmelding,\rvil forsendelsen feile uten eksplisitt varsling til sluttbruker eller tjenesteeier.\r\rIntegrasjonspunktet eksponerer endepunkter der man kan følge statusen for en forsendelse. https://platform.altinn.no/eformidling/api/conversations?messageId={instanceGuid}\nBytt ut {instanceGuid} med guiden til instansen som er blitt innsendt.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/events/",
	"title": "Events",
	"tags": [],
	"description": "Hvordan lage egendefinerte events for en app.",
	"content": "Aktivere generering av events i applikasjonen din For at applikasjonen din skal kunne generere events må den referere til nugetversjon = 1.2.4.\rSe hvordan du oppdaterer nugetreferanser for applikasjonen din [her](../update/#nuget-pakker).\r\rGenerering og lagring av events er ikke enablet som default i applikasjonene per 22.10.2020. Det må derfor et manuelt steg til for at applikasjonen din skal generere events.\nI filen appsettings.json i mappen App må følgende legges til i seksjonen AppSettings\n\u0026#34;RegisterEventsWithEventsComponent\u0026#34;: true Pushe egendefinerte events i applikasjonen din Servicen IEvents er eksponert i applikasjonen og kan dependency injectes i den klassen der du har behov for å generere et egendefinert event.\nMetoden AddEvent krever navnet på eventypen og instansen som input.\nKodeeksempel I denne seksjonen finner du et eksempel på hvordan man kan generere et egendefinert event ved instansiering av applikasjonen.\nLogikken er implementert i InstantiationHandler.cs\nusing Altinn.App.Services.Interface; using Altinn.App.PlatformServices.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; using System.Threading.Tasks; // using Altinn.App.Models; // Uncomment this line to refer to app model(s)  namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; private IEvents _eventsService; /// \u0026lt;summary\u0026gt;  /// Set up access to profile and register services  /// \u0026lt;/summary\u0026gt;  public InstantiationHandler(IProfile profileService, IRegister registerService, IEvents eventsService) { _profileService = profileService; _registerService = registerService; _eventsService = eventsService; } /// \u0026lt;summary\u0026gt;  /// Run validations related to instantiation  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;example\u0026gt;  /// if ([some condition])  /// {  /// return new ValidationResult(\u0026#34;[error message]\u0026#34;);  /// }  /// return null;  /// \u0026lt;/example\u0026gt;  /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;validationResults\u0026#34;\u0026gt;\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;The validation result object (null if no errors) \u0026lt;/returns\u0026gt;  public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { return await Task.FromResult((InstantiationValidationResult)null); } /// \u0026lt;summary\u0026gt;  /// Run events related to instantiation  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;remarks\u0026gt;  /// For example custom prefill.  /// \u0026lt;/remarks\u0026gt;  /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;Instance information\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data object created\u0026lt;/param\u0026gt;  public async Task DataCreation(Instance instance, object data) { await _eventsService.AddEvent(\u0026#34;app.test.event\u0026#34;, instance); await Task.CompletedTask; } } }   Den private variabelen for servicen inkluderes i klassen\nprivate IEvents _eventsService;   Namespce for IEvents må inkluderes i klassen. Legg til linjen nedenfor blant de andre using-statements øverst i filen.\nusing Altinn.App.PlatformServices.Interface;   IEvents servicen dependency injectes inn i klassen. Og den private variabelen blir assignet en verdi.\npublic InstantiationHandler(IProfile profileService, IRegister registerService, IEvents eventsService) { _profileService = profileService; _registerService = registerService; _eventsService = eventsService; }   I metoden der man har behov for å genere et event kaller man på servicen.\nHer har det egendefinerte eventet fått navnet app.test.event, i tillegg sendes instansen med. Denne brukes til å populere resterende metadata om eventet.\nawait _eventsService.AddEvent(\u0026#34;app.test.event\u0026#34;, instance);   Dersom du prøver å bygge løsningen nå vil det feile.\nIEvents vil mangle der InstantiationHandler instansieres. Naviger til App.cs og dependency inject servicen inn i konstruktøren til App.\nVidere må tjenesten legges til i kallet der InstantiationHandler instansieres som vist nedenfor.\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IEvents eventsService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService, eventsService); }   Applikasjonen din er nå klar til å generere et egendefinert event under instansiering. Dette er mulig å teste lokalt før det evt. deployes til et testmiljø.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/attachments/",
	"title": "Vedlegg",
	"tags": [],
	"description": "I en applikasjon kan man legge til rette for opplasting av filvedlegg både via GUI og API.",
	"content": "Metoder for opplasting av vedlegg I en Altinn app har man to alternativer for opplasting av vedlegg:\n vedleggskomponent i skjema API-kall mot app backend  Førstnevnte vil være et godt alternativ for all data er det forventet at en sluttbruker vil laste opp via brukergrensesnitt i skjema. Sistnevnte anbefales brukt dersom det kun er forventet at systemer skal laste opp vedlegget. Det er ingen begrensning på hvor mange vedlegg som kan inkluderes i en applikasjon og begge opplastingsmetoder kan brukes innad i samme applikasjon.\nNedenfor følger en enkel beskrivelse av hvordan du kan legge til rette for at applikasjonen din kan ta imot vedlegg.\nInnsending av vedlegg med vedleggskomponent i skjema Når man setter sammen skjemaet sitt i Altinn Studio har man en vedleggskomponent tilgjengelig. Det er mulig å laste opp flere vedlegg på en enkelt komponent, og hvor mange vedleggskomponenter du benytter i din applikasjon vil avgjøres av egenskapene til dokumentene du forventer at skal lastes opp og eventuelle begrensninger du selv ønsker å sette (se konfigurasjon av vedlegg for mer informasjon om dette).\nNB! Det vil også være mulig å laste opp vedlegg av typen definert i vedleggkomponenten via API.\nBildet over viser vedleggskomponenten i Altinn Studio. Det er mulig å sette en del av konfigurasjonenen for vedleggene som lastes opp alledere her.\n Egendefinerte filtyper kan spesifiseres dersom man vil begrense filtypene som kan sendes inn. En bruker vil i så fall hindres under opplastning dersom filtypen ikke er blant den godkjente listen. Minst/maks antall filvedlegg kan spesifiseres dersom man ønsker et bestemt antall vedlegg lastet opp via komponenten. Ved å sette \u0026lsquo;0\u0026rsquo; på minst antall filvedlegg vil det ikke være påkrevd å laste opp en fil. Maks filstørrelse spesifiseres i MB.  Ytterligere konfigurasjoner som kan settes for vedlegg inkluderer: tillatte bidragsytere og beskrivelse. Dette gjøres i applicationMetadata.json som ligger under App/config i applikasjonsrepoet.\nVedleggskomponent med merking Det finnes også en egen komponent der man får brukeren til å merke filen med hjelp av en nedtrekksliste. Dette settes opp ganske likt som med den vanlige filopplastingskomponenten, med tillegget av en kodeliste-ID og navnet man vil gi merkingen.\nHer under kan du se den i bruk\nInnsending av vedlegg med API-kall For å legge til rette for å kunne sende inn vedlegg uten å ha støtte for dette i GUI må man legge inn et datatype-objekt i applicationMetadata.json (filen ligger under App/config i applikasjonsrepoet). Det vil da kun være mulig å sende inn vedlegg av denne typen via API-kall. For en nærmere beskrivelse av de tilgjengelige feltene se konfigurasjon av vedlegg.\nKonfigurasjon for vedlegg I applicationMetadata.json (ligger under App/config i applikasjonsrepoet) vil man finne en property som heter dataTypes. Her er ligger konfigurasjonen for alle datatyper knyttet til applikasjonen, både skjemadata (app model data) og vedlegg. Feltet appLogic som man også vil se blant noen av objektene i listen skal kun brukes for skjemadata.\nNedenfor er det to eksempler på dataTypes-instanser i en applikasjon fra en deployet applikasjon.\n\u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;53a50f0d-2345-448d-9fba-f18e6bbe71f8\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;allowedContentTypes\u0026#34;:[\u0026#34;application/pdf\u0026#34;] }, { \u0026#34;id\u0026#34;: \u0026#34;attest\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 0, \u0026#34;allowedContributers\u0026#34;: [\u0026#34;org:nav\u0026#34;, \u0026#34;orgNo:XXXXXXXXXX\u0026#34;], \u0026#34;grouping\u0026#34;: \u0026#34;Attester\u0026#34;, } ]   Id på vedleggstypen. Denne vil settes som en GUID dersom man bruker vedleggskomponent fra Altinn Studio slik man ser i det første elementet i dataTypes-listen. Skulle det være ønskelig å endre verdien til et mer fornuftig navn må man også være obs på at denne endringen må gjøres to steder: applicationMetadata.json og FormLayout.json. (Kun relevant dersom man bruker filopplaster i GUI)\n  taskId betegner hvilket steg i prosessen det er forventet at dette vedlegget skal lastes opp på. Denne verdien må tilsvare en id på en av taskene i process.bpmn.\n  maxSize betegner maks tillat størrelse på vedlegget.\n  maxCount betegner en øvre grensen for hvor mange vedlegg av denne typen som skal lastet opp i tilknytning til en instans.\n  minCount betegner en nedre grensen for hvor mange vedlegg av denne typen som skal lastet opp i tilknytning til en instans. Dersom verdien er 0 er det ikke påkrevt å laste opp vedlegg av denne typen.\n  allowedContributers spesifiserer hvem som får lov til å lage og/eller endre vedlegg av denne typen. Dette spesifiseres på formatet {nøkkelord}:{verdi}. Tillatte nøkkelord inkluderer: \u0026lsquo;org\u0026rsquo;; trebokstavsforkortelse på organisasjon og \u0026lsquo;orgNo\u0026rsquo;; organisasjonsnummer. Det er per nå ikke mulig å spesifisere en organisasjon som ikke er registrert som tjenesteeier.\n  allowedContentTypes spefisiserer hvilke vedleggstyper man tillater. De hyppigst brukte inkluderer: application/pdf, text/xml, image/jpeg. Dersom man ikke ønsker å sette begrensning på typen vedlegg trenger man ikke definere denne parameteren. Les mer om mime types her.\n  grouping betegner gruppen som vedleggene i av denne typen skal grupperes etter. Dette er en valgfri egenskap, hvor vedlegg med samme grouping vil havne i samme liste. Grouping kan både være en streng (f.eks \u0026ldquo;Attester\u0026rdquo;) eller en tekstnøkkel om man ønsker å støtte flere språk (f.eks \u0026ldquo;skjema.vedleggsgruppering). Her er et eksempel hvor grouping \u0026ldquo;Demogruppe\u0026rdquo; satt på en vedleggstype:\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/settings/",
	"title": "Settings og miljøvariabler",
	"tags": [],
	"description": "Hvordan legge inn konfigurasjon- og miljøspesifikke verdier slik at de er tilgjengelig fra app-koden.",
	"content": "Standard .NET konfigurasjon Altinn 3 sin App template baserer seg på en ASP.Net Core applikasjon og har med dette en rekke muligheter for å styre konfigurasjon av en App. Denne dokumentasjonen er derfor i stor grad utdrag fra eller linker til Microsoft sin egen dokumentasjon. Det er derimot ikke alt som er mulig i en App da det er litt begrenset hva Altinn 3 gir av tilganger til miljøet en App kjører i.\nappsettings.json Første og enkleste kilde til konfigurasjonsinformasjon er appsettings filene. En hver ny app som blir laget vil komme med en eksisterende appsettings.json fil. Denne filen blir lest inn av en App under oppstart uavhengig av hvilke miljø Appen kjører i. Det vil si at den bør inneholde standarinnstillinger og innstillinger som er lik i alle miljøer. Filen har allerede en del innstillinger som er i bruk og verdiene er i stor grad beregnet for et utviklingsmiljø hvor man kjører LocalTest.\nI appsettings.json filene organiseres verdier i ulike seksjoner. Det anbefales å ikke legge til nye verdier i de eksisterende seksjonene, men isteden lage nye seksjoner. Følgende seksjoner er reservert for å unngå kollisjoner: Kestrel, AppSettings, GeneralSettings, PlatformSettings, PEPSettings, ApplicationInsights, kvSettings.\n{ \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn i alle miljøer, men kanskje overstyrt av miljøspesifikke kilder\u0026#34; }, \u0026#34;AppSettings\u0026#34;: { ... }, \u0026#34;GeneralSettings\u0026#34;: { ... }, \u0026#34;PlatformSettings\u0026#34;: { \u0026#34;ApiStorageEndpoint\u0026#34;: \u0026#34;http://localhost:5101/storage/api/v1/\u0026#34;, \u0026#34;ApiRegisterEndpoint\u0026#34;: \u0026#34;http://localhost:5101/register/api/v1/\u0026#34;, ... }, \u0026#34;ApplicationInsights\u0026#34;: { \u0026#34;InstrumentationKey\u0026#34;: \u0026#34;retrieved from environment at runtime\u0026#34; } } I fremtiden vil en ny App få med en egen seksjon som det skal være enkelt å utvide. I mellomtiden refereres det til Microsoft sin dokumentasjon for hvordan dette kan gjøres.\nMiljøspesifikke appsettings En ny app vil også inneholde et set med miljøspesifikke appsettings filer: appsettings.Development.json, appsettings.Staging.json og appsettings.Production.json. Disse filene blir lest inn kun i det aktuelle miljøet. TT02-miljøet er definert som Staging og produksjonsmiljøet er definert som Production.\nHver fil skal altså ha verdier som er unike eller anderledes i minst ett annet miljø. Et eksempel på en type verdi som kan variere fra miljø til miljø er \u0026ldquo;timeout\u0026rdquo; verdier. Hvis man ønsker at en App skal vente lengre på respons fra et eksternt API under utvikling enn det man ønsker å tillate i produksjon.\nappsettings.Development.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for utviklingsmiljø\u0026#34; } } appsettings.Staging.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for TT02\u0026#34; } } appsettings.Production.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for produksjon\u0026#34; } } Miljøvariabler Standard oppførsel til en ASP.Net applikasjon er å lese inn miljøvariabler. Dette gjøres også for en App, men det er ikke mulig for en Apputvikler å lage eller endre noen verdier per i dag. Altinn 3 mener at denne måten å styre miljøspesifikke verdier på dekkes av appsettings og KeyVault.\nKommandolinjeargumenter Det er teknisk mulig å overstyre alle andre data kilder ved hjelp av kommandolinjeargumenter. Det er derimot ikke mulig å bruke dette til å endre verdier fra et miljø til et annet.\nAzure KeyVault Hver applikasjonseier skal få tilgang til sitt eget Azure KeyVault for lagring av sensitive verdier. Altså verdier man ikke ønsker å ha synlig i kode eller konfigurasjonsfiler. Noen naturlig eksempler på dette er ting som brukernavn og passord for eksterne APIer en App skal benytte. Et sertifikat, privat nøkkel eller lignende.\nPer i dag blir ikke verdier fra KeyVault lest inn i konfigurasjonsstyringen av en App. Isteden må man benytte Secrets komponenten. Dette er dokumentert under hemmeligheter.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/startup/",
	"title": "Konfigurer appens oppførsel under oppstart",
	"tags": [],
	"description": "Hvordan konfigurere applikasjonens oppførsel under oppstart av app-frontend",
	"content": "I applicationmetadata.json har man mulighet til å styre hva applikasjonen viser i det brukeren går mot en direktelenke. Dette gjøres under feltet onEntry.show, hvor man har mulighet til å sette verdiene new-instance (default) eller select-instance. Standard oppførsel om dette feltet ikke er satt er at det lages en ny instans for brukeren som besøker applikasjonen.\nVelge fra aktive instanser MERK: for å benytte denne funksjonaliteten må man ha versjon \u0026gt;= 4.15.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\n\rOm man setter feltet til onEntry.show til select-instance vil brukeren bli presentert med en liste av aktive instanser for den valgte avgiver når man navigerer seg til en applikasjon.\nEksempel Følgende konfigurasjon legges til i applicationmetadata.json for å sette opp valg av aktive instanser.\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/demo-app\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Starte fra aktiv instans\u0026#34; }, ... \u0026#34;onEntry\u0026#34;: { \u0026#34;show\u0026#34;: \u0026#34;select-instance\u0026#34; } } For brukere som ikke har noen aktive instanser vil det automatisk bli opprettet en instans. Brukere som har aktive instanser vil bli presentert med følgende brukergrensesnitt:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/stateless/",
	"title": "Stateless applikasjon (innsynstjeneste)",
	"tags": [],
	"description": "Hvordan legge inn konfigurasjon for å styre oppførsel ved applikasjonens oppstart",
	"content": "Introduksjon til stateless applikasjoner En stateless, eller tilstandsløs, applikasjon skiller ser fra standard applikasjoner ved at den ikke lagrer noe data, verken skjemadata eller metadata om instanser av applikasjonen. Derfor passer stateless applikasjoner godt som innsynstjenester der en sluttbruker eller et system gjør et oppslag mot en eller annen ressurs evt. presenterer data fra en tredjepart basert på hvem brukeren er.\nKonfigurasjon Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre.\nMERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.5.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\n\rI applikasjonsmetadataen er det mulig styre oppførselen en applikasjonen har under oppstart. Om man ønsker at applikasjonen skal oppføre seg som en tilstandsløs applikasjon vil det nå være mulig. For en slik applikasjon vil det ikke bli lagret noe data eller metadata, og applikasjonen vil heller ikke havne i meldingsboksen til sluttbruker. Dette tilsvarer en innsynstjeneste i Altinn 2.\nKonfigurasjonen av dette gjøres i applicationmetadata.json. Eksempel:\n{\r\u0026quot;id\u0026quot;: \u0026quot;ttd/stateless-app-demo\u0026quot;,\r\u0026quot;org\u0026quot;: \u0026quot;ttd\u0026quot;,\r\u0026quot;title\u0026quot;: {\r\u0026quot;nb\u0026quot;: \u0026quot;Stateless App Demo\u0026quot;\r},\r\u0026quot;dataTypes\u0026quot;: [\r{\r\u0026quot;id\u0026quot;: \u0026quot;ref-data-as-pdf\u0026quot;,\r\u0026quot;allowedContentTypes\u0026quot;: [\r\u0026quot;application/pdf\u0026quot;\r],\r\u0026quot;maxCount\u0026quot;: 0,\r\u0026quot;minCount\u0026quot;: 0\r},\r{\r\u0026quot;id\u0026quot;: \u0026quot;Stateless\u0026quot;,\r\u0026quot;allowedContentTypes\u0026quot;: [\r\u0026quot;application/xml\u0026quot;\r],\r\u0026quot;appLogic\u0026quot;: {\r\u0026quot;autoCreate\u0026quot;: true,\r\u0026quot;classRef\u0026quot;: \u0026quot;Altinn.App.Models.StatelessV1\u0026quot;\r},\r\u0026quot;taskId\u0026quot;: \u0026quot;Task_1\u0026quot;,\r\u0026quot;maxCount\u0026quot;: 1,\r\u0026quot;minCount\u0026quot;: 1\r}\r],\r...\r\u0026quot;onEntry\u0026quot;: { \u0026quot;show\u0026quot;: \u0026quot;stateless\u0026quot; } // legg til denne linjen\r}\rI feltet onEntry.show har man mulighet til nå å referere til et layout-set som man ønsker skal vises under oppstarten av applkasjonen. Les mer om layout-sets her.\nLayout-settet man referer til her blir så benyttet som visningen brukeren blir presentert for i det man navigerer til applikasjonen.\nKonfigurasjonsfilen layout-sets.json kan opprettes dersom den ikke finnes fra før av. Den skal ligge i mappen App/ui. I layout-sets.json legger man så inn det aktuelle settet man referer til fra applicationmetadata.json, eksempel:\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;stateless\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Stateless\u0026#34; } ] } I eksempelet over så referer layout-settet stateless til datamodellen Stateless. Eksempel app-struktur på en applikasjon som har satt opp på denne måten:\n├───App ├───config ├───logic ├───models │ Stateless.cs │ Stateless.metadata.json │ Stateless.schema.json │ Stateless.xsd ├───ui │ layout-sets.json │ └───stateless | RuleConfiguration.json │ RuleHandler.js │ Settings.json │ └───layouts FormLayout.json FormLayout.json vil så kunne settes opp på samme måte som en vanlig applikasjon, og vil støtte samtlige komponenter som er mulig å sette opp i en vanlig app, med unntak av:\n Filopplaster Knapp  App frontend vil så skjønne ut fra konfigurasjonen i applicationmetadata.json at den ikke skal instansiere, og hente ned de aktuelle layout-filene og den tilkoblede datamodellen og presentere dette til sluttbrukeren.\nDatapopulering Når man benytter en stateless datatype så vil man kunne populere datamodellen i det app-frontend spør om skjemadataen.\nDatapopuleringen skjer i to steg på det initielle kallet fra frontend (GET):\n Prefill, les mer om dette her. Dataprossesering, les mer om dette her.  På påfølgende oppdateringer på samme skjemadata (POST) så vil man ikke kjøre prefill en gang til, men kalkuleringen trigges. Dette muligjør manipulering av dataen basert på brukerens input selv i en stateless tilstand.\nEksempel på en kalkulering som populerer datamodellen nevnt i eksempelet over:\npublic async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data) { if (instance.GetType() == typeof(StatelessV1)) { StatelessV1 form = (StatelessV1) data; // Her kan du gjøre det du ønsker, f.eks et API-kall  // om tjenesten skal oppføre seg som en innsynstjeneste.  form.Fornavn = \u0026#34;Test\u0026#34;; form.Etternavn = \u0026#34;Testesten\u0026#34;; return true } return false; } Autorisasjon med tredjepartsløsninger Tilgangsstyring for stateless applikasjoner kan løses med standard app-autorisasjon der man hved hjelp av Altinn-roller definerer hvem som har tilgang til å benytte tjenesten. Dersom man har behov for ytteligere sikring av tjenesten kan man implementere logikk for autorisasjon av brukere med tredjepartløsninger. Dette kan være API-er som er eksponert innenfor egen virksomhet eller åpne API fra andre tilbydere.\nI eksempelet nedenfor benyttes Finanstilsynets API til å fastslå om virksomheten som repesenteres av en bruker i Altinn har tilstrekkelige lisenser til å benytte tjenesten.\nKildekoden til applikasjonen som eksempelet er basert på finnes her. (Krever bruker i Altinn Studio.)\nVidere i eksempelet vil betegnelsen bruker være synonymt med en virksomhet representert ved en person i Altinn.\n  Utvid datamodellen med felter for autorisasjon\nI tillegg til et felt for å ta input fra bruker og et felt for å vise fram resultatet, har vi i dette eksempelet et felt for å holde på infomasjon om hvorvidt brukeren er autentisert og et felt for å holde på en dynamisk feilmelding.\n\u0026lt;xs:sequence\u0026gt; \u0026lt;xs:element name=\u0026#34;searchString\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;result\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;userAuthorized\u0026#34; type=\u0026#34;xs:boolean\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;errorMessage\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;/xs:sequence\u0026gt; Hopp til steg 4 dersom applikasjonen kun skal benyttes via API.\n  Legg til felt for å vise feilmelding i brukergrensesnittet\nI brukergrensesnittet til applikasjonen er det tre komponenter. Et søkefelt for brukerinput, et tekstfelt dedikert til å vise fram søkeresultatet og en paragraf som er reservert for feilmeldinger.\nKomponentene er koblet til datamodell og tekstressurs på følgende måte i FormLayout.json\n\u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;sokeBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;SearchString\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;searchString\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: false }, { \u0026#34;id\u0026#34;: \u0026#34;resultatBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Result\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;result\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: true }, { \u0026#34;id\u0026#34;: \u0026#34;errorBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;ErrorMessage\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: true } ]   Legg inn dynamikkregler for å vise/skjule felter\nVi bruker dynamikkregler til å vise/skjule felter avhengig av om en bruker en autorisert eller ikke.\nDet er lagt inn en dynamikkregel i RuleHandler.js som sjekker om et felt i datamodellen har verdien false. Konfigurasjon av regler er beskrevet nærmere her.\nI RuleConfiguration.json ser man hvordan regelen benyttes. Dersom inputverdien fra datamodellen userAuthorized er false, så vises errorBoks-komponenten, mens det motsatte skjer med søke- og resultatfeltene, disse skjules.\nDefault oppførsel vil være det motsatte, altså at søk og resultat er synlig, mens error feltet er skjult.\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;e2dd8ff0-f8f1-11eb-b2bc-5b40a942c260\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;isFalse\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;userAuthorized\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Show\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c260\u0026#34;: \u0026#34;errorBoks\u0026#34; } }, \u0026#34;e2dd8ff0-f8f1-11eb-b2bc-5b40a942c261\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;isFalse\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;userAuthorized\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Hide\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c261\u0026#34;: \u0026#34;sokeBoks\u0026#34;, \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c262\u0026#34;: \u0026#34;resultatBoks\u0026#34; } } } } }   Legg til tekstressurser\nI tillegg til navnet på tjenesten er det lagt inn tre tekstressurser.\nTekstressursen for feilmelding inneholder en placeholder for navnet på brukeren. Variabelen errorMessage vil populeres i datamodellen når det registreres at en bruker ikke er autorisert til å bruke tjenesten.\n{ \u0026#34;id\u0026#34;: \u0026#34;ErrorMessage\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;{0} mangler rettigheter til å bruke denne tjenesten.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;errorMessage\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.lookup\u0026#34; } ] }, { \u0026#34;id\u0026#34;: \u0026#34;Result\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Resultat\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;SearchString\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Legg inn søkeord her:\u0026#34; },   Implementér autorisasjonslogikk\nAlt av dataprosessering for stateless applikasjoner ligger i filen App\\logic\\DataProcessing\\DataProcessingHandler.cs, og det er her autorisasjonslogikken skal plasseres.\nLogikk for å slå opp data og autorisere brukeren ligger i metoden ProcessDataRead. Denne kalles hver gang en bruker åpner applikasjonen eller sendes inn noe input data.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data)\r{\rlookup lookup = (lookup)data;\r// Check if user is authorized to use service\rParty party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)); if (string.IsNullOrEmpty(party.OrgNumber) || !await _finanstilsynet.HasReqiuiredLicence(_settings.LicenseCode, party.OrgNumber))\r{\rlookup.userAuthorized = false;\rlookup.errorMessage = $\u0026quot;{party.Name}\u0026quot;;\rreturn true;\r} // logic for looking up data\rif (!string.IsNullOrEmpty(lookup.searchString))\r{\rlookup.result = $\u0026quot;You typed \\\u0026quot;{lookup.searchString}\\\u0026quot;. This is the result.\u0026quot;;\rreturn true;\r}\rreturn false;\r}\rMetoden starter med logikk for å hente ut skjemadataen slik at denne kan benyttes videre i metoden.\nlookup lookup = (lookup)data Videre kommer logikken for å sjekke om brukeren er autorisert.\n// Check if user is authorized to use service Party party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)) if (string.IsNullOrEmpty(party.OrgNumber) || !await _finanstilsynet.HasReqiuiredLicence(_settings.LicenseCode, party.OrgNumber)) { lookup.userAuthorized = false; lookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;; return true; } For å vite hvem brukeren er, benyttes identifikatoren instance.InstanceOwner.PartyId, denne får vi som input til metoden. Vi slår opp i Altinn sitt register for å hente ut party-objektet som representerer brukeren. Dette kan inneholde en organisasjon eller en person.\nParty party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)) Det gjøres to sjekker for å avgjøre om en bruker er autorisert eller ikke. Først verifiseres det at party-objektet har definert et organisasjonsnummer, dersom dette ikke er tilfellet er brukeren en person, og dermed ikke autorisert.\nDen andre sjekken kaller _finanstilsynet.HasReqiuiredLicence(), en metode som slår opp i finanstilsynets API for å avgjøre om en organisasjonen har en gitt lisens. Implementasjonen av servicen er tilgjengelig her.\nDersom ingen av sjekkene er vellykkede populeres to felter i datamodellen;\n en indikator på at brukeren ikke er autorisert en feilmelding, her kun navnet til brukeren  og true returneres for å indikere at dataverdier har blitt oppdatert.\nlookup.userAuthorized = false; lookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;; return true; Helt til slutt kommer logikken for å vise fram et resultat basert på søkestrengen.\n// logic for looking up data if (!string.IsNullOrEmpty(lookup.searchString)) { lookup.result = $\u0026#34;You typed \\\u0026#34;{lookup.searchString}\\\u0026#34;. This is the result.\u0026#34;; return true; } return false; lookup.result populeres med verdien av oppslaget, i dette tilfellet skriver vi bare søkestrenger tilbake til bruker. Igjen returneres true for å indikere at en dataverdi er blitt endret, og false dersom dette ikke er tilfellet.\n  Starte instans fra et stateless skjema Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre og vil ikke være støttet i Altinn Studio.\nMERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.17.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\n\rFra en tilstandsløs applikasjon har man mulighet til å benytte InstantiationButton-komponenten til å starte en instans. Enn så lenge støtter vi kun å starte en instans innad i samme applikasjonen som stateless skjema vises i. Det å starte en instans i en annn applikasjon er funksjonalitet som kommer.\nDet er laget en eksempel applikasjon som er satt opp som en innsynstjeneste hvor sluttbruker kan velge å starte en instans på den aktuelle applikasjonen. Denne kan brukes til inspirasjon for videre utvikling. Applikasjonen med kildekode finnes her.\nInstansiere med prefill Et bruksområde for det å starte en instans fra et stateless view kan være at man først ønsker at appen skal oppføre seg som en innsynstjeneste hvor brukeren blir presentert for gitte data som er aktuell. Fra denne informasjonen kan brukeren velge å agere videre på dataen som listes opp, og da er man over på en vanlig innsendingstjeneste.\nFor å få til en slik flyt er man først avhengig av å sette opp applikasjonen som en stateless appliksjon som står beskrevet under konfigurasjon. Når dette er gjort kan man utvide stateless viewet til å inkludere InstantiationButton som kan vil starte en ny instans i det brukeren klikker på knappen. Standard oppførsel for denne knappen er å sende inn hele datamodellen som brukeren har benyttet inn som en del av instansieringn under feltet prefill. Om man ønsker å velge ut deler av datamodellen som er benyttet i det tilstandsløse steget vil det også være mulig ved å legge til mapping på InstantiationButton-komponenten. F.eks\n{ \u0026#34;id\u0026#34;: \u0026#34;instantiation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;InstantiationButton\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Start instans\u0026#34; }, \u0026#34;mapping\u0026#34;: { \u0026#34;some.source.field\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;some.other.field\u0026#34;: \u0026#34;id\u0026#34; } } Når brukeren da velger å starte en instans så vil app-frontend hente ut feltene some.source.field og some.other.field fra datamodellen i det tilstandsløse steget og mappe disse mot feltene name og id som sendes med i instansieringskallet for applikasjonen. Eksempel request som vil gå mot backend som man kan mappe over datamodellen man benytter i datamodellen man benytter i innsendingsdelen av applikasjonen:\n{ \u0026#34;prefill\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Ola Nordmann\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;12345\u0026#34; }, ... } Denne prefill verdien kan man så benytte seg av i metoden DataCreation i InstantiationHandler.cs for å mappe mot de feltene man trenger som en del av innsendsingsdelen av applikasjonen under instansieringen. Eksempel:\npublic async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { if (data.GetType() == typeof(MessageV1)) { string name = \u0026#34;\u0026#34;; string id = \u0026#34;\u0026#34;; if (prefill.ContainsKey(\u0026#34;name\u0026#34;)) { name = prefill[\u0026#34;name\u0026#34;]; } if (prefill.ContainsKey(\u0026#34;id\u0026#34;)) { id = prefill[\u0026#34;id\u0026#34;]; } MessageV1 skjema = (MessageV1)data; skjema.Sender = name; skjema.Reference = id; } await Task.CompletedTask; } Instansiere fra en repeterende gruppe Om man i det tilstandsløse steget ønsker at brukeren f.eks velger et element fra en repeterende gruppe å jobber videre på et gitt element kan man sette opp InstantiationButton-komponenten som en del av den repeterende gruppen. Her kan man så konfigurere instansierings-knappen til å mappe felter fra den gitte indeksen brukeren velger å starte en instans fra. Dette krever at man setter opp mapping-feltene med en indeks på den aktuelle gruppen. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;instantiation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;InstantiationButton\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Start ny instans\u0026#34; }, \u0026#34;mapping\u0026#34;: { \u0026#34;people[{0}].name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;people[{0}].age\u0026#34;: \u0026#34;age\u0026#34; } } I den repeterende gruppen vil så {0} bli erstattet med den aktuelle indeksen på gruppen brukeren ønsker å starte fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/deployment/",
	"title": "Deployment",
	"tags": [],
	"description": "Konfigurering av deploy og kjøretids oppsett",
	"content": "Fra versjon 2.0.0 av deployment helm-charten er autoskalering tilgjengelig og aktivert som standard.\nAutoskalering benytter Horizontal Pod Autoscaler) for å automatisk skalere opp og ned en app basert på CPU forbruk.\nNår man skal konfigurere hvordan autoskaleringen oppfører seg må man ta hensyn til to seksjoner i deployment/values.yaml.\n resources cpu/minne garantier og grenser for app pods under kjøring, se: Resources konfigurasjon autoscaling konfigurerer når din applikasjon skal skaleres opp eller ned.  Vi setter noen standard verdier basert på tester vi har utført og erfaringer vi har gjort oss, disse kan endre seg etter hvert som vi får mer erfaringer over tid.\nStandrad verdiene kan du se her\nEt eksempel på hvordan du overskriver verdier:\nI values.yaml i den sentrale helm-charten er replicaCount definert som følger:\nreplicaCount: 2 ... For å overskrive dette i den app endrer du filen deployment/values.yaml og legger replicaCount under deplyoment:\ndeployment: replicaCount: 3 ... Legg merke til at \"deployment:\" er lagt til i forhold til det sentrale charten sin values.yaml. _replicaCount_ er også indentert med to mellomrom.\rI yaml skal indents være mellomrom og ikke tab, benytter du tab vil ikke din yaml være gyldig.\r\rSkalering Initial skalering Initial skalering er konfigurerbart med feltet replicaCount. Hvis autoskalering er aktivert vil autoskalerings logikken overstyre denne verdien. Eksempel hvor initial skalering er satt til 2:\ndeployment: replicaCount: 2 Autoscaling konfigurasjon Autoscaling seksjonen konfigurerer når en applikasjon automatisk skal skaleres. Dette er håndtert av Horizontal Pod Autoscaler i kubernetes.\nFor å lese mer og Horizontal Pod Autoscaler kan du lese kubernetes sin dokumentasjon her.\nStandard verdier hvis ikke overstyrt i deployment/values.yaml\ndeployment: autoscaling: enabled: true replicas: min: 2 max: 10 avgCpuUtilization: 70 behavior: stabilizationWindowSeconds: scaleUp: 0 scaleDown: 120 deployment.autoscaling.replicas min: Det laveste antall pods autoskaleringen har lov til å sette. max: Det høyeste antall pods autoskalering har lov til å sette.\ndeployment.autoscaling.avgCpuUtilization Terskelen for prosent av cpu request som er utnyttet før opp eller ned skalering skal skje.\nOppskaleringen er ikke umiddelbar siden en ny pod trenger tid på å starte (1-2 min i de fleste tilfeller). Hvis alle ressursene i et cluster er reservert må en ny node startes opp i azure (5-10 min i de fleste tilfeller). Det er derfor lurt å ha en liten buffer sånn at applikasjonen kan håndtere lasten frem til kapasiteten er utvidet.\ndeployment.autoscaling.behavior.stabilizationWindowSeconds Stabiliserings vindu er benyttet for å begrense blafring av replikaer når metrikkene som er brukt for skalering svinger.\nSom standard vil en oppskalering skje så fort forbruket er over terskelverdiene. Nedskalering vil vente i to minutter.\nscaleUp: Antall sekunder kubernetes skal vente etter siste skalering før den gjør en ny evaluering om oppskalering. scaleDown: Antall sekunder kubernetes skal vente etter siste skalering før den gjør en ny evaluering om nedskalering.\nResources konfigurasjon For å sette gode requests og eventuelt limits er kjennskap til appen viktig da koden og oppgavene applikasjonen utfører har stor innvirkning på dette. Vi forsøker å sette kode standard verdier som fungerer for så mange av alle appene i Altinn som mulig, men det er ikke sikkert de passer for din app.\nStandard verdier hvis de ikke blir overskrevet i deployment/values.yaml\ndeplyoment: resources: requests: cpu: 300m memory: 256Mi Verdier som er mulige å konfigurere (verdiene under er kun som et eksempel og på ingen måte en fasit)\ndeplyoment: resources: requests: cpu: 200m memory: 256Mi limits: cpu: 1000m memory: 512Mi deployment.resources.requests Denne seksjonen i values.yaml definerer ressursene som din app vil få reservert av kubelet i clusteret.\nRequests er brukt av kubernetes sin skedulerer for å finne noden den skal plassere appen sine pods på. Dette vil begrense hvor mange pods en node kan kjøre før den er full.\nRequests er også brukt av Horizontal Pod autoscaler for å avgjøre om det skal skalere opp eller ned antall replikaer av appen.\nGitt et cluster med noder som har 2 cores (2000 millicores) og 4Gi minne hvor alle pods har requests satt til 200m (200 millicores) og 256Mi.\nAntall pods en node kan kjøre basert på CPU request er: 2000 / 200 = 10\nAntall pods en node kan kjøre basert på minne request er: 4096Mi / 256Mi = 16\nAntall pods en node kan kjøre, med eller uten last i løsningen er da: 10.\nRequests begrenser ikke hvor mye CPU eller minne en applikasjon kan bruke dersom mer er tilgjengelig, men blir det lite ressurser og en pod bruker mer enn requests kan denne blir \u0026ldquo;kastet ut\u0026rdquo; av noden.\ndeployment.resources.limits Denne seksjonen i values.yaml definerer hvor mye en pod kan maksimalt bruke.\nHvis en pod forsøker å benytte mer CPU en det som er satt som limit vil denne bli strupet.\nHvis en pod forsøker å allokere mer minne en det som er satt som limit vil den bli terminert med en Out Of Memory (OOM) error.\nLinkerd Alle applikasjoner som deployes er som standard innlemmet i Linkerd sitt service mesh.\nVi anbefaler på det sterkeste å ikke endre denne innstillingen da den legger på mutual TLS som krypterer all intern kommunikasjon mellom tjenester i klusteret før det forlater en maskin.\ndeployment: ... linkerd: enabled: true ... Volumes and VolumeMounts Disse delene gjør det mulig å mounte opp forskjellige ressurser til filsystemet til en applikasjon. Det er to predefinerte mounts som benyttes av standard funksjonalitet for å blant annet kommunisere med Altinn Platform.\ndeployment: ... volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken På gjeldende tidspunkt er det kun en use case for å legge til andre volumer: Hente hemmeligheter fra Azure Key Vault\nService Service konfigurasjonen gjør det mulig å endre hvilke port som eksponeres internt i clusteret og hvilken intern port dette skal mappes til. Det er sjelden disse verdiene må endres. Hvis din applikasjon kjører på annen port enn 5005 så endrer du internalPort. EksternalPort må ikke endres Standard oppsett er:\ndeployment: ... service: name: deployment type: ClusterIP externalPort: 80 ## If your application is running on another port, change only the internal port. internalPort: 5005 ... Deler som blir overskrevet ved deploy  image ingressRoute  Disse områdene blir overskrevet ved deploy så endringer her vil ha liten til ingen effekt.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/deployment/",
	"title": "Produksjonssetting av apper",
	"tags": [],
	"description": "Tjenesteeier kan selv produksjonssette sine applikasjoner, og gjøre vedlikehold av kode og avhengigheter.",
	"content": "Få tilgang til et produksjonsmiljø Første gang man skal gjøre deploy av en applikasjon til produksjonsmiljøet er det behov for at det er satt opp et eget tjenesteeier-cluster. For å få dette gjelder følgende prosess:\n Send en e-post med en beskjed om hvilken/hvilke apps du har klar til produksjonssetting. Vent på beskjed om at cluster er opprettet.  Denne rutinen trenger bare å følges en gang. Når clusteret er satt opp, er løsningen selvbetjent etterpå.\nProduksjonssette en app Produksjonssetting av applikasjonen gjøres på samme måte som for testmiljøer.\nDatabehandleravtale for behandling av personopplysninger i Altinn Du må fylle ut Vedlegg til Bilag 2 og sende dette til tjenesteeier@altinn.no\nBestille Om skjema-side Altinn vedlikeholder en oversikt over alle tjenester i løsningen. For at Altinn brukerservice skal kunne hjelpe brukerne med en tjeneste, må informasjon legges inn her. Bestillingsskjemaet heter \u0026ldquo;Publiser informasjon om tjeneste på Altinn PROD og TT02\u0026rdquo;, og finnes etter innlogging på altinndigtal.no.\nMerk! Bestillingsskjemaet er inntil videre optimalisert for Altinn II-tjenester. Gjør derfor følgende:\n I feltet \u0026ldquo;Tjenestekode\u0026rdquo;, oppgi 9999 og i feltet \u0026ldquo;Utgavekode\u0026rdquo; oppgi 9999 I feltet \u0026ldquo;Hvem skal bruke skjemaet\u0026rdquo; husk å angi hvilke roller som er satt på tjenesten i tillegg til beskrivelsen av hvem tjenesten er for.  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/maintainance/",
	"title": "Vedlikehold av app i produksjon",
	"tags": [],
	"description": "Applikasjoner i produksjon krever jevnlig vedlikehold og oppdateringer.",
	"content": "Når applikasjonen er satt i produksjon, vil det oppstå behov for å vedlikeholde applikasjonen. Den vanligste vedlikeholdstypen vil være å oppdatere avhengigheter.\nFor å gjøre en ny versjon av applikasjonen tilgjengelig, produksjonssetter man den på samme måte som vanlig.\nInstanser av appen i brukers innboks vil automatisk oppdateres til å bruke siste versjon av applikasjonen, så det er viktig at man ikke innfører endringer som knekker eksisterende instanser.\n\rOppdatere avhengigheter i app\rHvordan oppdatere avhengigheter i en app.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/",
	"title": "Lanserte tjenester",
	"tags": [],
	"description": "Noen av tjenestene som allerede er i produksjon, til informasjon og inspirasjon.",
	"content": "Mars 2022  Transportløyvegarantier (Statens vegvesen)\nInfo | Repo | Kjørende tjeneste  Februar 2022  Algeskjema (Havforskningsinstituttet)\nInfo | Repo | Kjørende tjeneste Søk om tillatelse til å arbeide med asbest (Arbeidstilsynet)\nInfo | Repo | Kjørende tjeneste  Januar 2022  Behovskartlegging for opprettelse av vergemål (Statens sivilrettsforvaltning)\nInfo | Repo | Kjørende tjeneste Forespørsel om endring av vergefullmakt (Statens sivilrettsforvaltning)\nInfo | Repo | Kjørende tjeneste  November 2021  Bestilling av tilgang til Medarbeiderundersøkelsen i staten (STAMI).\nLanseres offisielt på et senere tidspunkt. Info og lenker er derfor ikke tilgjengelig. Avtalevilkår for Medarbeiderundersøkelsen i Staten (STAMI).\nLanseres offisielt på et senere tidspunkt. Info og lenker er derfor ikke tilgjengelig.  August 2021  Valgkort (Valgdirektoratet)\nInfo | Repo | Kjørende tjeneste  Juni 2021  Forhåndsgodkjenning av innreise for kjærestebesøk (UDI).\nInfo | Repo | Kjørende tjeneste  Mai 2021  Søknad for unntak om opphold på karantenehotell ved sterke velferdsgrunner når du reiser til Norge fra utlandet (UDI).\nInfo | Repo | Kjørende tjeneste Melding om registrering av bemanningsforetak (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste Årlig melding – Register over bemanningsforetak (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste  April 2021  Skattemelding med næringsspesifikasjon - pilot (Sirius) (Skatteetaten).\nInfo | Repo | Kjørende tjeneste  Februar 2021  Søknad om forhåndsgodkjenning av innkvartering i forbindelse med innreisekarantene (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste Digital pliktavlevering (Nasjonalbiblioteket).\nInfo | Repo | Kjørende tjeneste  Desember 2020  Søknad om autorisasjon som landmåler (Kartverket).\nInfo | Repo | Kjørende tjeneste Vedlegg til søknad om autorisasjon som landmåler (Kartverket).\nInfo | Repo | Kjørende tjeneste  Juni 2020  Ledige stillinger (RA0678) (SSB).\nInfo | Repo | Kjørende tjeneste Bestill tilgang til REST API (Digdir).\nInfo | Repo | Kjørende tjeneste Be om å bli tjenesteeier (Digdir).\nInfo | Repo | Kjørende tjeneste Godkjenning av bruksvilkår for skytjenester fra Altinn (Digdir).\nInfo | Repo | Kjørende tjeneste  \rApper fra Digdir\rDokumentasjon for apper utviklet av Digitaliseringsdirektoratet.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/",
	"title": "Roadmap for Altinn",
	"tags": [],
	"description": "Høynivå roadmap og funksjonell beskrivelse for Altinn.",
	"content": "Altinn er under kontinuerlig videreutvikling. Du får vite mer om hva vi har gjort og hva vi planlegger å gjøre her. Enn så lenge er det kun roadmap for Altinn Studio og relatert funksjonalitet som er tilgjengelig her. All annen funksjonalitet har en egen roadmap.\nSe diagram nedenfor for detaljert feature oversikt med status for Altinn 3. Hver boks har en link til nærmere forklaring på feature.\n\nKlikk for åpne diagram i fullskjerm\n\rRoadmap for Altinn Studio\rHøynivå roadmap og funskjonelle beskrivelser for Altinn Studio og funksjonalitet som understøtter apper utviklet der.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/",
	"title": "Roadmap for Altinn Studio",
	"tags": [],
	"description": "Høynivå roadmap og funskjonelle beskrivelser for Altinn Studio og funksjonalitet som understøtter apper utviklet der.",
	"content": "\rFor informasjon om hvordan man bruker funksjonalitetene beskrevet her, se seksjonene om apper og API.\n\r\r\rApplikasjonseierfunksjonalitet in Altinn 3\rDette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.\n\r\rSluttbrukerfunksjonalitet i Altinn 3\rDette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/",
	"title": "Altinn Studio docs",
	"tags": [],
	"description": "Lær om Altinn Studio",
	"content": "Altinn Studio docs "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/api/",
	"title": "api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/",
	"title": "Testing av app API-er lokalt",
	"tags": [],
	"description": "Hvordan teste app-APIer lokalt.",
	"content": "\rAPI test org\rNår man kjører applikasjonene lokalt sammen med den lokale testplattformen kan man teste API som applikasjon eksponerer.\n\r\rAPI bruk som sluttbruker\rNår man kjører applikasjonen lokalt så kan man teste API beregnet for sluttbruker.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/",
	"title": "App API",
	"tags": ["api"],
	"description": "Standard API&#39;er eksponert av apper i Altinn 3.",
	"content": "Overview De API funksjonene som er dokumentert her er standard funksjoner i en app basert på app malen i Altinn Studio. Applikasjonseiere kan fritt gjøre endringer, men det er relativt trygt å annta at fjerning av funksjoner vil være ekstremt skjeldent. Enhver app med tillegg eller endringer skal ha sin egen dokumentasjon publisert av applikasjonseieren.\nAlle app API adresser starter med samme navn og filsti, men de varierer fra en app til en annen basert på eier av app og app navn.\nTest miljø (TT02)\nhttps://{org}.apps.tt02.altinn.no/{org}/{appname} Produksjon\nhttps://{org}.apps.altinn.no/{org}/{appname} URL\u0026rsquo;en identifiserer app eier spesifikt domene ved hjelp av applikasjonseier sitt kortnavn org, og identifiserer spesifikk app ved hjelp av både kortnavnet til applikasjonseier og navnet på appen; org/appname.\n\rApp metadata\rApp API for å få metadata informasjon for appen.\n\r\rInstanser\rApp API å jobbe med forekomster av en app.\n\r\rData-elementer\rAPI å jobbe med dataelementene knyttet til en app instans.\n\r\rTilstandsløse data\rAPI til å arbeide med dateelementer uten tilstand som ikke er knyttet til en instans.\n\r\rProsess\rAPI endepunkter for å lede en instans gjennom prosessen som er definert.\n\r\rValidering\rValidering API-endepunktene for instanser og dataelementer.\n\r\rOpenAPI (swagger) for Apps\r\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/app/",
	"title": "app",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/appowner/",
	"title": "Applikasjonseierfunksjonalitet in Altinn 3",
	"tags": [],
	"description": "Dette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.",
	"content": "Lansert funksjonalitet For informasjon om hvordan man bruker funksjonalitetene som er beskrevet her, se brukerdokumentasjonen for Altinn Studio og API.\n\r\rTjenesteutvikling i GUI I brukergrensesnittet til Altinn Studio kan du gjøre følgende:\n Opprette (og finne igjen) en app Laste opp datamodell Legge inn tekster Lage et enkelt skjema (en eller flere sider), med kobling mellom elementer, tekster og datamodell Legge inn dynamikkregler (NB! Kodes i JavaScript) Deploye app til test- og produksjonsmiljø  Tjenesteutvikling via kode Ved å hente ned applikasjonskoden (via Git) lokalt (eller ved å redigere på app-filene i repository-visning) kan du gjøre alle mulige endringer av appen. Dette inkluderer blant annet standardfunksjonalitet for å:\n Lage kalkulerings- og valideringsregler Koble på forhåndsutfylling Legge inn API-oppslag Redigere på prosessen/arbeidsflyten i appen Redigere på autorisasjonsreglene for appen, samt lage egendefinert instansieringslogikk Lage egendefinerte hendelser/events  Teste lokalt Når du har applikasjonskoden lokalt, kan du også benytte deg av muligheten til å ha et lokalt testmiljø for å gjøre de fleste typer testing.\nIntegrasjon med tjenesteeier Altinn 3 har standardiserte API-er som tjenesteeier kan bruke for å hente og laste opp data. For nedlasting bygger Altinn 3 på at tjenesteeier gjør spørringer og laster ned data (pull). I tillegg kan tjenesteeier benytte app-enes API-er for å instansiere eller gjøre endringer på instanser.\nMan kan redusere mengden spørringer ved bruk av push av events - at tjenesteeier varsles når det er data til nedlasting (Q2 2021) (#4728) ✔️\nFor å benytte API-ene som tjenesteeier må man autentisere seg med Maskinporten.\nForvaltning av apper Det er lagt opp til tilgang til overvåking av egne applikasjoner, slik at man kan ha oversikt over hvordan appene fungerer. Se også sidene om vedlikehold av apps.\n Mulighet for å lage en ny app som kopi av en tidligere (Q3 2021) (#5923) ✔️  Kommende funksjonalitet Altinn 3 er i stadig videreutvikling, og funksjonalitet lanseres løpende. Backlogg revideres åtte ganger i året, og mindre endringer kan også forekomme mellom revisjonene. Generelt kan man si at jo lenger frem i tid leveranse er planlagt jo mer usikkert er angitt leveransetidspunkt.\nEndringer beskrevet i kursiv er å regne som på idéstadiet, og er ikke besluttet at skal utvikles.\nTjenesteutvikling i GUI For all kommende funksjonalitet gjør vi vurderinger av om det er egnet å løse det i GUI. På et senere tidspunkt (2023 eller senere) vil vi gjøre et løft for at mer funksjonalitet skal være tilgjengelig via GUI.\n Støtte for branching i Altinn Studio (Q4 2021) (#985)  Datamodellering Den avhengigheten vi i dag har til at datamodellering skal gjøres i et eksternt system vil forsvinne. Noen høydepunkter i planene for datamodellering i Altinn 3 er:\n Å kunne jobbe med en datamodell i et GUI (Q4 2021) (#5551) Integrasjoner med Felles datakatalog (Q1 2022) (#3811) Å kunne få automatisk generert datamodell fra det man bygger av brukergrensesnitt Å kunne få automatisk generert forslag til brukergrensesnitt ut fra datamodellen  Forvaltning av tjenester Vi ønsker å gjøre tjenesteeiere i stand til å selv forvalte sine applikasjoner i Altinn 3. For å få til dette kommer blant annet:\n Mulighet for å avpublisere en applikasjon (Q4 2021) (#3717) Webanalyse for applikasjonene  Integrasjon med tjenesteeier Pull av data vil fortsatt være grunnmønsteret for at tjenesteeier får tilgang til data, men det kommer et par unntak:\n Mulighet for å bruke eFormidling som grensesnitt for å få data direkte fra en Altinn 3-app til tjenesteeiers systemer (Q4 2021) (#4788) Splitt av data - flere tjenesteeiere kan motta data fra samme tjeneste (Q3 2022) (#4274)  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/apps/",
	"title": "Apps",
	"tags": [],
	"description": "Team Apps",
	"content": "Mal tjenesteeier title: Tjenesteeier Lenke til org i Altinn Studio Lenke til org i TUL\nForutsetninger  Systemer hos tjenesteeier for henting/mottak av data Beslutning av at migrering kan starte  \r"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/apps/",
	"title": "apps",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/",
	"title": "Authentication API",
	"tags": [],
	"description": "Beskrivelse av hvordan systemer og tjenesteeiere kan benytte Maskinporten eller ID-porten for å få tilgang til APIer i Altinn 3.",
	"content": "\r\rAutentisere med Maskinporten\rBeskrivelse av hvordan tjenesteeiers systemer kan benytte Maskinporten for å få tilgang til APIer.\n\r\rAutentisere med ID-porten\rBeskrivelse av hvordan systemer kan benytte ID-porten for å få tilgang til APIer i Altinn 3.\n\r\rDelegere API-tilganger til en leverandør\rBeskrivelse av hvordan tjenesteier kan delegere API-tilganger (scopes) til en underleverandør.\n\r\rOpenAPI (swagger) for Authentication\r\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/auto-delete/",
	"title": "Automatisk sletting",
	"tags": [],
	"description": "En applikasjon kan konfigureres til å slette alle spor når prosessen er slutt.",
	"content": "For enkelte applikasjoner vil det være problematisk at det er spor av instanser i arkiv osv. på grunn av sikkerhetshensyn.\nDerfor er det mulig å sette ett flagg i applicationmetadata.json som sørger for at instansen blir fysisk slettet når tjenesteeier bekrefter at det er mottatt. Ved å sette autoDeleteOnProcessEnd til true vil man trigge denne funksjonaliteten.\nEksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/apps-test-prod\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;apps-test-prod\u0026#34; }, \u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.Skjema\u0026#34; }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;6aa7d237-f20f-4d42-9361-0c84cf1a8ed0\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [], \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 1, \u0026#34;maxCount\u0026#34;: 3, \u0026#34;minCount\u0026#34;: 1 } ], \u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: false, \u0026#34;organisation\u0026#34;: false, \u0026#34;person\u0026#34;: false, \u0026#34;subUnit\u0026#34;: false }, \u0026#34;created\u0026#34;: \u0026#34;2020-06-04T12:11:36.9601284Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;someone\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-06-04T12:11:36.9601305Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;someone\u0026#34;, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: true } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/autorisasjon/",
	"title": "autorisasjon",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/maintainance/dependencies/",
	"title": "Oppdatere avhengigheter i app",
	"tags": [],
	"description": "Hvordan oppdatere avhengigheter i en app.",
	"content": "Appen er avhengig av flere ressurser som ligger utenfor selve appen. Dette inkluderer støttebiblioteker med felles funksjonalitet for alle apper og referanse til appen sin frontend.\nDisse avhengighetene er definert noen forskjellige steder i appen, og hver avhengighet refereres til med en spesifikk versjon. Når ressursene oppdateres, publiseres de på nytt som en ny versjon. En ny versjon kommer ofte med ny funksjonalitet eller forbedringer. For at appen skal kunne ta dette i bruk, må man oppdatere hvilken versjon av ressursene appen henter.\nNuget Nuget er .NET sin package manager, hvor vi publiserer kodebibliotek som brukes av alle appene.\nAppen bruker flere støttebiblioteker, som oppdateres fortløpende med forbedringer og ny funksjonalitet. En app refererer til konkrete versjoner av de forskjellige bibliotekene, og disse referansene må oppdateres for å hente inn siste versjon.\nOppgradere til nyeste versjon Tips: Installer Version Lens-utvidelsen for Visual Studio Code.\nDa kan du automatisk se hva som er nyeste versjon av alle pakker når du åpner App.csproj. Støtter også npm.\n\r\r Finn fram referansene til bibliotekene i appen. Referansene til biblioteker ligger i filen App/App.csproj i appens repo.  F.eks.:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.Extensions.Logging.Debug\u0026#34; Version=\u0026#34;3.1.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;3.1.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt;  Sjekk om det har kommet en oppdatert versjon av bibliotekene:  Altinn.App.Api Altinn.App.Common Altinn.App.PlatformServices   Oppdater de aktuelle referansene til den siste versjonen og lagre filen. Sjekk om det er noen breaking changes ifm endringer i bibliotekene, og gjør ev. endringer som beskrives for å løse ev. problemer. Bygg og deploy appen på nytt.  App frontend App frontend lastes inn av appen runtime, via en lenke til javascript-filen som er app frontend. Denne javascript-filen versjoneres ihht. Semantic Versioning:\n Given a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\n App\u0026rsquo;en refererer som standard til en major versjon av app frontend, f.eks. versjon 1.x.y. Med mindre det kommer en ny major versjon vil alle oppdateringer med ny minor eller patch versjoner komme med automatisk. Om det kommer en ny major versjon må man eksplisitt oppdatere appen til å referere til denne.\nDersom man ønsker å referere til en spesifikk versjon av app frontend (f.eks. 1.2.3) så kan dette spesifiseres direkte i url\u0026rsquo;en som peker på app frontend.\nOppgradere til nyeste versjon / spesifisere versjon Referansen til app frontend ligger i App/views/Home/Index.cshtml.\nDet er 2 referanser som må oppdateres:\n Referansen til altinn-app-frontend.js-filen som er app frontend koden.  \u0026lt;script src=\u0026#34;https://altinncdn.no/toolkits/altinn-app-frontend/\u0026lt;VERSJONSNUMMER\u0026gt;/altinn-app-frontend.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;  Referansen til altinn-app-frontend.css som inneholder styling for app frontend.  \u0026lt;script src=\u0026#34;https://altinncdn.no/toolkits/altinn-app-frontend/\u0026lt;VERSJONSNUMMER\u0026gt;/altinn-app-frontend.css\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Søk etter filnavnet (altinn-app-frontend.js eller altinn-app-frontend.css) og erstatt versjonsnummeret (f.eks. 1) med ønsket versjonsnummer (f.eks. 2).\nHusk: Dersom man setter kun major versjon (f.eks. 2), så vil alle oppdateringer innenfor denne major versjoner (bugfix, ny funksjonalitet som ikke er breaking) komme med automatisk. Dersom man setter en spesifikk versjon (f.eks. 2.0.0) så vil appen hente akkurat denne versjonen, helt til referansen evt. oppdateres til å bruke en annen versjon.\nDeployment Deployment utføres ved hjelp av helm charts. Standard deployment oppsett for apps hentes fra altinn-studio sitt helm repository.\nEr du i tvil om du benytter siste deployment strategi kan du følge migreringsguiden her\nFor å finne siste versjon av helm-charten kan du enten sjekke releases av charten deployment her eller legge inn helm repoet lokalt og søke i dette på følgende måte:\n# Legg til helm altinn-studio helm repo helm repo add altinn-studio https://charts.altinn.studio # Søk for versjoner av altinn-studio/deployment charten helm search repo -l altinn-studio/deployment Hvis det er ny versjon av helm charten sjekk changelog for å se hva som er oppdatert i versjonen.\nFor å ta i bruk en ny versjon oppdater versjon under dependencies i deployment/Chart.yaml\napiVersion: v1 description: A Helm chart for Kubernetes name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 \u0026lt;--- Oppdater her "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/bekreftelsessteg/",
	"title": "bekreftelsessteg",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/bli-tjenesteeier/",
	"title": "Bli tjenesteeier",
	"tags": ["app"],
	"description": "Dokumentasjon av appen for å bli tjenesteeier i Altinn.",
	"content": "TODO: Dokumentasjon, screenshots, etc\n Info Repo Kjørende tjeneste  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i app frontend i v3.0.0",
	"content": "As of v3.0.0 of app frontend, the font Altinn-DIN replaces the Roboto font that was used previously.\nOnce an app is upgraded to use v3 of the app frontend, all CSS expects the Altinn-DIN font to be loaded. In order for the app to display fonts as expected, the font that is loaded with the app must be updated.\nIn App/views/Home/Index.cshtml, replace the line\n\u0026lt;link href=\u0026#34;https://altinncdn.no/fonts/roboto/latin/roboto.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; with\n\u0026lt;link href=\u0026#34;https://altinncdn.no/fonts/altinn-din/altinn-din.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; The updated file, referring to v3 of app frontend, should reflect the changes of the file on the right:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v3.0.0.",
	"content": "We have added a new PDF handler to make it possible to hide pages and components in PDF.\nThe new version of the Altinn.App.* packages have breaking changes:\nUpdating to this version will require changes in multiple files.\n Updated package dependencies\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate nuget dependencies in App.csproj to version 3.0.0. \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt;  Create a new file for a new class called PdfHandler in the logic/Print folder File from template using System.Threading.Tasks; using Altinn.App.Common.Models; namespace Altinn.App.AppLogic.Print { /// \u0026lt;summary\u0026gt;  /// Handler for formatting PDF.  /// \u0026lt;/summary\u0026gt;  public class PdfHandler { /// \u0026lt;summary\u0026gt;  /// Method to format PDF dynamic  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;the layoutsettings\u0026lt;/param\u0026gt;  /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;data object\u0026lt;/param\u0026gt;  public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await Task.FromResult(layoutSettings); } } }  Changes to the App.cs file\nAdd using using Altinn.App.AppLogic.Print; using Microsoft.Extensions.Options; using Microsoft.AspNetCore.Http; using Altinn.App.Services.Configuration; Add a new private field below InstantiationHandler\nprivate readonly PdfHandler _pdfHandler; Change constructor from:\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService, instanceService) to:\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService, IOptions\u0026lt;GeneralSettings\u0026gt; settings, IText textService, IHttpContextAccessor httpContextAccessor) : base( appResourcesService, logger, dataService, processService, pdfService, prefillService, instanceService, registerService, settings, profileService, textService, httpContextAccessor) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService); _pdfHandler = new PdfHandler(); } Add method\n/// \u0026lt;summary\u0026gt; /// Hook to run logic to hide pages or components when generatring PDF /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;The layoutsettings. Can be null and need to be created in method\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data that there is generated PDF from\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;Layoutsetting with possible hidden fields or pages\u0026lt;/returns\u0026gt; public override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); }   "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v4.0.0.",
	"content": "Altinn.App.* librarires target .Net 5 now, which requires that the application does the same.\nIn addition, all references to app and platform services have been moved from Startup.cs and should be replaced with two method calls.\nFollow the instructions below to ensure that the app is compatible with version 4 of the Altinn.App.* packages.\n  Update target framework and package dependencies\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate target framework to .Net 5 by replacing\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; with\n\u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; In the same file, update the Altinn.App.* package references to version 4.0.0.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;4.0.0\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;4.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;4.0.0\u0026#34; /\u0026gt; The changes in the file should match the image below:\n  Update Dockerfile to use .Net 5 images\nThe Dockerfile can be found in the root folder of the application repository.\nUpdate build image by replacing\nFROMmcr.microsoft.com/dotnet/core/sdk:3.1-alpine AS build with\nFROMmcr.microsoft.com/dotnet/sdk:5.0-alpine AS build And update the runtime image by replacing\nFROMmcr.microsoft.com/dotnet/core/aspnet:3.1-alpine AS final with\nFROMmcr.microsoft.com/dotnet/aspnet:5.0-alpine AS final The changes in the file should match the image below:\n  Replace references to services with call to extension method\nIn the App folder you will also find Startup.cs\nSeveral lines of code will be removed and replaced with the two lines below.\nservices.AddAppServices(Configuration, _env); services.AddPlatformServices(Configuration, _env); The code that should be removed from the file is marked in pink in the pictures below, which cover one section of the file each.\nDepending on how many custom changes you have made in your file the line numbers might not match. Do not worry, the services should still be grouped togheter roughly as shown in the picture. The application will run even if not all services are removed, so just do your best.\nStart by removing referenes to the Altinn App services.\nRemove references to all the Altinn Platform services.\nRemove all loading of configuration files.\nRemove logic to configure Application insights.\nRemove private method for retrieving the key for Application Insights.\nAs previously stated the removed references are now replaced by calls to two new methods that will load all existing and future platform and app services into your application.\nservices.AddPlatformServices(Configuration, _env); loads all configurations and services that the app requires to use Altinn Platform functionality, and services.AddAppServices(Configuration, _env); loads all remaining configurations and services that the app requires such as Authorization and Prefill services.\nEnsure that these lines are added withing the ConfigureServices fuction.\n  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/breaking-changes/",
	"title": "Breaking changes",
	"tags": [],
	"description": "Oversikt over breaking changes introdusert i deployment i v1.1.0",
	"content": "Helm chart flyttet til eksternt repository. Følg migreringsguiden\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v2/breaking-changes/",
	"title": "Breaking changes",
	"tags": [],
	"description": "Oversikt over breaking changes introdusert i deployment i v2.0.0",
	"content": " Endring på navnet til deployment i kubernetes fører til en nedetid opp til tiden applikasjonen bruker på å starte Standard antall replikas ved start er endret fra 1 til 2 og autoskalering påskrudd som standard (min: 2, max: 10) Hvis din applikasjon kun kan ha en replika må overstyres i deployment/values.yaml  deployment: replicaCount: 1  autoscaling: enabled: false "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/build/",
	"title": "build",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/case/",
	"title": "case",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/confirmation/",
	"title": "confirmation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/datamodel/",
	"title": "datamodel",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/dataprocessing/",
	"title": "Dataprosessering",
	"tags": [],
	"description": "Hvordan legge til kalkuleringer og annen dataprosessering?",
	"content": "Dataprosessering kjøres på serveren, og er basert på input fra sluttbruker/skjemadata. Dataprossering kan være kan være rent matematiske kalkuleringer, det kan også være å overføre verdier mellom felter, resultater av API-kall, osv.\nDataprossering kodes i C#, i filen DataProsessingHandler.cs. Denne filen kan redigeres enklest ved å laste ned kildekoden til app\u0026rsquo;en og redigere på egen maskin, f.eks. i Visual Studio Code. Datamodellen med skjemadata er tilgjengelig og kan redigeres/oppdateres etter ønske/behov.\nDataprossering kjøres hver gang data lagres og når data hentes ut fra API. Med auto-lagring på (dette er standard) vil dataprossering kjøres hver gang en bruker har gjort en endring og hopper ut av et felt.\nFor å sikre optimal opplevelse og kontroll er applikasjonstemplaten to forskjellige hendelser hvor logikk kan plasseres.\n ProcessDataWrite kjøres når data lagres ProcessDataRead kjøres når data leses fra databasen  VIKTIG: Når en dataprossering er kjørt som har oppdatert dataene på server, må front-end få beskjed om dette, sånn at de oppdaterte dataene kan lastes inn.\rFor å gjøre dette, må `ProcessDataWrite`-metoden returnere `true` om det er noen av dataene som har blitt oppdatert.\rHvis dette ikke gjøres, vil de oppdaterte dataen ikke være synlig for sluttbruker før de ev. laster inn siden på nytt.\r\rEksempel på kode fra app som prosesserer og populerer forskjellige data under lagring.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite( Instance instance, Guid? dataId, object data) { bool edited = false; if (data is SoknadUnntakKaranteneHotellVelferd model) { string org = instance.Org; string app = instance.AppId.Split(\u0026#34;/\u0026#34;)[1]; int partyId = int.Parse(instance.InstanceOwner.PartyId); Guid instanceGuid = Guid.Parse(instance.Id.Split(\u0026#34;/\u0026#34;)[1]); // handling mapping of multiple choice velferdsgrunner  if (!string.IsNullOrEmpty(model.velferdsgrunner?.sammenstilling)) { model.velferdsgrunner.helseproblemer = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;helseproblemer\u0026#34;); model.velferdsgrunner.barnefodsel = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnefodsel\u0026#34;); model.velferdsgrunner.begravelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;begravelse\u0026#34;); model.velferdsgrunner.naerstaaende = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;naerstaaende\u0026#34;); model.velferdsgrunner.adopsjon = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;adopsjon\u0026#34;); model.velferdsgrunner.sarligeOmsorg = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;sarligeOmsorg\u0026#34;); model.velferdsgrunner.barnAlene = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnAlene\u0026#34;); model.velferdsgrunner.hjemmeeksamen = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;hjemmeeksamen\u0026#34;); model.velferdsgrunner.arbeidunntak = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;arbeidunntak\u0026#34;); model.velferdsgrunner.andreVelferdshensyn = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;); model.velferdsgrunner.andreVelferdshensynBeskrivelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;) ? model.velferdsgrunner.andreVelferdshensynBeskrivelse : null; edited = true; } else { model.velferdsgrunner = null; } // set data for receipt if not set  if (string.IsNullOrEmpty(model.applogic?.altinnRef)) { model.applogic ??= new Applogic(); Party party = await _registerService.GetParty( int.Parse(instance.InstanceOwner.PartyId)); model.applogic.avsender = $\u0026#34;{instance.InstanceOwner.PersonNumber}-{party.Name}\u0026#34;; model.applogic.altinnRef = instance.Id.Split(\u0026#34;-\u0026#34;)[4]; } } return await Task.FromResult(edited); } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/dataprosessering/",
	"title": "dataprosessering",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/debug/",
	"title": "Debugging av app",
	"tags": [],
	"description": "Når man kjører appene lokalt kan man debugge ved hjelp av ulike verktøy.",
	"content": "Følgende beskrivelse forutsetter at du har clonet applikasjonen fra Altinn Studio Repositories og har filene liggende på lokal harddisk.\nDebugging i Visual Studio Code For å debugge applikasjonen lokalt må du åpne applikasjonsprosjektet i Visual Studio Code. Velg åpne folder og bla deg frem til hvor repostoriet er lagret på din maskin.\nVelg debugging knappen til venstre i vertikal meny.\nDet er to måter å starte debugging av en applikasjon lokalt:\nStarte appen fra Visual Studio Code (.NET Core Launch) Denne metoden er den enkleste. Her vil Visual Studio Code starte applikasjonen og koble seg til i en og samme prosess\nVelg .NET Core Launch og trykk på den grønne \u0026ldquo;play\u0026rdquo; knappen.\nApplikasjonen vil da starte og han vil spørre om du skal starte en browser. Velg bare close.\nÅpne et browservindu og gå til http://altinn3local.no (forutsetter at du har startet lokal utviklingsplattform).\nStarte appen fra commando vindu Dette forutsetter at du har startet applikasjonen allerede. Gå til folderen hvor applikasjonen ligger og kjør kommando for å starte dotnet prosessen.\nI Visual Studio Code ha åpnet folderen med applikasjonsprosjektet. Attach deg til prosessen som heter Altinn.App.exe\nLegg til Breakpoints og analysere kode Sett breakpoints i code der du vil at debugger skal stoppe\nDer debugger stopper kan du analysere lokale verdier på objekter for å finne ut hvordan kode fungerer og eventuelt finne feil.\nLes mer om debugging i Visual Studio Code i dokumentasjonen til code.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/delegate-scopes/",
	"title": "Delegere API-tilganger til en leverandør",
	"tags": [],
	"description": "Beskrivelse av hvordan tjenesteier kan delegere API-tilganger (scopes) til en underleverandør.",
	"content": "Enkelte tjenesteeiere ønsker at en underleverandør skal kunne agere på vegne av dem, f.eks. leverandører av fagsystemer. For å få til det, så må disse API-tilgangene delegeres til leverandøren ved bruk av Altinn.\nDet er tjenesteeiers ansvar å selv fjerne delegeringene om behovet for tilgang hos leverandør forsvinner.\nDelegering av API-tilganger til leverandør Som en bruker som er nøkkelrolleinnehaver for tjenesteeier (typisk daglig leder aka DAGL), åpne \u0026ldquo;Andre med rettigheter til virksomheten\u0026rdquo;.\nSå må de nødvendige rettighetene gis.\n Altinn tjenesteeier-API: Appinstanser (full tilgang) - gir tilgang til scopes for både read og write. Altinn tjenesteeier-API: Appinstanser (lesetilgang) - gir kun tilgang til read.  Fjerning av delegering Delegeringer som er gjort kan også fjernes. Om en leverandør ikke lenger har behov for API-tilganger så er det tjenesteeier sitt ansvar å fjerne disse.\nScopes Delegering gir tilgang til disse scopene for leverandør:\naltinn:serviceowner/instances.read altinn:serviceowner/instances.write "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/deploy/",
	"title": "deploy",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/development/",
	"title": "development",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/",
	"title": "DevOps",
	"tags": [],
	"description": "Hvordan vi gjør DevOps",
	"content": "Fullscreen\n\rTeams\rVåre DevOps-teams\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/",
	"title": "Apper fra Digdir",
	"tags": [],
	"description": "Dokumentasjon for apper utviklet av Digitaliseringsdirektoratet.",
	"content": "\r\rBli tjenesteeier\rDokumentasjon av appen for å bli tjenesteeier i Altinn.\n\r\rGodkjenning av bruksvilkår for skytjenester fra Altinn\rDokumentasjon av appen for å godkjenne bruksvilkår for Altinn.\n\r\rOppgjør etter dødsfall\rDokumentasjon av arkitektur, design, funksjonalitet og apper relatert til oppgjør etter dødsfall.\n\r\rBestill tilgang til REST API\rDokumentasjon av appen for å bestille API-nøkler for bruk i Altinn.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/dynamic/",
	"title": "Dynamikk",
	"tags": [],
	"description": "Hvordan legge til dynamikk?",
	"content": "Introduksjon Dynamikk er hendelser som skjer på klient-siden. Disse kan deles opp i to kategorier:\n Beregning - kjøre beregninger på klient-side, og oppdatere felter med ny verdi Vis/skjul felter - bestemme om felter skal vises eller skjules basert på verdier i skjema.  Det er to måter å legge til og endre dynamikkregler for en Altinn App.\n Direkte i Altinn Studio under Lage-fanen. Velg Rediger dynamikk i høyre-menyen. I lokalt utviklingsmiljø ved å jobbe i filen RuleHandler.js som finnes i App/ui-mappen .  All dynamikk skrives som funksjoner i JavaScript i RuleHandler-filen. Funksjonene som er definert i denne filen kan videre konfigureres til å kjøres for feltene i skjemaet.\nKoden som definerer beregninger eller regler for vis/skjul bør settes opp slik at den håndterer eventuell feil i input.\rBlant annet bør de håndtere å motta et tomt felt, eller tekst der man forventer et tall, uten å kræsje.\rDersom dynamikken ikke fungerer som forventet, ta en titt på koden som definerer\rberegninger eller regler for vis/skjul for å se om det er noe feilhåndtering som mangler.\r\r**MERK**: for å støtte beregning/vis-skjul felter på eldre nettlesere må man skrive javascript koden man legger i `RuleHandler.js` i den versjonen av ECMA-script som den aktuelle nettleseren støtter. For IE11 vil dette være ECMA-script 5. \rLegg til/rediger funksjoner for beregninger eller vis/skjul I filen RuleHandler.js er det satt opp 2 javascript-objekter:\n ruleHandlerObject - funksjoner for beregninger conditionalRuleHandlerObject - funksjoner med regler for vis/skjul  Det er inne i disse at de forskjellige funksjonene skal defineres. I tillegg er det satt opp to hjelpe-objekter (ruleHandlerHelper og conditionalRuleHandlerHelper), hvor man skal sette opp hva slags input de forskjellige funksjonene forventer å få inn. Dette gjør det mulig å konfigurere opp reglene i Altinn Studio senere. For at en funksjon skal være tilgjengelig for å konfigureres som dynamikk, må selve funksjonen være definert i hoved-objektet (ruleHandlerObject eller conditionalRuleHandlerObject), og parametrene den forventer å få inn må være satt opp i det tilhørende hjelpe-objektet.\nStrukturen på hjelpe-objektet vises under:\nvar ruleHandlerHelper = { \u0026lt;name_of_rule\u0026gt;: () =\u0026gt; { return { \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34;, \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34;, \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34; ... }; } } Strukturen på hoved-objektet, som inneholder funksjoner som brukes i dynamikk, vises under:\nvar ruleHandlerObject = { \u0026lt;name_of_rule\u0026gt;: (\u0026lt;input_variable_name\u0026gt;) =\u0026gt; { // Do something here  // Values from input parameters defined in  // helper can be accessed through the object passed  // into the rule, f.ex.  // \u0026lt;input_variable_name\u0026gt;.\u0026lt;input_param\u0026gt;  } } For eksempel, for å lage en regel som returnerer summen av to tall (beregning), vil man trenge følgende kode:\nvar ruleHandlerHelper = { sum: () =\u0026gt; { return { field1: \u0026#34;Field 1 in sum\u0026#34;, field2: \u0026#34;Field 2 in sum\u0026#34; }; } } var ruleHandlerObject = { sum: (data) =\u0026gt; { // Check if data is available  if (!data) return; // Check if value from input fields are available  // If not, use value 0 in sum  data.field1 = data.field1 ? data.field1 : 0; data.field2 = data.field2 ? data.field2 : 0; // return the sum  return data.field1 + data.field2; } } Noen standard-metoder for beregniner, med hjelpe-objekt, er satt opp automatisk når app\u0026rsquo;en lages i Altinn Studio. Noen av disse er vist i eksempelet under.\n   Method name Description Parameters Defined in object/helper     sum Returnerer summen av 2 verdier value1, value2 ruleHandlerObject/ruleHandlerHelper   fullName Returnerer to tekster (fornavn og etternavn) satt sammen med mellomrom mellom. firstName, lastName ruleHandlerObject/ruleHandlerHelper   lengthGreaterThan4 Returnerer true dersom verdien den får inn er lengre enn 4 karakterer lang. value conditionalRuleHandlerObject/conditionalRuleHandlerHelper    Regler for dynamikk kjøres dersom det har skjedd en endring i input-parametrene til de forskjellige reglene. Funksjonene som da kjøres må kunne håndtere dersom det f.eks. har kommet inn kun 1 av 2 parametre eller lignende.\nEt eksempel på hvordan dette kan gjøres er vist i sum-funksjonen under, hvor man tester hvilke parametre man har fått inn, og setter verdi til 0 på den/de parametre som mangler, sånn at regelen fortsatt fungerer.\nvar ruleHandlerObject = { sum: (obj) =\u0026gt; { obj.value1 = obj.value1 ? +obj.value1 : 0; obj.value2 = obj.value2 ? +obj.value2 : 0; return obj.value1 + obj.value2; }, fullName: (obj) =\u0026gt; { return obj.firstName + \u0026#39; \u0026#39; + obj.lastName; } } var ruleHandlerHelper = { sum: () =\u0026gt; { return { value1: \u0026#34;Value 1\u0026#34;, value2: \u0026#34;Value 2\u0026#34; } }, fullName: () =\u0026gt; { return { firstName: \u0026#34;First name\u0026#34;, lastName: \u0026#34;Last name\u0026#34; }; } } var conditionalRuleHandlerObject = { lengthBiggerThan4: (obj) =\u0026gt; { if (obj.value == null) return false; return obj.value.length \u0026gt;= 4; } } var conditionalRuleHandlerHelper = { lengthBiggerThan4: () =\u0026gt; { return { value: \u0026#34;value\u0026#34; } } } Konfigurere dynamikk for skjema-komponenter  Legg til de skjema-komponentene som ønskes i layout. I høyre-menyen, velg å legge til Regler for beregninger eller Regler for vis/skjul felt.  Velg en tilgjengelig funksjon som gjør det du ønsker. Legg evt. til en ny funksjon, se beskrivelse over.  Sett opp hvilke(t) felt som skal fungere som input til funksjonen - her er det felt i datamodellen som gjelder.  Sett opp hvilke(t) felt som skal påvirkes av regelen (skal motta beregnet verdi, eller skal vises/skjules) - her er det skjemakomponent som gjelder.   For regler for vis/skjul felt kan man velge flere felter som skal vises/skjules basert på samme regel.  Lagre konfigurasjonen. Test at det fungerer som forventet.  Eksisterende oppsett ligger synlig i høyre-menyen og kan redigeres/slettes.\nKonfigurasjonen legges i filen App/ui/RuleConfiguration.json. Denne kan også redigeres manuelt ved behov.\nEksempel på bruk av dynamikk i skjema Scenario:\nEn app med skjema som har flere felter for input. En av disse er en radioknapp-gruppe, med valgene \u0026ldquo;Ja\u0026rdquo; og \u0026ldquo;Nei\u0026rdquo;. Avhengig av hva sluttbruker velger her, skal forskjellig innhold vises i skjemaet:\n Ja: Et nytt input-felt vises, sammen med ekstra informasjon om hvordan feltet skal fylles ut. Nei: En annen informasjons-tekst vises.  Dette kan gjøres ved å legge inn følgende i RuleHandler.js, enten via Rediger dynamikk i Altinn Studio, eller ved å laste ned kildekoden til appen og redigere lokalt.\nvar conditionalRuleHandlerObject = { sjekkVirksomhetIDrift: (obj) =\u0026gt; { return (obj.value \u0026amp;\u0026amp; obj.value === \u0026#34;Ja\u0026#34;); }, sjekkVirksomhetIkkeIDrift: (obj) =\u0026gt; { return (!obj.value || obj.value != \u0026#34;Ja\u0026#34;); } } var conditionalRuleHandlerHelper = { sjekkVirksomhetIDrift: () =\u0026gt; { return { value: \u0026#34;Verdi\u0026#34; } }, sjekkVirksomhetIkkeIDrift: () =\u0026gt; { return { value: \u0026#34;Verdi\u0026#34; } } } Her har to funksjoner blitt opprettet, som sjekker om verdien er henholdsvis \u0026ldquo;Ja\u0026rdquo; eller ikke. Etter at denne koden er lagt til, kan regelen konfigureres i Altinn Studio. Resultatet vises under.\nDynamikk i repeterende gruppe Det er også mulig å sette opp dynamikk innad i en repeterende gruppe. Dette krever at man først setter opp regelen som vanlig, og så redigerer på oppsettet App/ui/RuleConfiguration.json manuelt. Helt konkret, er det følgende som må endres:\n For alle inputParams, må man legge til {0} etter gruppe-delen av data-modellen. F.eks. Datamodell.gruppe{0}.felt. Dette erstattes i koden av indeksen til hvert enkelt innslag av den repeterende gruppen. For alle selectedFields (altså feltene som påvirkes av reglen), må man legge til {0} bak felt-id\u0026rsquo;en. F.eks. skjemaFelt1{0} I tillegg må man legge enn en ny egenskap på regelen, repeatingGroup. Denne skal inneholde id\u0026rsquo;en til gruppen i layout-filen.  Et eksempel på en regel som er satt opp for repeterende grupper vises under:\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;9f9f2a50-360b-11ea-b69a-8510e2e248b9\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;lengthBiggerThan4\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;Skjemainnhold.personalia.arbeidserfaring{0}.stilling\u0026#34;  }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Show\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;962e2f60-3797-11ea-bfa5-9922024b4738\u0026#34;: \u0026#34;a-e-4{0}\u0026#34;,  \u0026#34;something\u0026#34;: \u0026#34;arbeidsgiver-adresse{0}\u0026#34; }, \u0026#34;repeatingGroup\u0026#34;: {  \u0026#34;groupId\u0026#34;: \u0026#34;arbeidserfaring-group\u0026#34;, } } } } } Eksempel med mer kompleks dynamikk Example with more complex dynamics\nScenario: Et skjema med to sett med radioknapper (ja/nei) og en avkrysningsboks.\n Når skjema lastes, er kun det første settet med radioknapper synlig. Hvis brukeren velder Ja, vises det andre settet med radioknapper.  Hvis brukeren velger Ja i det andre settet, blir avkrysningsboksen synlig. Hvis brukeren går tilbake til det første settet med radioknapper og velger nei, blir både det andre settet med radioknapper og avkrysningsboksen ikke lenger synlig.    Alternativ 1 Dette kan settes opp ved å lage 2 forskjellige betingelser for når feltene skal vises:\n En betingelse for det andre settet med radioknapper  Vises dersom Ja er valgt i det første settet   En betingelse for avkrysningsboksen  Vises når Ja er valgt i begge sett med radioknapper.    Koden for å løse dette kan være:\nvar conditionalRuleHandlerObject = { showField2: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.field1 \u0026amp;\u0026amp; obj.field1=== \u0026#34;yes\u0026#34;) { return true; } return false; }, showField3: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.field1 \u0026amp;\u0026amp; obj.field1 === \u0026#34;yes\u0026#34; \u0026amp;\u0026amp; obj.field2 \u0026amp;\u0026amp; obj.field2 === \u0026#34;yes\u0026#34;) { return true; } return false; } } var conditionalRuleHandlerHelper = { showField2: () =\u0026gt; { return { field1: \u0026#34;Field 1\u0026#34; }; }, showField3: () =\u0026gt; { return { field1: \u0026#34;Field 1\u0026#34;, field2: \u0026#34;Field 2\u0026#34; }; } } Alternativ 2 Dette kan også settes opp ved å bruke den samme betingelsen for å vise både det andre settet med radionkapper og avkrusningsboksen. I tillegg må man da ha en regel som sletter verdien i det andre settet med radioknapper dersom verdien i det første settet settes til Nei:\nvar ruleHandlerObject = { clearField: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.checkValue === \u0026#34;no\u0026#34;) { return \u0026#34;\u0026#34;; } return obj.currentValue; } } var ruleHandlerHelper = { clearField: () =\u0026gt; { return { checkValue: \u0026#34;check against this value\u0026#34;, currentValue: \u0026#34;the current value\u0026#34; } } } var conditionalRuleHandlerObject = { showField: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.checkField \u0026amp;\u0026amp; obj.checkField === \u0026#34;yes\u0026#34;) { return true; } return false; } } var conditionalRuleHandlerHelper = { showField: () =\u0026gt; { return { checkField: \u0026#34;check against this value\u0026#34; }; } } Dynamikk i PDF Fra versjon 3.0.0 er det også mulig å legge inn dynamikk for PDF. Dette gjøres i PDF Handler. Her kan man ved hjelp av logikk velge å skjulte felter eller sider i print.\nAppen må inkludere layout/ui/Settings.json filen som her.\nTeknisk er det veldlig likt hvordan man gjør det for validering.\nEksempel nedenfor som skjuler et gitt felt basert på innhold. Komponentene er basert på ID som man finner i layouts filene til skjema.\npublic async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data is Skjema) { Skjema skjema = (Skjema)data; if (skjema?.Innledninggrp9342?.Kontaktinformasjongrp9344?.KontaktpersonNavndatadef2?.value.Contains(\u0026#34;tulling\u0026#34;) == true) { layoutSettings.Components = new Components(); layoutSettings.Components.ExcludeFromPdf = new System.Collections.Generic.List\u0026lt;string\u0026gt;(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;079f205b-c9ea-414d-9983-0d158e833e8a\u0026#34;); } } return await Task.FromResult(layoutSettings); } ``` "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/dynamikk/",
	"title": "dynamikk",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/expose/",
	"title": "Eksponere APIer fra en app",
	"tags": [],
	"description": "Man kan legge til flere API enn det som er definert som standard API for applikasjoner utviklet i Altinn Studio.",
	"content": "Applikasjonene som utvikles i Altinn Studio baserer seg i dag på ASP.NET Core for back-end. Dette gir høy fleksibiltet til å endre og modifisere applikasjonene.\nLegge til API kontroller For å kunne eksponere et nytt API i applikasjonen må det legges til en eller flere API kontrollere.\nNedenfor vises et eksempel fra en API controller som er lagt til i en gitt app. Her settes det opp hvilken path API skal lytte på og logikken.\nusing System; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; namespace Altinn.App.Api.Controllers { [ApiController] [Route(\u0026#34;{org}/{app}/CustomApi\u0026#34;)]  public class CustomApiController : ControllerBase { [HttpGet(\u0026#34;TimeInfo\u0026#34;)]  public async Task\u0026lt;ActionResult\u0026gt; Get() { return Ok(DateTime.Now); } } } Koden kan ses i dette repositoriet.\nI dokumentasjonen til ASP.NET kan du lese flere detaljer om mulighetene for å eksponere API.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/events/",
	"title": "Events API",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Platform API for hendelser.",
	"content": "Overview Events are in this context is information about events created by applications or other sources. The event itself is based on the CloudEvent standard and is a small JSON structure containing the most important information of an event. Details are found here.\nThe events APIs are used to access events created by applications in Altinn Apps and other event sources that use Altinn Platform as av \u0026ldquo;event hub\u0026rdquo;.\nSubscription The highly preferred way to use events is to set up a subscription that enables push of events to a webhook-endpoint. This is done through the subcriptions API. This API supports the following consumers\n Persons, authenticated through ID-porten Orgs, authenticated through Maskinporten  The subscriptions API is described here as Swagger.\nThe webhook endpoint needs to be able to accept cloud event that is posted through HTTPS to the endpoint URL.\nThe push functionality also supports pushing events to Slack. Other platforms might be added at a later point.\nSearch API The search allows searching for events. The storage of events is limited to 90 days.\nThis is available to be used by the following consumers.\n Persons, authenticated through ID-porten Orgs, authenticated through Maskinporten  The API is described in swagger here.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/godkjenn-bruksvilkaar/",
	"title": "Godkjenning av bruksvilkår for skytjenester fra Altinn",
	"tags": ["app"],
	"description": "Dokumentasjon av appen for å godkjenne bruksvilkår for Altinn.",
	"content": "TODO: Dokumentasjon, screenshots, etc\n Repo Kjørende tjeneste  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/",
	"title": "Gruppering av felter",
	"tags": [],
	"description": "Hvordan gruppere felter i skjema.",
	"content": "\rOppsett for gruppering av felter\rGenerelt oppsett for gruppering av felter i skjema.\n\r\rRepeterende grupper\rOppsett for repeterende grupper.\n\r\rInnstillinger\rInnstillinger for visning.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/whats-new/",
	"title": "Hva er nytt",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v1 av deployment.",
	"content": "1.1.0 Første versjon i remote repository. Templates kopiert fra apps template\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v2/whats-new/",
	"title": "Hva er nytt",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v2 av deployment.",
	"content": "2.1.0 Aktivering av liveness og/elelr readiness probe krever at applikasjonen din kjører versjon 4.30.0 eller høyere av Altinn.App.* nugetpakkene.\r\rEndringer innført  Default CPU og minne tilgjengeliggjort per pod er redusert til henholdsvis 50m og 128Mi. Konfigurerbar liveness og readiness probes er tilgjengelig. Default er at dette er disablet.  Nye valgfrie felter med standard verdier tilgjengelig for overstyring i values.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14  deployment: readiness: enabled: false path: /health initialDelaySeconds: 30 failureThreshold: 3 periodSeconds: 3 timeoutSeconds: 1 liveness: enabled: false path: /health initialDelaySeconds: 3 failureThreshold: 3 periodSeconds: 10   Gjennomgang:\n3. Aktiver eller deaktiver readinessprobe for denne applikasjonen.\n4. Pathen til readiness-endepunktet i applikasjonen.\n5. Hvor mange sekunder man venter før readinessproben begynner etter at containeren har startet.\n6. Minimum antall påfølgende feil før readinessproben ansees som feilet.\n7. Frekvens for readinessprobing\n8. Hvor mange sekunder før readinessproben timer ut\n10. Aktiver eller deaktiver livenessprobe for denne applikasjonen.\n11. Pathen til liveness-endepunktet i applikasjonen.\n12. Hvor mange sekunder man venter før livenessproben begynner etter at containeren har startet.\n13. Minimum antall påfølgende feil før livenessproben ansees som feilet.\n13. Frekvens for livenessprobing\n14. Hvor mange sekunder før livenessproben timer ut\n2.0.0 Oppgradering til 2.0.0 fra 1.x.x vil føre til en kort nedetid ved første deploy. Påfølgende deployments vil gå som normalt\r\rHvis din apps deployment mappe fortsatt har undermappen templates vennligst følg migrerings guiden\nChanges introduced  Deployment objektet får nytt navn -v2 dette på grunn av nødvendig endring på selector som ikke kan endre på et objekt. ADVARSEL fører til nedetid ved førstegangs deploy Alle applikasjoner får satt resource requests Horizontal pod autoscaler er påskrudd som default (automatisk skalering av applikasjon) Labels and selectors oppdaterte for de fleste kubernetes objekter Standard initial skalering er endret fra 1 til 2  Nye valgfrie felter med standard verdier tilgjengelig for overstyring i values.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  deployment: autoscaling: enabled: true replicas: min: 2 max: 10 avgCpuUtilization: 70 behavior: stabilizationWindowSeconds: scaleUp: 0 scaleDown: 120 resources: requests: cpu: 300m memory: 256Mi   Gjennomgang\n3. Aktiver eller deaktiver autoskalering for denne applikasjonen.\n5. Nedre grense for antall pods som kan settes av autoskaleringen.\n6. Øvre grense for antall pods som kan settes av autoskaleringen.\n7. Grensen for gjennomsnittlig CPU utnyttelse (målt i prosent av request CPU) over alle pods for når skalering skal inntreffe.\n9. Stabiliseringsvinduet brukes for å begrense unødvendige endringer i antall replikaer av applikasjonen.\n10. Antall sekunder gjennomsnittlig CPU forbruk over alle pods er over terskelverdi (cpuAvgCpuUtilization) før oppskalering starter.\n11. Antall sekunder gjennomsnittlig CPU forbruk over alle pods er under terskelverdi (cpuAvgCpuUtilization) før nedskalering starter.\n14. CPU millicores reservert av kubelet for hver pod/replica av denne applikasjonen. Benyttet av HPA for å kalkulere skalering. Pods kan bruke mer CPU enn dette hvis det er tilgjengelig.\n15. Minne reservert av kubelet for hver pod/replica av denne applikasjonen. Pods kan bruke mer minne enn dette hvis det er tilgjengelig.\nNye valgfrie felter uten standard verdier tilgjengelig for overstyring i values.yaml 1 2 3 4 5  deployment: resources: limits: cpu: 1000m memoty: 512Mi   Gjennomgang\n4. Øvre grense for CPU millicores en pod kan benytte. Forsøk på bruk utover dette vil føre til CPU throttling.\n5. Øvre grense for minne en pod kan benytte. Pods som forsøker å allokere mer minne en dette vil termineres med en \u0026ldquo;Out of memory (OOM)\u0026rdquo; error.\nPull requests merged  Horizontal Pod Autoscaler (PR #3)  "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/whats-new/",
	"title": "Hva er nytt?",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v3 av app frontend.",
	"content": "3.33.3 (2022-03-25) - Støtte for å definere rad eller kolonne for checkbox og radio Lagt til støtte for å definere om radio/checkbox skal vises på en rad eller i kolonne. Issue #5730.\n3.33.2 (2022-03-24) - Justert høyde for inputfelter og datovelger Høyden på disse feltene var feil. Det har blitt rettet til 36px høyde. Issue #7377.\n3.33.1 (2022-03-23) - Fikset feil med dynamiske options Fikset en feil hvor kun den første option ble hentet om man hadde definert to komponenter med samme optionId men ulik mapping. Issue #8292.\n3.33.0 (2022-03-18) - Oppdatert tekst i bekreftelsessteg + mulighet til å overstyre Ny tekst for confirm.sender i bekreftelsessteget. Nå også mulighet til å overstyre denne. Issue #8243.\n3.32.10 (2022-03-18) - Fikset feil i datovelgeren Fikset en feil hvor ugyldige datoer ikke ville vise noen feilmelding. Issue #8121.\n3.32.9 (2022-03-10) - Fikset feil med vedlegg i LocalTest Er nå mulig å laste ned vedlegg i LocalTest. Pull request #7925.\n3.32.8 (2022-03-04) - Fikset feil for nedtrekkskomponent i repeterende grupper Fikset en feil hvor nedtrekkskomponenten i repeterende grupper kunne resultere i en ukjent feil. Issue #8169.\n3.32.7 (2022-03-04) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 9 av 2022. Issue #8137.\n3.32.6 (2022-03-02) - Forbedret validerings-støtte for sporvalg La til støtte for å kunne koble valideirngsmelding til data-felt som ble brukt på flere sider. Issue #8145.\n3.32.5 (2022-03-02) - Forbedringer i tekster Ulike forbedringer relatert til teksthåndtering. La også til støtte for markdown i tittel-komponentens. Issue #7874. Issue #7571.\n3.32.4 (2022-03-01) - Visuelle fikser i modalen. Justeringer i padding i modalen i mobilvisningen. Issue #8143.\n3.32.3 (2022-03-01) - Kjøre frontendregler på serversidekalkuleringer Fikset en feil der frontend regler ikke ville bli kjørt når en kalkulering på serversiden oppdaterte et felt koblet til en regel. Issue #8054.\n3.32.2 (2022-02-28) - Fikset feil i Adresse-komponenten Fikset en feil i adresse-komponenten hvor poststed enkelte ganger ikke ble oppdatert når man skrev inn postnummer. Issue #8130.\n3.32.1 (2022-02-25) - Fikset feil for layout-navn Fikset en feil hvor en app med en layout-side med navn \u0026ldquo;data\u0026rdquo; ikke ville starte. Issue #8125.\n3.32.0 (2022-02-23) - Sikrede options Er nå mulig å sette opp sikrede options. Issue #7893.\n3.31.4 (2022-02-23) - Feilretting for Bekreft-steget Fikset feil hvor spinneren ikke ble vist mens confirm request ble gjort. Viser også nå den genererte PDF\u0026rsquo;en i bekreft-steget. Issue #7824.\n3.31.3 (2022-02-17) - Fikset oppstilling av label grid Fikset oppstilling av label grid slik at den matcher en vanlig grid. Pull request #8059.\n3.31.2 (2022-02-17) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 7 av 2022. Issue #8048.\n3.31.1 (2022-02-16) - Ny styling for knapp Ny styling for knapp-komponent for å matche figma-skisser. Pull request #8057.\n3.31.0 (2022-02-16) - Lagt til støtte for å endre tekster i arkivkvittering Tekster i arkivkvittering kan nå overstyres fra applikasjonen, og tekstene støtter også markdown og variabler.\nIssue #7902.\n3.30.0 (2022-02-16) - Automatisk hente nye options når mapping endres La til funksjonalitet for å automatisk hente options på nytt når et felt i mappingen endres.\nIssue #7888.\n3.29.1 (2022-02-14) - Fikset feil hvor variables i tekster ble ignorert ved kalkulering Dette fikser en feil som ble introdusert i 3.29.0\nPull request #5893.\n3.29.0 (2022-02-11) - Lagt til Navigationbar komponent Lagt til Navigationbar komponent\nIssue #5893.\n3.28.2 (2022-02-10) - Flyttet testfiler Ingen kodeendringer\nPull request #7999.\n3.28.1 (2022-02-09) - Fikset en feil i checkboxkomponent Fikset en feil som ble introdusert i 3.27.5, hvor endringer av checkbox førte til at simplebindingverdien ble satt til ,\nPull request #7996.\n3.28.0 (2022-02-09) - Lagt til FileUploadWithTag komponent Lagt til filopplastningskomponent med mulighet for merking av filer.\nIssue #6479.\n3.27.5 (2022-02-09) - Fikset feil i checkboxkomponent Fikset feil i checkboxkomponent\nEndringen støtter under sak #7464.\n3.27.4 (2022-02-08) - Fikset feil i confirm container Fikset feil i confirm container\nEndringen støtter under sak #7464.\n3.27.3 (2022-02-07) - Fikset feil i radiobuttonkomponent Fikset feil i radiobuttonkomponent\nEndringen støtter under sak #7464.\n3.27.2 (2022-02-07) - Fikset feil i receipt container Fikset feil i receipt container\nEndringen støtter under sak #7464.\n3.27.1 (2022-02-07) - Fikset feil i datepickerkomponent Fikset feil i datepickerkomponent\nEndringen støtter under sak #7464.\n3.27.0 (2022-02-01) - Vise applikasjonseier header Applikasjonseier vil nå vises i header for å tydeliggjøre hvem som er eier av appen.\nIssue #7227.\n3.26.3 (2022-02-01) - Fikset feil i adressekomponent Fikset feil i adresse komponent\nEndringen støtter under sak #7464.\n3.26.2 (2022-02-01) - Fikset feil i dropdownkomponent Fikset feil i dropdown komponent\nEndringen støtter under sak #7464.\n3.26.1 (2022-01-31) - Fikset feil i InstantiateContainer Fikset feil i instantiate container\nEndringen støtter under sak #7464.\n3.26.0 (2022-01-30) - Designendringer for repeterende grupper  \u0026ldquo;Lagre\u0026rdquo;-knappen får annereledes stil enn \u0026ldquo;Neste\u0026rdquo;-knappen. \u0026ldquo;Rediger\u0026rdquo;-knappen får samme focus-state stil som den redigerbare boksen så man enklere ser hvilken rad som redigeres. Ikon justeres til venstre for tekst i alle ikonknapper. Margen i gruppen endres slik at teksten utnytter hele bredden og flyter på samme vertikale linje som resten av innholdet i skjemaet.  Endringen støtter under sak #7577.\n3.25.1 (2022-01-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 4 av 2022.\nIssue #7842.\n3.25.0 (2022-01-24) - Lagt til flere datakilder for variabler i tekst Funksjonaliteten knyttet til variabler i tekster har fått to nye datakilder. Det blir nå mulig å hente verdier fra instance og konfigurasjonsverdier fra ApplicationSettings. Støtten for konfigurasjonsverdier krever versjon 4.25.0 eller nyere av backend sine NuGet pakker.\nEndringen støtter under sak #7520.\n3.24.0 (2022-01-24) - Nøytralt design La til et mer nøytralt design for app-frontend. Issue #7234.\n3.23.1 (2022-01-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 3 av 2022. Issue #7842.\n3.23.0 (2022-01-21) - Dynamiske options (kodelister) La til støtte for første utgave av dynamiske options (kodelister). Issue #5247.\n3.22.9 (2022-01-20) - Typestabil FormData + Typescript forbedringer Gjør FormData typestabil og ulike forbedringer til typer. Pull request #7718.\n3.22.8 (2022-01-17) - Fikset ulike eslint feil Fikset ulike eslint feil, la til testdekning. Noe refaktorering av eldre komponenter. Pull request #7786.\n3.22.7 (2022-01-13) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 2 av 2022. Issue #7753.\n3.22.6 (2022-01-11) - Fikset feil med repeterende grupper Fikset feil hvor repeterende grupper staten ikke ville bli fjernet når man lastet ny formlayout. Issue #7773.\n3.22.5 (2022-01-10) - Optimalisering for SummaryGroupComponent La til manglende keys for forbedret ytelse. Pull request #7720.\n3.22.4 (2022-01-07) - Vise feilmelding for ukjent komponent App frontend viser nå en feilmelding når den prøver rendre en ukjent komponent. Pull request #7724.\n3.22.3 (2022-01-07) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 1 av 2022. Issue #7753.\n3.22.2 (2021-12-23) - Fikset feil med variabler i tekst Fikset en feil hvor variabler i tekst ikke ville bli oppdatert etter en backend kalkulering. Issue #7308.\n3.22.1 (2021-12-23) - Fikset feil for manglende rettigheter i stateless view Fikset en feil hvor manglende rettigheter ville resultere i en generisk feilmelding og ikke feilmelding om manglende rettigheter. Issue #6514.\n3.22.0 (2021-12-22) - Flere muligheter til å skreddersy repeterende gruppe La til flere muligheter til å overstyre tekster og skjule \u0026ldquo;legg til\u0026rdquo; knappen for repeterende gruppe. Issue #7164.\n3.21.1 (2021-12-17) - Fikset feil med validering på task Fikset en feil hvor feilmeldinger satt i ValidateTask i ValidationHandler.cs ikke ble vist til bruker. Issue #7333.\n3.21.0 (2021-12-17) - Mulighet for å bruke h2, h3 og h4 for størrelse i header komponenten i FormLayout Det er nå mulig å bruke h2, h3 og h4, istedenfor S, M og L som verdier for størrelse i header komponenten. Issue #7611.\n3.20.1 (2021-12-16) - Fikset feil i adressekomponenten Fikset en feil hvor adressekomponenten kræsjet uventet for tomme verdier. Issue #7658.\n3.20.0 (2021-12-14) - Støtte for egendefinert OIDC provider La til støtte i frontend for at Altinn.Apps kan ha ulike OIDC provider. Issue #7173.\n3.19.2 (2021-12-09) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 49. Issue #7590.\n3.19.1 (2021-12-09) - Endringer i bilde komponent Flere endringer for bilde-komponenten. Issue #7484.\n3.19.0 (2021-12-06) - Starte instans fra stateless visning Støtte for å starte en data instans fra stateless visning innad i samme applikasjon. Issue #6196.\n3.18.4 (2021-12-03) - Optimalisering for mobil visning Tilbakestilte endring av maxWidth fra versjon 3.18.3 da dette skapte trøbbel med fokus-visning på større skjermer. Issue #7588.\n3.18.3 (2021-12-01) - Optimalisering for mobil visning - bredde Fikset maxWidth for input-komponenter og for address component. Issue #6697.\n3.18.2 (2021-11-30) - Optimalisering for mobil visning - luft Forbedret luft for tittel og paragraf-komponentene. Issue #6697.\n3.18.1 (2021-11-30) - Optimalisering for mobil visning - bredde Endret maxWidth på valideringsmeldinger fra auto til none. Issue #6697.\n3.18.0 (2021-11-29) - Støtte for labelgrid La til støtte for labelGrid i grid som muliggjør lengre lister med korte spørsmål og svar som kan bli presentert i en tabell-liknende visning. Issue #7027.\n3.17.1 (2021-11-24) - Bugfiks DataProcessWrite. Fikset en feil hvor numeriske felter som ble satt i DataProcessWrite ikke ble oppdatert i skjema om verdien var 0. Issue #7393.\n3.17.0 (2021-11-24) - Optimalisering for mobilvisning La til forbedringer i måten skjema ser ut på mobil. Issue #6697.\n3.16.0 (2021-11-24) - Endret ikon for hjelpetekst. Endret hjelpetekst ikonet fra plus til spørsmålstegn. Issue #5722.\n3.15.1 (2021-11-18) - Ugyldige typer for reselect Fikset ugyldige typer for reselect. Pull request #7502.\n3.15.0 (2021-11-15) - Støtte for returnUrl La til støtte for returnUrl i app-frontend. Issue #7183.\n3.14.2 (2021-11-11) - Oppdatering av jsonpointer Oppdaterte ekstern avhenghighet jsonpointer. Issue #7317.\n3.14.1 (2021-11-11) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 45. Issue #7317.\n3.14.0 (2021-11-08) - \u0026ldquo;today\u0026rdquo;-flagg for datovelger min/max datoer La til et flag for å dynamisk kunne styre min/max datoer basert på dagens dato. Issue #7228.\n3.13.6 (2021-11-04) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 44. Issue #7317.\n3.13.5 (2021-10-28) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 43. Issue #7303.\n3.13.4 (2021-10-22) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 42. Issue #7303.\n3.13.3 (2021-10-15) - Høyrejustere tekst i inputfelter La til funksjonalitete for å høyrejustere tekst i inputfelter. Pull request #7034.\n3.13.2 (2021-10-14) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 41. Issue #7051.\n3.13.1 (2021-10-13) - Fiks for tilpasset validering av vedlegg Fikset validering av vedlegg som krasjet med tilpasset logikk. Issue #7107.\n3.13.0 (2021-10-11) - Start fra aktiv instans La til funksjonalitet for å starte en applikasjon fra en aktiv instans. Issue #6766.\n3.12.4 (2021-10-11) - Repeterende gruppe åpen konfigurasjon La til funksjonalitet til å styre om en repeterende gruppe skal være åpen i editeringsmodus når applikasjonen lastes. Løser deler av issue #4870.\n3.12.3 (2021-10-07) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 40. Issue #7051.\n3.12.2 (2021-10-04) - Fiks for design av readonly datovelger Readonly datovelger nå har samme design som andre readonly komponenter. Issue #6253.\n3.12.1 (2021-09-30) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u39. Issue #6873..\n3.12.0 (2021-09-29) - Bildekomponent La til bildekomponent for enklere å kunne legge til bilder i applikasjonen. Issue #379.\n3.11.9 (2021-09-29) - Støtte for JSON Schema 2020-12 i app frontend Fikset bug hvor JSON Schema 2020-12 ikke var støttet i app frontend. Tilhørende issues: #6703 #6812.\n3.11.8 (2021-09-27) - Lagt til mellomrom mellom valgfri tekst og titteltekst Lagt til mellomrom mellom valgfri tekst og titteltekst i radioknapp, avkrysningsboks og adresse komponenter. Issue #6893.\n3.11.7 (2021-09-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u38. Issue #6873.\n3.11.6 (20201-09-21) - Fokus indikator for input-felt Fikset bug hvor fokus indikator ikke var synlig for input-felter. Issue #6801.\n3.11.5 (2021-09-21) - Content loader visning på mobil Fikset bug hvor content loader gikk over tildelt bredde for små skjermer. Issue #6876.\n3.11.4 (2021-09-20) - Fiks for tekst parse feil Fikset tekst parse feil i confirm steget av en app. Issue #6775.\n3.11.3 (2021-09-17) - Forhåndsvalgt nedtrekksliste Nedtrekksliste støtter forhåndsvalgt (preselectedOptionIndex) verdi. Issue #5255.\n3.11.2 (2021-09-16) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u37. Issue #6794.\n3.11.1 (2021-09-09) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u36. Issue #6794.\n3.11.0 (2021-09-08) - Aktør valg i stateless app Stateless appene støtter aktør valg basert på innstillinger i app metadata. Issue #6443.\n3.10.3 (2021-08-23) - Added some IDs used by automated tests Non functional change. Not connected to an issue.\n3.10.2 (2021-08-19) - Dependency patching Patching of external dependencies for w33. Issue #6600\n3.10.1 (2021-08-16) - App frontend includes partyID for stateless apps App frontend includes partyID in calls for fetching stateless data. Issue #6609\n3.10.0 (2021-08-13) - Log out functionality Added functionality for log out from app frontend. Issue #6620\n3.9.9 (2021-08-12) - Dependency patching Patching of external dependencies for w32. Issue #6600.\n3.9.8 (2021-08-05) - Dependency patching Patching of external dependenecies for w31. Issue #6571.\n3.9.7 (2021-08-03) - Bugfix print view Fixed a bug where the print view for Altinn Apps would display an empty container. Issue #6578.\n3.9.6 (2021-08-02) - Dependency patching Patching of external dependenecies for w30. Issue #6571.\n3.9.5 (2021-07-28) - Bugfix for mobile view during app startup Fixed a bug where the app modal would behave inconsistent during app startup on mobile devices. Issue #6558.\n3.9.4 (2021-07-23) - Bugfix validation trigger for groups. Fix a bug where validations would not be triggered when closing a repeating group by clicking Edit button when trigger was present. Issue #6427.\n3.9.3 (2021-07-23) - Dependency patching Patching of external dependencies for w29.\n3.9.2 (2021-07-02) - Dependency patching Patching of external dependencies for w26. Issue #6385.\n3.9.1 (2021-07-01) - Support for redirect to require higher authentication level for stateless app Fix for bug that didn\u0026rsquo;t redirect user to login page with allowed authentication levels if logged in with a too low level. Issue #6506.\n3.8.0 (2021-06-29) - Several updates to validation functionality  Support for adding custom error messages to client side validations (JSON schema). Support for specifying single field validation (server) as FIXED to make sure resolved validation error messages are removed. Fixes bug where single field validation that returned empty (no errors/warnings) did not remove existing validation messages. Issue #5747.  3.7.0 (2021-06-29) - Support for posting data from stateless app Issue #6194.\n3.6.14 (2021-06-22) - Bug fix for duplicated validation messages Fixed a bug that caused validation messages on a FileUpload component to be displayed twice. Issue #6400.\n3.6.13 (2021-06-18) - Bugfix for replaceAll with variables in text Fix for bug introduced in 3.6.9, where only the last variable in texts with multiple variables was replaced. The change in 3.6.9 also caused summary page to fail in some cases. Issue #6455.\n3.6.12 (2021-06-18) - Dependency patching Patching of external dependencies. Issue #6385.\n3.6.11 (2021-06-16) - Bugfix for disappearing validation messages Fixed bug for disappearing validation messages. Single field validation response would overwrite all existing validations, causing earlier triggered validation messages to disappear. Issue #5857.\n3.6.10 (2021-06-15) - Bugfix for navigation buttons with multiple triggers Fixed bug for navigation buttons configured with multiple triggers, where only the first one was actually triggered. Issue #6387.\n3.6.9 (2021-06-14) - Bugfix variables in text Fixed bug where only first occurance of a variable in a given text was replaced. Issue #6091\n3.6.8 (2021-06-11) - New endpoints for statless app New endpoints for stateless app. Issue #6227\n3.6.7 (2021-06-10) - Dependency patching Patching of external dependencies. Issue #6385\n3.6.6 (2021-06-09) - Dependency patching Updated to latest major version of react v17. Issue #5072\n3.6.5 (2021-06-02) Bugfix for stateless app Fixed bug where stateless app with onEntry.show set to new-instance would crash. Issue #6321.\n3.6.4 (2021-06-02) Bugfix for simple receipt Fixed bug where simple receipt did not parse markdown if the app overrides defult texts. Issue #6232.\n3.6.3 (2021-06-02) Bufix for content loader Fixed bug where content loader did not scale for whole view. Issue #4888.\n3.6.2 (2021-06-01) Bugfix for summary view of group with multiple pages Fixed bug that caused app frontend to crash when rendering summary component for group when the group was defined with multiple pages in edit mode. Issue #6233.\n3.6.1 (2021-05-28) Dependency patching Patching of external dependencies. Issue #6324.\n3.6.0 (2021-05-28) Support for hiding back button in apps Issue #6193.\n3.5.0 (2021-05-27) Support for number formatting Added support for formatting numbers for Input-components. Issue #5972.\n3.4.2 (2021-05-26) Improve look of summary for checkboxes component Issue #6329.\n3.4.1 (2021-05-20) Dependency patching Patching of external dependencies. Issue #6221.\n3.4.0 (2021-05-18) Support for stateless apps Issue #6124.\n3.3.5 (2021-05-14) - Dependency patching Patching of external dependencies. Issue #6221.\n3.3.4 (2021-05-11) Bugfix for calculation in groups Issue #6235.\n3.3.3 (2021-05-11) Run data validation on page switch, and fix group component mobile view Issue #6236. Issue #5977.\n3.3.2 (2021-05-06) - Dependency patching Patching of external dependencies. Issue #6011.\n3.3.1 (2021-05-06) Support for markdown in validation messages Issue #5137.\n3.3.0 (2021-05-03) Support for multiple views in repeating group edit mode Issue #5869.\n3.2.2 (2021-04-23) - Dependency patching Patching of external dependencies. Issue #6011.\n3.2.1 (2021-04-23) - Bugfix for group validations Fixed a bug where groups with validation trigger would call the instance validation api. Now calls data validation. Issue #6089.\n3.2.0 (2021-04-21) - Validation on group save Added support for running validations on a group when the user tries to save an entry. Issue #5281.\n3.1.6 (2021-04-19) - Bugfix for checkbox values in summary component Fixed bug where summary would display an empty string for checkboxes with multiple selected values. Issue #5993.\n3.1.5 (2021-04-19) - Bugfix for repeating group state on calculation Fixed bug where repeating group state would not be updated if a backend calculation had altered a repeating group. Issue #6006.\n3.1.4 (2021-04-19) - Bugfix for validations on group delete Fixed bug where validations for a given group index would not be removed on delete. Issue #5960.\n3.1.3 (2021-04-16) - Bugfix for validation Fixed bug where single field validation would validate the whole instance and not data. Issue #5885.\n3.1.2 (2021-04-12) - Dependency patching. Patching of external dependencies. Issue #5957.\n3.1.1 (2021-04-09) - Bugfix for slow calculate Fixed bug where a slow backend calculation can overwrite later entered data. Issue #5754.\n3.1.0 (2021-04-07)- Help text for paragraph and header components App now supports help text for paragraph and header components. Issue #5862.\n3.0.16 (2021-04-06) - Dependency patching Patching of external dependencies. Issue #5877.\n3.0.15 (2021-03-22) - Bugix for group component with checkboxes Fixed bug where group component summary would display an empty value for checkboxes that had several selected values. Issue #5907.\n3.0.14 (2021-03-19) - Dependency patching Patching of external dependencies. Issue #5877.\n3.0.13 (2021-03-18) - Internal typings App frontend internal typings updated to fix failing tests. No issue connected.\n3.0.12 (2021-03-17) - Bugfix for markdown support in summary and group titles Fixed bug where app frontend would not render markdown in summary and group titles. Issue #5781.\n3.0.11 (2021-03-17) - Bugfix for page order calculation Fixed bug where app frontend would trigger call to calculate page order even when no calculation trigger was present. Issue #5863.\n3.0.10 (2021-03-12) - Bugfix for page order calculation Fixed bug where app frontend would trigger call to calculate page order for single page applications. Issue #5859.\n3.0.9 (2021-03-12) - Dependency patching Patching of external dependencies. Issue #5771.\n3.0.8 (2021-03-12) - Support for dynamicly getting page order App frontend now supports dynamicly fetching the page order on next page (\u0026ldquo;sporvalg\u0026rdquo;). See docs for more information. Issue #5640.\n3.0.7 (2021-03-09) - Bugfix for page caching Fixed issue where the app would cache the first page in alphabetical order and not respect the order in Settings.json. Issue #5819.\n3.0.6 (2021-03-08) - Caching of last viewed page Introduced caching of the last viewed form page, so user is returned to this page when refreshing or coming back at a later time. Issue #5278.\n3.0.5 (2021-03-05) - Dependency patching Patching of external dependencies. Issue #5770.\n3.0.4 (2021-03-05) - Bugfix for text styling in titles/descriptions Fix issue where label and description texts would get cut off mid word. Issue #5810.\n3.0.3 (2021-03-02) - Bugfix for metadata with layoutsets Fix issue where app-frontend feched wrong metadata when using layoutsets. Issue #5624.\n3.0.2 (2021-02-26) - Dependency patching Patching of external dependencies. Issue #5676.\n3.0.1 (2021-02-25) - Horizontally aligned components \u0026amp; Bugfix for loading options App-frontend now supports horizontally aligned components. See docs for more information. Issue #1515.\nFix issue that only loaded options related to form layout in first data task - for subsequent data tasks options were not loaded. Issue #5619.\n3.0.0 (2021-02-23) - New font for App Frontend This version changes the font for the app frontend from Roboto to Altinn-DIN. For the apps to show fonts as expected, some changes need to be made. See breaking changes for the details.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i versjon 3.",
	"content": "3.5.1 (2021-03-11) - Possible to get ruleconfiguration for apps with layout sets There was a bug resulting in av 404 response whenever it is attepmpted to retrieve the ruleconfiguration for an application while specifying the layout set id in the request. This has now been fixed.\n3.5.0 (2021-03-10) - Added funcionality for pdf generation for application owner Up until now a pdf copy has not been generated for the tasks that are completed by the application owner. This has now been implemented and pdf should be generated after a task regardless if it is an end user of the app owner that completes the task.\n3.4.0 (2021-03-10) - Endpoint and functionality for get page order made available All apps now expose an endpoint for getting the current page order based on the current state of an instance. Default behavior is to return the page order as defined in Settings.json to override, add the function below in Logic/App.cs and include your own logic.\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } 3.3.0 (2021-03-04) - Retrieving certificate from Key Vault now uses name The ISecret service now requires certificate name as input for retrieving a certificate from key vault. Previously this has been the certificate id, but this identificator contains more information that an app developer might have available, so the service has been simplified.\n3.2.3 (2021-02-17) - Fixed duplicate key exception on options When using the same option key in an option result a duplicate key exception was thrown that crashed the app. This is now fixed, and keys that already exist in the option result will not be added.\n3.2.1 (2021-02-10) - Correctly set unread status when instantiated by end user The instance now appears as read in the messagebox if it is instantiated by an end user through api, regardless if they have opened the instance in GUI or downloaded the form data they just posted.\n3.2.0 (2021-02-02) - Options displayed with label in PDF Before this release the selected option was shown with it\u0026rsquo;s value rather than the label that the end user was presented with during form filling. This has now been fixed so the label is diplayed in the pdf.\n3.1.6 (2021-01-29) 3.1.5 (2021-01-27) 3.1.4 (2021-01-26) 3.0.4 (2021-01-26) - Swagger support for Apps We have added Swashbuckle to the App. It is a library that brings Swagger support and this is especially handy when developing an HTTP based API. It creates a form of interactive documentation based on the OpenAPI Specification. To describe the Api\u0026rsquo;s better, we use the xml documentation file.\nThis documentation will be generated automatically when the application is build. Existing api\u0026rsquo;s and new api\u0026rsquo;s created in the app will be documented.\nThe documentation will appear at https://[org].apps.altinn.no/[org]/[app]/swagger/index.html in the app.\nTo enable this, there\u0026rsquo;s some changes.\n  Updated package dependencies, generate xml documentation file and copy xml documentation for Altinn.App.Api Navigate to you application repository and find App.csproj in the App folder.\nUpdate nuget dependencies in App.csproj to version 3.0.4, add new property for Altinn.App.Api.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.4\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml \u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.4\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.4\u0026#34; /\u0026gt; This is new in App.csproj\n\u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;5.6.3\u0026#34; /\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;Target Name=\u0026#34;CopyXMLFromPackagesForBuild\u0026#34; AfterTargets=\u0026#34;Build\u0026#34;\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReferenceFiles Condition=\u0026#34;%(PackageReference.CopyToOutputDirectory) != \u0026#39;\u0026#39;\u0026#34; Include=\u0026#34;$(NugetPackageRoot)$([MSBuild]::Escape(\u0026#39;%(PackageReference.Identity)\u0026#39;).ToLower())/%(PackageReference.Version)/%(PackageReference.CopyToOutputDirectory)\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;Copy SourceFiles=\u0026#34;@(PackageReferenceFiles)\u0026#34; DestinationFolder=\u0026#34;$(OutDir)\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt;   Changes to the Startup.cs file. If you don\u0026rsquo;t have any custom code in this, copy file from here.\nAdd this to the end of the ConfigureServices method\n// Add Swagger support (Swashbuckle)  services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Altinn App Api\u0026#34;, Version = \u0026#34;v1\u0026#34; }); IncludeXmlComments(c); }); Add this before app.UseRouting() in the Configure method\nstring applicationId = GetApplicationId(); if (!string.IsNullOrEmpty(applicationId)) { app.UseSwagger(o =\u0026gt; o.RouteTemplate = applicationId + \u0026#34;/swagger/{documentName}/swagger.json\u0026#34;); app.UseSwaggerUI(c =\u0026gt; { c.SwaggerEndpoint($\u0026#34;/{applicationId}/swagger/v1/swagger.json\u0026#34;, \u0026#34;Altinn App API\u0026#34;); c.RoutePrefix = applicationId + \u0026#34;/swagger\u0026#34;; }); } Add two methods\nprivate void IncludeXmlComments(SwaggerGenOptions options) { try { string fileName = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; string fullFilePath = Path.Combine(AppContext.BaseDirectory, fileName); options.IncludeXmlComments(fullFilePath); string fullFilePathApi = Path.Combine(AppContext.BaseDirectory, \u0026#34;Altinn.App.Api.xml\u0026#34;); options.IncludeXmlComments(fullFilePathApi); } catch { // Swagger will not have the xml-documentation to describe the api\u0026#39;s.  } } private string GetApplicationId() { string appMetaDataString = File.ReadAllText(\u0026#34;config/applicationmetadata.json\u0026#34;); JObject appMetadataJObject = JObject.Parse(appMetaDataString); return appMetadataJObject.SelectToken(\u0026#34;id\u0026#34;).Value\u0026lt;string\u0026gt;(); }   3.0.1 (2021-01-19) 3.0.0 (2021-01-05) - Support for dynamics in PDF We have added a new PDF handler to make it possible to hide pages and components in PDF. See breaking changes for how to update you app to be compatible with this version.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i versjon 4.",
	"content": "4.34.1 (06.04.2022) - Støtte for forsendelsestype på eFormidling forsendelse Denne releasen muliggjør spesifisering av forsendelsestype.\nUtvid eFormidling-seksjonen i applicationmetadata.json med den nye egenskapen dpfShipmentType som vist nedenfor.\n\u0026#34;eFormidling\u0026#34;: { ... \u0026#34;dpfShipmentType\u0026#34;: \u0026#34;altinn3.skjema\u0026#34; } 4.33.0 (15.03.2022) - Støtte for å slå av PDF generering for skjema  Denne releasen gjør det mulig å slå av PDF generering for enkeltskjema i en applikasjon.  Dette gjøres ved å sette flag i application metadata på en gitt datatype. Standard er true\nEksempel.\n{ \u0026#34;id\u0026#34;: \u0026#34;melding\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;maxCount\u0026#34;: 1, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: false, \u0026#34;ClassRef\u0026#34;: \u0026#34;App.IntegrationTestsRef.Data.apps.dibk.nabovarsel.Melding\u0026#34; }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;enablePdfCreation\u0026#34; : false } 4.32.0 (14.03.2022) - Person oppslagstjeneste Register applikasjonen i platform har blitt oppdatert med et nytt endepunkt som kan brukes til å verifisere et personnummer. Denne versjonen av NuGet pakkene til en app har fått implementert en oppslagstjeneste som kan brukes til å gjøre oppslag mot dette nye endepunktet i Register.\n4.31.1 (10.03.2022) - Fikset bug relatert til prefill og berriket instance events med personnumer  Denne releasen løser en bug der prefill av samme verdi til mer enn ett felt kaster en duplicate key exception. Personnummer legges nå til i platformUser objektet for instance events.  4.30.0 (07.03.2022) - Støtte for readiness og livenessprober Det er nå lagt til et endepunkt for helsesjekk i applikasjonen. Dette benyttes blant annet av Kubernetes til å vite når en applikasjonsinstans er klar til å settes inn i last.\nFor alle applikasjon opprettet før 16.03.2022 må det gjøres manuelle endringer for å aktivere readiness og liveness probene.\n  I App/Startup.cs\n  Legg til linjen using Altinn.App.Core.Health; blant de andre using-referansene øverst i filen.\n  I metoden ConfigureServices legger du til linjen\nservices.AddHealthChecks().AddCheck\u0026lt;HealthCheck\u0026gt;(\u0026#34;default_health_check\u0026#34;);   I metoden Configure legger du til linjen\napp.UseHealthChecks(\u0026#34;/health\u0026#34;);     I deployment/Chart.yaml skal referansen til Studio helm charten oppdateres til versjon 2.1.0\nEndelig resultat bør likne på dette:\napiVersion: v1 description: A Helm chart for Kubernetes name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 2.1.0   I deployment/values.yaml legger du til\nreadiness: enabled: true liveness: enabled: true   MERK antall innrykk er viktig i filen. readiness og liveness skal stå på nivået under deployment og på samme nivå som volumeMounts og volumes\n4.27.0 (23.02.2022) - Sikre kodelister Lagt til støtte for sikre kodelister Rettet url og parameter logik i GetInstanceEvents Endret redirect url fra string til base64 encoded string\n4.26.0 (2022-02-10) - Forbedringer knyttet til PDF og tekstressurser Nyinnførte tekstressurs appName benyttes som tittel på PDF. Lokal kopi av tekstressurser benyttes i PDF i stedet for tekstressurser fra Platform Storage.\n4.25.0 (2022-01-24) - Dynamiske konfigurasjonsverdier for frontend Det er blitt laget en ny seksjon kalt FrontEndSettings for bruk i appsetting.{miljø}.json filer. Dette eksponeres til frontendapplikasjonen som applicationSettings og er en dynamisk liste med verdier. I praksis betyr dette at FrontEndSettings kan utvides med innslag uten at man må gjøre kodeendringer i backend. Dette gjør det mulig for backend å tilby miljøspesifikke verdier til frontend.\n4.24.0 (2020-01-21) Støtte for språk og query parametre inn til dynamiske kodelister. Ny måte å implementere dynamiske kodelister ved hjelp av IAppOptionsProvider. Se dokumentasjon\n4.23.0 (2022-01-15) - Støtte for BPMN Gateways Restrukturering av prosessmotor og støtte for BPMN gateways.\n4.22.0 (2022-01-07) - Included access token generation for eFormidling integration point Integrasjonspunktet som benyttes for å sende instansdata via eFormidling krever nå et gyldig tilgangstoken. Applikasjonstemplaten er nå oppdatert til å fylle alle krav for integrasjonspunktet.\n4.21.0 (2021-12-01) - Støtte for lagring av brukernavn for instanseier Dersom en selvidentifisert bruker instansierer en instans vil dere brukernavn lagres i metadataen for instanseier.\n4.20.0 (2021-11-18) - Støtte for egendefinert redirect URL når man avslutter appen Lagt til støtte for ett spesifikt query parameter (returnUrl) for å videresende brukeren til den spesifiserte URLen når brukeren avslutter appen ved å trykke på avslutt-knappen i Altinn 3 appen. Les mer om dette her\nRelatert til 7183\n4.19.0 (2021-11-15) - Added support for instantiation based of a copy of an archived instance Lagt til støtte for å instansiere en applikasjon basert på en arkivert instans. Det nye endepunktet er dokumentert her. Merk at støtte for kopiering av instans i meldingsboksen og konfigurasjon av funksjonaliteten via Altinn Studio enda er under utvikling.\nRelatert til 6695\n4.18.0 (2021-11-10) - Støtte for OIDC konfigurasjon i App Lagt til støtte for å konfigurere opp en spesifikk OIDC provider for en app.\nRelatert til 7173\n4.17.2 (2021-10-27) - Lagt inn API for prefill i form av nøkkel-verdi par ved instansiering Det er nå mulig å angi prefill i form av nøkkel-verdi par ved instansiering av en app. Støtten for dette er innført i et nytt API endepunkt.\nDet er også mulig å bruke prefill verdiene i app spesifikk kode. Dette vil kreve at app\u0026rsquo;en implementerer siste versjon av App.cs. Legg til følgende metode:\npublic override async Task RunDataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { await _instantiationHandler.DataCreation(instance, data, prefill); } I tillegg må InstansiationHandler.cs oppdateres med methoden:\npublic async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { await Task.CompletedTask; } 4.16.0 (2021-10-07) - Nytt app API for tagging av data elementer Det er blitt laget støtte for å lagre tags (stikkord) på et data element. I den sammenheng er det laget API endepunkter for å liste tags, legge til en tag, og sletting av tag.\nDenne endringer tilhører saken 6861 på github.\nDet er mer informasjon om endringen under app API dokumentasjon.\n4.15.2 (2021-10-04) - Nytt endepunkt for å hente ut aktive instanser Altinn Apps eksponerer nå et endepunkt for å hente ut aktive instanser for en gitt avgiver. Det nye endepunktet er tilgjengelig på {org}.apps.altinn.no/{org}/{app}/instances/{instanceOwnerPartyId}/active.\nDenne endringen tilhører issue 6767.\n4.14.1 (2021-09-22) - Fikset en bug som medførte 500 error hvis instance ikke finnes Det var en bug i koden som medførte 500 error hvis man spurte etter en ikke eksisterende instance. Dette er nå blitt fikset på en måten som gjør at API isteden nå svarer med 403. Open API spesifikasjon for aktuelt endepunkt har blitt oppdatert med mulige status koder.\n4.14.0 (2021-09-13) - Delvis støtte for navnerom(namespace) i XML Koden som deserialiserer XML inn i objekter har blitt oppdatert til å håndtere navneromsdeklarering i rotelementet til et XML-dokument.\nEksempel:\n\u0026lt;Skjema xmlns=\u0026#34;urn:no:altinn:skjema:v1\u0026#34;\u0026gt; \u0026lt;Navn\u0026gt;Altinn\u0026lt;/Navn\u0026gt; \u0026lt;/Skjema\u0026gt; Deserialisering skjer når et eksternt system bruker et app API endepunkt til å sende inn et nytt skjema, overskrive et eksisterende skjema, og når en app henter et skjema dokument fra \u0026ldquo;blob-storage\u0026rdquo;.\nEndringen blir ikke automatisk tatt i bruk i alle apps som tar i burk denne versjonen av NuGet pakkene. For at endringen skal fungere må C# klassen som representerer modellen/skjema bli oppdatert. Klassen må bli dekorert med et XmlRootAttribute hvor det er angitt et navnerom.\nEksempel:\n[XmlRoot(ElementName = \u0026#34;Skjema\u0026#34;, Namespace = \u0026#34;urn:no:altinn:skjema:v1\u0026#34;)] public class Skjema { [MaxLength(100)] [XmlElement(\u0026#34;Navn\u0026#34;)] public string Navn { get; set; } } Denne endringen må foreløpig bli utført manuelt i både gamle og nye modeller. Modeleditoren i altinn.studio har ikke blitt oppdatert til å gjøre det automatisk.\n4.13.0 (2021-09-03) - Hendelse for endring av substatus Det å endre substatus på en instanse trigger nå en event av typen app.instance.substatus.changed. Dette kan eksterne systemer abonnere på via Events tjenesten.\nDette løser sak #6691\n4.12.0 (2021-08-27) - Identitetsdata inkludert i request telemetri Logging av requests til Application Insights nå inkluderer et lite set med identifiserende data for å mer effektivt kunne spore kilden til uvanlige requester. Følgende data punkter blir registrert:\n partyId authentication level userId organisationNumber  Dette løser sak #5983\n4.11.1 (2021-08-26) - Hindre caching av data for apps uten \u0026ldquo;state\u0026rdquo; Det er lagt inn kode som gir hint til nettleser om å ikke cache data som blir brukt i apps uten state.\nDette løser #6532\n4.11.0 (2021-08-03) - Support for disabling reportee selection in Altinn Portal Apps now support adding query parameter DontChooseReportee=true to disable the reportee selection when an unauthorized user accesses an app. The result being that the user will represent themselves and be routed directly to the application after login.\nThis release solves issue #6573.\n4.10.2 (2021-07-15) - Text resources are loaded locally  The app will now load texts from the locally stored text resource files (config/texts/*) instead of retrieving them from Storage. Texts are still uploaded to Storage during deploy. The change is to remove unnecessary calls to Storage and to avoid an issue with caching that prevented new texts from being used immediately. #6466, #6415 Fixed a bug where a filename with space in it could lead to a crash. #6421 New apps created after the v2021.29 release will provide security headers like X-Frame-Options, X-XSS-Protection, X-Content-Type-Options, and Referer-Policy. To activate this in existing apps follow these steps:  Open the App/Startup.cs file. At the top of the file add the namespace reference: using Altinn.App.Api.Middleware; Find the Configure method and add the statement: app.UseDefaultSecurityHeaders(); Add it right before existing app.Use* statements. E.g. before app.UseRouting();    4.9.2 (2021-07-08) - Fixed messages from multipart request validation Validation messages from multipart request validation was misleading. This release solved issue #6418.\n4.9.1 (2021-07-02) - Bugfix for errors in multipart validation Fixed a bug that caused validation messages to show C# type of DataType rather than DataTypeId. Issue #6418\n4.9.0 (2021-06-29) - Support for marking a single field validation error as fixed It is now possible to mark a previous validation error as fixed by using the prefix *FIXED* in front of the original error. documentation on how to implement the functionality (in Norwegian )\n4.8.0 (2021-06-22) - Application version number available in AppSettings During app deployment an environment variable with the app version number/name is added to the app runtime environment. This version information can now be retrieved in any controller or service through the AppSettings configuration object. Just add a dependency on AppSettings into the class and access the new property called AppVersion.\n4.7.1 (2021-06-15) - Adjustments to response headers Some of the controllers exposed by the applications have been modified to not allow caching and/or storage of their responces in the client.\n4.7.0 (2021-06-08) Altinn Apps now authorize access for statless apps.\nAltinn Apps now have two new application events where application developers can add data processing logic. calculation, population, and more.\nIn this update the RunCalculate application event is made obsolete/deprecated. It\u0026rsquo;s recommended that Apps are updated to use RunProcessDataWrite and RunProcessDataRead instead. Calls to the RunCalculate method will be removed in a future update.\nThe process to update is\n Add the DataProcessing folder and DataProcessingHandler class from our app template to your app. Update App.cs. Add a class field for DataProcessingHandler and copy new methods ( RunProcessDataRead and RunProcessDataWrite) from App.cs Move logic from calculation handler to DataProcessinghandler Remove RunCalculation method from App.cs Remove CalculationHandler when code has been moved to DataProcessingHandler. Compile and test your app.  See details about data processing here\n4.6.2 (2021-06-01) - Duplicate keys in options causing crash This release has a fix for a crash related to PDF rendering when an app has options with duplicate entries. #5887\n4.6.1. (2021-05-21) Changed alternative subject Altinn Apps now uses org instead of organization as subject when publishing events.\n4.6.0 (2021-05-11) - Apps now support data fields Altinn Apps now support data fields. Data fields allows for adding data values, from either form fields or a custom source, to the instance object. Form data can be added by configuring data fields in applicationmetadata.json while custom sources require coding. Documentation on how to add data values to an instance can be found here.\n4.5.2 (2021-05-04) - Endpoints for stateless data elements exposed through app. Bug stopping local testing fixed Altinn Apps now expose endpoints for creating, prefilling and running calculations on stateless data elements. A stateless data element entails there is no link to an instance or instance owner, and the data is simply presented to the end user, but not persisted in any database.\nIn addition, a bug breaking apps running with localtest intoduced in 4.4.1 has been fixed.\nInformation on the new endpoints can be found in the swagger exposed by each application https://{org}.apps.altinn.no/{org}{app}/swagger\n4.4.1 (2021-04-30) - Ask user to upgrade security level An app would show the \u0026ldquo;unknown error\u0026rdquo; message if a user were trying to access an instance with a security level that was too low for the instance. This has been fixed. The user is now sent to authentication with the option to pick an authentication method that provides a higher security level. The fix targets the GET instance endpoint specifically.\n4.4.0(2021-04-27) - Performance fix Improved performance.\n4.3.0 (2021-04-28) - Apps now support presentation fields Altinn Apps now support presentation fields. By specifying presentation fields in applicationmetadata.json, speficied data values from the form data will be stored on the instance in order to show them along with the app title in the Altinn messagebox. Further documentation on how to configure presentation fields is found here.\nThis change is related to this epic.\n4.2.0 (2021-04-19) - Possible to integrate an app with eFormidling Altinn Apps now support integration with eFormidling. Documentation on how to set up an application to use eFormidling will be published once an integration point for eFormidling is set up in Altinn Platform.\n4.1.0 (2021-04-07) - Add new property with updated data to response for PUT to DataController During PUT of data to DataController ({org}/{app}/instances/{instanceOwnerPartyId:int}/{instanceGuid:guid}/data), any calculations that are defined by the apps are run, and data is potentially updated before being saved. Previously, the response returned only the metadata for the updated data element, and a GET to fetch the updated data was necessary. In this version, a dictionary of all the fields that have updated data from calculations is returned as a new parameter in the API response (in addition to the data element metadata), so that clients do not need to perform the additional GET request in order to get the updated data.\nThis change is related to this issue.\n4.0.3 (2021-03-23) - Fixed a bug reading filename from Content-Disposition  The specification for Content-Disposition specify that filename should be in quotes. This was not supported by the app backend API, causing requests following the specification to fail. This has been fixed. Added support for filename* (FilenameStar). If Content-Disposition contain both filename and filename*, the value defined by filename* will be used.  4.0.1 (2021-03-15) - Upgraded application to .Net 5 and grouped references of Altinn App and Altinn Platform services in Startup.cs Altinn.App.* librarires target .Net 5 now, which requires that the application does the same. In addition we have created two methods for referencing all app and platform sevices in Startup.cs\nSee breaking changes for how to update you app to be compatible with this version.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/handbook/",
	"title": "Utviklingshåndbok",
	"tags": ["development"],
	"description": "Utviklingshåndbok for bidrag til kodebasen i Altinn.",
	"content": "Håndbok for utvikling er foreløpig kun tilgjengelig på engelsk.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/settings/",
	"title": "Innstillinger for felt",
	"tags": [],
	"description": "Innstillinger for tekster knyttet til et felt.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt direkte i form layout inntil videre.\nMERK: Denne funksjonaliteten krever app-frontend versjon 3. Se denne lenken.\n\rIndikere at felt er valgfritt Det er mulig å styre om et felt er markert som valgfritt eller ikke. Normal oppførsel er at felt som er valgfrie blir markert som valgfrie.\nNormal oppførsel kan overstyres ved hjelp av innstillinger knyttet til feltbeskrivelsen. Dette gjøres via labelSettings på en komponent i form layout.\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;labelSettings\u0026#34;: { \u0026#34;optionalIndicator\u0026#34;: false } } } Ved å sette optionalIndicator til false vil teksten, som indikerer at feltet er valgfritt, ikke bli vist. Det er ikke mulig å tvinge visning av Valgfri teksten på et felt som er obligatorisk. Denne innstillingen styrer ikke feltets faktiske egenskaper.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/instance/",
	"title": "Instans",
	"tags": [],
	"description": "Hvordan gjøre endringer på applikasjonsinstanser",
	"content": "Denne siden er foreløpig ikke fullstendig, mer informasjon vil komme på et senere tidspunkt.\nEn instansiert applikasjon vil ha et tilhørende instans-objekt. Dette objektet inneholder metadata om den spesifikke instansen. Om du ønsker å lære mer om instans og api\u0026rsquo;et rundt så kan du lese teknisk dokumentasjon om dette under API.\nSubstatus Som app-eier kan man sette en substatus på instansen, dette for å kunne gi sluttbruker ytterligere informasjon om hvilken tilstand instansen befinner seg i. Substatus vil vises frem både i meldingsboksen i Altinn og på kvitteringssiden.\nSubstatusen er et objekt som kan settes på instansobjektet. Hvordan dette gjøres står beskrevet under API. Substatus er et enkelt objekt som inneholder label og description. Disse feltene kan enten inneholde ren tekst, eller en tekstnøkkel som referer til applikasjonstekstene. Verdt å merke seg at vi ikke støtter variabler i tekst for disse tekstene. I meldingsboksen er det satt en begrensning på 25 tegn på label, og inneholder label mer enn 25 tegn vil bare de 22 første tegnene bli brukt og \u0026ldquo;\u0026hellip;\u0026rdquo; lagt til på slutten.\nEksempel på et substatus-objekt:\n{ \u0026#34;label\u0026#34;: \u0026#34;some.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beskrivelse i klarteskst\u0026#34; } Under ser du du eksempler på hvordan substatus ser ut i meldingsboksen og i kvitteringen hvor substatusen er satt opp på følgende måte:\n{ \u0026#34;label\u0026#34;: \u0026#34;Godkjent\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Din søknad er godkjent av kongen.\u0026#34; } Automatisert sletting av utkast Som applikasjonseier kan man i noen tilfeller ønske å slette sluttbrukerens utkast av en tjeneste dersom det har gått en viss tid siden instansiering. For å oppnå dette er det tre steg som må tas.\n Applikasjonen må konfigureres slik at tjenesteeier har lov til å slette instanser Identifiser hvilke instanser som ikke er fullført v.h.a. spørring mot storage Slette instans via endepunkt eksponert i applikasjonen  Steg 1: Konfigurasjon av applikasjon Standarden for en applikasjon er at tjenesteeier ikke har lov til å slette instanser. For å få lov til dette må det legges til en ny regel i policy.xml den finnes i App/config/authorization. Regelen kan kopieres fra regelbiblioteket.\nSteg 2: Identifiser hvilke instanser som ikke er fullført v.h.a. spørring mot storage Storage eksponerer et sett med queryparametre som kan brukes når man skal hente ut et sett med instanser. i eksempelet nedenfor får man ut alle instanser som av en gitt applikasjon som er instansiert 30. september 2020 eller tidligere, og som enda står i utfyllingssteget.\nHer kan man prøve seg litt fram for å finne de rette queryparameterene for akkurat deres tjeneste.\nHTTP GET https://platform.altinn.no/storage/api/v1/instances?appId={org}/{app}\u0026amp;created=lte:2020-09-30\u0026amp;process.currentTask=Task_1\nSteg 3: Slette instans via endepunkt eksponert i applikasjone Når man har identifisert instansene som skal slettes er det en smal sak å sende et kall til applikasjonen for å få slettet disse. Da må id på instansen (instanceOwner.partyId/instanceGuid) oppgis.\nHTTP DELETE https://ttd.apps.altinn.no/ttd/apps-test/instances/{instanceOwner.partyId}/{instanceGuid}\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/instantiation/",
	"title": "Instansiering",
	"tags": [],
	"description": "Hvordan legge til logikk som skal kjøres ved instansiering?",
	"content": "Introduksjon Applikasjonslogikk knyttet til instansiering kan defineres i InstantiationHandler.cs. For en helt ny app vil det være to funksjoner implementert i denne klassen:\n RunInstantiationValidation - lag egne sjekker for å avgjøre om en bruker/avgiver får lov til å instansiere. DataCreation - lag tilpasset prefill data.  Egendefinerte valideringsregler for instansiering Som tidligere nevnt, kan sjekker for instansiering defineres i RunInstantiationValidation. Tilgang til Register- og Profile-tjenester er inkludert i InstantiationHandler.cs-filen, som tillater å gjøre sjekker mot disse. Valideringsregler for instansiering kan innebære å validere tidspunkt til spesifikke brukerrestriksjoner og komplekse sjekker som krever eksterne API-kall.\nEksempel 1 - Insansiering kun tillatt før kl 15:00 på en gitt dag public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { DateTime now = DateTime.Now; if (now.Hour \u0026lt; 15)  { return new InstantiationValidationResult() { Valid = false, Message = \u0026#34;ERROR: Instantiation not possible before 3PM.\u0026#34; }; } return null; } Eksempel 2 - Instansiering kun tillatt for applikasjonseier Kodebasen som eksempelet er basert på er tilgjengelig her. (krever innlogging i altinn.studio)\nFor å kunne begrense instansiering til en gitt entitet, i dette tilfellet applikasjonseier, er det to filer som må endres: App.cs og InstantiationHandler.cs.\nI App.cs tilgjengeliggjøres http-konteksten og brukerdata (claims principals) hentes ut fra konteksten ved å kalle _httpContext.User.\nFor å validere instansieringen kan man sjekke ett av to claims i konteksten. Enten organisasjonsen trebokstavsforkortelse eller organisasjonsnummeret. Valideringen skjer i InstantiationHandler.cs og eksempelet nedenfor bruker organisasjonsforkortelsen.\nFor å validere basert på organisasjonsnummer kan du følge eksempelet nedenfor, og bytte ut AltinnCoreClaimTypes.Org med AltinnCoreClaimTypes.OrgNumber.\nom må gjøres i denne file ser du nedenfor.\npublic async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance, ClaimsPrincipal user) { var result = new InstantiationValidationResult(); string org = string.Empty; if (user.HasClaim(c =\u0026gt; c.Type == AltinnCoreClaimTypes.Org)) { Claim orgClaim = user.FindFirst(c =\u0026gt; c.Type == AltinnCoreClaimTypes.Org); if (orgClaim != null) { org = orgClaim.Value; } } if (!string.IsNullOrWhiteSpace(org) \u0026amp;\u0026amp; org.Equals(\u0026#34;ttd\u0026#34;)) { result.Valid = true; } else { result.Valid = false; result.Message = \u0026#34;Only ttd is allowed to instantiate this application.\u0026#34;; } return await Task.FromResult(result); } Eksempel 3 - Instansiering kun tillatt mellom gitte datoer For å kunne begrense instansiering til en gitt tidsrom, i dette eksempelet januar 2021, er det én fil som må endres:InstantiationHandler.cs.\nMetoden RunInstantiationValidation vil kjøre hver gang noen prøver å instansiere applikasjonen, så her plasseres logikk for å verifiere at tidspunktet er innenfor den tillatte rammen.\npublic async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { InstantiationValidationResult result = null; DateTime now = TimeZoneInfo.ConvertTime(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById(\u0026#34;Central European Standard Time\u0026#34;)); if (now \u0026lt; new DateTime(2021, 01, 01)) { result = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated before 1.1.2021\u0026#34; }; } else if (now \u0026gt; new DateTime(2021, 01, 31)) { result = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated after 25.1.2021\u0026#34; }; } return await Task.FromResult(result); } Det er lagt inn logikk knyttet til datohåndtering for å forsikre oss om at det er norsk tid som gjelder og som blir brukt i valideringen.\nDateTime now = TimeZoneInfo.ConvertTime(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById(\u0026#34;Central European Standard Time\u0026#34;)); Videre gjøres det en enkel sjekk for å se om nåværende tidspunkt er innenfor rammene\n(now \u0026lt; new DateTime(2021, 01, 01) Dersom man ikke oppfyller kravene blir returobjektet populert med et InstantiationValidationResult objekt som inneholder to felter: Valid: en boolean som benyttes for å si om instansieringen er gyldig eller ikke Message: en string som kan inneholde en feilmelding dersom det ikke er gyldig\nresult = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated before 1.1.2021\u0026#34; }; I tillegg har man muligheten til å legge benytte property ValidParties: en liste med de partiene som kan instansiere applikasjonen.\nResultatet av en feilet validering er vist nedenfor:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/calculation/",
	"title": "Kalkuleringer",
	"tags": [],
	"description": "Hvordan legge til kalkuleringer?",
	"content": "Kalkulering er fra 4.7.0 erstattet av dataprosessering. Se her\nKalkulering Kalkuleringer kjøres på serveren, og er basert på input fra sluttbruker/skjemadata. Kalkuleringer trenger ikke å være rent matematiske, det kan også være å overføre verdier mellom felter, resultater av API-kall, osv.\nKalkuleringer kodes i C#, i filen CalculationHandler.cs. Denne filen kan redigeres enklest ved å laste ned kildekoden til app\u0026rsquo;en og redigere på egen maskin, f.eks. i Visual Studio Code. Datamodellen med skjemadata er tilgjengelig og kan redigeres/oppdateres etter ønske/behov.\nKalkuleringer kjøres hver gang data lagres. Med auto-lagring på (dette er standard) vil kalkulering kjøres hver gang en bruker har gjort en endring og hopper ut av et felt.\nVIKTIG: Når en kalkulering er kjørt som har oppdatert dataene på server, må front-end få beskjed om dette, sånn at de oppdaterte dataene kan lastes inn.\rFor å gjøre dette, må `Calculate`-metoden returnere `true` om det er noen av dataene som har blitt oppdatert.\rHvis dette ikke gjøres, vil de oppdaterte dataen ikke være synlig for sluttbruker før de ev. laster inn siden på nytt.\r\rEksempel på kode som erstatter en gitt verdi (12345678) med en annen verdi (22222222) i et gitt felt vises under:\npublic bool Calculate(object data) { if (data.GetType() == typeof(Skjema)) { // Cast the data object to model type to access all fields  Skjema model = (Skjema)data; // Get the existing value of a specified field, if it exists  string tlf = model? .OpplysningerOmArbeidstakerengrp8819? .OpplysningerOmArbeidstakerengrp8855? .OppgavegiverTelefonnummerdatadef27335?.value; // Check if the value exists and is equal to \u0026#34;12345678\u0026#34;  if (tlf != null \u0026amp;\u0026amp; tlf == \u0026#34;12345678\u0026#34;)  { // Replace the value in the field with a new value, \u0026#34;22222222\u0026#34;  model .OpplysningerOmArbeidstakerengrp8819 .OpplysningerOmArbeidstakerengrp8855 .OppgavegiverTelefonnummerdatadef27335.value = \u0026#34;22222222\u0026#34;;  // Return true to trigger a re-loading of data  return true; } } // Return false if no changes have been made  return false; } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/kodelister/",
	"title": "kodelister",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/consume/",
	"title": "Konsumere APIer i en app",
	"tags": [],
	"description": "En applikasjon kan konsumere åpne og lukkede API som er tilgjengelig via Internett.",
	"content": "ASP.NET Core har gode muligheter til å konsumere API.\nDette kan være nyttig dersom man ønsker å eksponere organisasjonens egne API via en app eller har behov for data fra eksterne API i appen.\nPå denne siden går vi gjennom et eksempel hvor et eksternt, åpent API benyttes til å berrike skjemadata. Eksempelappen kan sees i sin helhet i Altinn Studio.\nAPIet som benyttes er RestCountries v3 og det er endepunktet https://restcountries.com/v3.1/name/{country} vi er interessert i. Dette returnerer et sett med detaljer om landet som er oppgitt.\nDu kan studere responsen ved å kalle APIet fra nettleseren din: https://restcountries.com/v3.1/name/Norway.\nVi ønsker å berrike skjemaet med detaljer om et land som sluttbruker har fylt inn.\nOpprettelse av API modeller Dersom API-et som skal konsumeres er dokumentert med Swagger eller OpenAPI kan man enkelt genere C# klasser basert på datamodellen. Dette kan gjøres manuelt eller ved hjelp av verktøy som tilbyr slik generering.\nI dette eksempelet er responsobjektet stort og inneholder langt mer data enn den vi er interessert i.\nHer er et lite utklipp av responsobjektet for Norge.\n[ { \u0026#34;name\u0026#34;: { \u0026#34;common\u0026#34;: \u0026#34;Norway\u0026#34;, \u0026#34;official\u0026#34;: \u0026#34;Kingdom of Norway\u0026#34;, \u0026#34;nativeName\u0026#34;: {} }, \u0026#34;idd\u0026#34;: {}, \u0026#34;capital\u0026#34;: [ \u0026#34;Oslo\u0026#34; ], \t\u0026#34;altSpellings\u0026#34;: [], \u0026#34;region\u0026#34;: \u0026#34;Europe\u0026#34;, \t\u0026#34;subregion\u0026#34;: \u0026#34;Northern Europe\u0026#34;, \u0026#34;languages\u0026#34;: {}, \u0026#34;translations\u0026#34;: {}, \u0026#34;latlng\u0026#34;: [ 62, 10 ], \u0026#34;landlocked\u0026#34;: false, \u0026#34;borders\u0026#34;: [], \u0026#34;area\u0026#34;: 323802, \u0026#34;demonyms\u0026#34;: {}, \u0026#34;flag\u0026#34;: \u0026#34;🇳🇴\u0026#34;, \u0026#34;maps\u0026#34;: {}, \u0026#34;population\u0026#34;: 5379475, \u0026#34;postalCode\u0026#34;: { \u0026#34;format\u0026#34;: \u0026#34;###\u0026#34;, \u0026#34;regex\u0026#34;: \u0026#34;^(\\\\d{4})$\u0026#34; } } ] I applikasjonen ønsker vi kun å ta med oss dataen på de markerte linjene, altså hovedstad og region. Vi lager et minimalistisk responsobjekt som kun inneholder de feltene vi er interessert i.\nI mappen App/models opprettes det en ny fil Country.cs.\nusing System.Collections.Generic; namespace Altinn.App.models { public class Country { public List\u0026lt;string\u0026gt; Capital { get; set; } public string Region { get; set; } } } Country-objektet består av feltene Capital og Region. Capital er en liste med strenger, da et land kan ha flere hovesteder.\nI dette eksempelt krever ikke APIet et komplekst request-objekt og dermed kan vi nøye oss med den ene modellen. Skulle det være behov for et request-objekt kan dette opprettes på samme måte.\nOppsett av interface for klienten Det anbefales at det defineres et interface for klienten som skal kalle API. Det gjør at vi kan benytte oss av styrkene til .NET med dependency injection og effektiv håndtering av HTTP-klienter.\nI applikasjonsrepoet opprettes mappen App/clients, i den nye mappen opprettes filen ICountryClient.cs.\nInterfaces består av én metode GetCountry som tar inn en streng og returnerer et Country-objekt.\nDefiner interfacet som vist nedenfor.\nusing System.Threading.Tasks; using Altinn.App.models; namespace Altinn.App.client { public interface ICountryClient { /// \u0026lt;summary\u0026gt;  /// Retrieves metadata about the provided country.  /// \u0026lt;/summary\u0026gt;  /// \u0026lt;param name=\u0026#34;country\u0026#34;\u0026gt;The name of the country\u0026lt;/param\u0026gt;  /// \u0026lt;returns\u0026gt;A country object\u0026lt;/returns\u0026gt;  public Task\u0026lt;Country\u0026gt; GetCountry(string country); } } Returobjektet er omkranset av Task\u0026lt;...\u0026gt; denne er lagt inn for å vise til at kallet som skal gjøres vil være asynkront.\nImplementere klient Det er klienten som inneholder koden som gjør kallet mot APIer og omformer resultatet til Country-modellen som forventes i retur av funksjonene som kaller klienten.\nDen fulle implementasjonen av Country-klienten er vist nedenfor.\nusing System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Threading.Tasks; using Altinn.App.models; using Microsoft.Extensions.Logging; namespace Altinn.App.client { public class CountryClient : ICountryClient { HttpClient _client; ILogger\u0026lt;ICountryClient\u0026gt; _logger; JsonSerializerOptions _serializerOptions; public CountryClient(HttpClient client, ILogger\u0026lt;ICountryClient\u0026gt; logger) { _logger = logger; _client = client; _client.BaseAddress = new Uri(\u0026#34;https://restcountries.com/v3.1\u0026#34;); _serializerOptions = new() { PropertyNameCaseInsensitive = true }; } public async Task\u0026lt;Country\u0026gt; GetCountry(string country) { string query = $\u0026#34;name/{country}\u0026#34;; HttpResponseMessage res = await _client.GetAsync(query); if (res.IsSuccessStatusCode) { string resString = await res.Content.ReadAsStringAsync(); List\u0026lt;Country\u0026gt; countryResponse = JsonSerializer.Deserialize\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt;(resString, _serializerOptions); return countryResponse.Any() ? countryResponse.First() : null; } else { _logger.LogError(\u0026#34;Retrieving country {country} failed with status code {statusCode}\u0026#34;, country, res.StatusCode); return null; } } } } Øverst i filen finner du referansen til alle namespace som klassen er avhengig av\nusing System; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Threading.Tasks; using Altinn.App.models; using Microsoft.Extensions.Logging; Videre definerer vi klassen og hvilket interface den arver fra\npublic class CountryClient : ICountryClient Videre er tre private objekter _client, __logger og _serializerOptions\nprivate readonly HttpClient _client; private readonly ILogger\u0026lt;ICountryClient\u0026gt; _logger; private readonly JsonSerializerOptions _serializerOptions; Understrek foran navnet er kun en navnekonvensjon og har ingen effekt.\n _client vil i konstruktøren populeres med en http-klient. _logger vil i konstruktøren populeres med en logger slik at man kan logge feilmeldinger og annet i klassen _serializerOptions vil i konstruktøren instansieres og konfigureres for å kunne deserialisere responsen fra APIet.  Videre i klassen defineres konstruktøren.\npublic CountryClient(HttpClient client, ILogger\u0026lt;ICountryClient\u0026gt; logger) { _logger = logger; _client = client; _client.BaseAddress = new Uri(\u0026#34;https://restcountries.com/v3.1\u0026#34;); _serializerOptions = new() { PropertyNameCaseInsensitive = true }; } Objekter populeres dersom de kommer som input i konstruktøren og andre objekter instansieres. Skulle du ha behov for å bruke en av de andre servicene som er registeret i applikasjonen er det bare å sende den inn i konstruktøren og opprette et privat objekt for å kunne ta det i bruk i klassen slik vi har gjort med _logger eller _client.\nVidere i klassen finner du implementasjonen av metoden GetCountry.\npublic async Task\u0026lt;Country\u0026gt; GetCountry(string country) { string query = $\u0026#34;name/{country}\u0026#34;; HttpResponseMessage res = await _client.GetAsync(query); if (res.IsSuccessStatusCode) { string resString = await res.Content.ReadAsStringAsync(); List\u0026lt;Country\u0026gt; countryResponse = JsonSerializer.Deserialize\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt;(resString, _serializerOptions); return countryResponse.Any() ? countryResponse.First() : null; } else { _logger.LogError(\u0026#34;Retrieving country {country} failed with status code {statusCode}\u0026#34;, country, res.StatusCode); return null; } } Her gjøres det en sjekk på at statuskoden på API-kallet er en suksess-kode før vi deserialiseres og returnerer objektet. Dersom det ikke er en suksess-statuskode logger vi en feil og returnerer null.\nRegistrere klienten i applikasjonen Når interface og klient er implementert kan den registreres i App/Program.cs (.NET 6) eller i App/Startup.cs (.NET 5) for bruk i applikasjonen.\nI metoden ConfigureServices legger vi til kodelinjen nedenfor\nservices.AddHttpClient\u0026lt;ICountryClient, CountryClient\u0026gt;(); Benytte klient i applikasjonslogikk For å berrike skjemadata må vi koble klienten vår på logikken i App/logic/DataProcessingHandler.cs i metoden ProcessDataWrite.\nFørst må klienten tilgjengeliggjøres ved å injecte den inn i konstruktøren til klassen. DataProcessingHandler har ingen konstruktør i utgangspunktet så den må opprettes i klasse.\npublic DataProcessingHandler() { } Videre kan vi opprette et privat objekt for klienten, injecte den i konstruktøren og assigne den til det private objektet. Resultatet blir seende slik ut:\nprivate readonly ICountryClient _countryClient; public DataProcessingHandler(ICountryClient countryClient) { _countryClient = countryClient; } _countryClient er nå tilgjengelig i DataProcessingHandler og vi er klare til å implementere logikken i ProcessDataWrite.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite(Instance instance, Guid? dataId, object data) { if (data.GetType() == typeof(skjema)) { skjema skjema = (skjema)data; if (!string.IsNullOrEmpty(skjema.land)) { Country country = await _countryClient.GetCountry(skjema.land.Trim()); if (country != null) { skjema.hovedstad = string.Join(\u0026#34;,\u0026#34;, country.Capital); skjema.region = country.Region; } else { skjema.hovedstad = skjema.region = string.Empty; } return true; } else { skjema.hovedstad = string.Empty; skjema.region = string.Empty; } } return await Task.FromResult(false); } Prøver du å bygge applikasjonen nå vil du få en feil. DataProcessingHandler instansieres i App.cs, så alle dependecies må og inn i denne filen og så sendes videre i konstruktøren til DataProcessingHandler.\nI filen App/logic/App.cs gjøres følgende endringer\n  legg til en referanse til namespaces til klienten øverst i filen\nusing Altinn.App.client;   Inject ICountryClient nederst i App.cs-konstruktøren.\nDette er gjort på linje 14.\n1public App( 2 IAppResources appResourcesService, 3 ILogger\u0026lt;App\u0026gt; logger, 4 IData dataService, 5 IProcess processService, 6 IPDF pdfService, 7 IProfile profileService, 8 IRegister registerService, 9 IPrefill prefillService, 10 IInstance instanceService, 11 IOptions\u0026lt;GeneralSettings\u0026gt; settings, 12 IText textService, 13 IHttpContextAccessor httpContextAccessor, 14 ICountryClient countryClient) : base( 15 appResourcesService, 16 logger, 17 dataService, 18 processService, 19 pdfService, 20 prefillService, 21 instanceService, 22 registerService, 23 settings, 24 profileService, 25 textService, 26 httpContextAccessor)   Legg til countryClient i konstruktøren til DataProcessingHandler\n_dataProcessingHandler = new DataProcessingHandler(countryClient);   Caching av responsdata En ulempe med eksempelet slikt det står nå er at man for hver gang skjemaet lagres vil man gjøre et kall mot endepunktet for å hente ut data.\nDet er rimelig å anta at et lands hovedstad og hvilken region det tilhører ikke vil endre seg hyppig. Har vi hentet informasjon om Norge kan vi lagre denne lokalt i applikasjonen i en tidsperiode, så man slipper å gjøre kallet igjen.\nKodeendringene beskrives ikke steg for steg, men er vist i sin helhet nedenfor. Det kreves kun endringer i CountryClient.cs.\nusing Altinn.App.models; using Microsoft.Extensions.Caching.Memory; using Microsoft.Extensions.Logging; using System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Threading.Tasks; namespace Altinn.App.client { public class CountryClient : ICountryClient { private readonly HttpClient _client; private readonly ILogger\u0026lt;ICountryClient\u0026gt; _logger; private readonly JsonSerializerOptions _serializerOptions; private readonly IMemoryCache _memoryCache; private readonly MemoryCacheEntryOptions _cacheOptions; public CountryClient(HttpClient client, ILogger\u0026lt;ICountryClient\u0026gt; logger, IMemoryCache memoryCache) { _logger = logger; _client = client; _client.BaseAddress = new Uri(\u0026#34;https://restcountries.com/v3.1/\u0026#34;); _serializerOptions = new() { PropertyNameCaseInsensitive = true }; _memoryCache = memoryCache; _cacheOptions = new() { AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(24) }; } public async Task\u0026lt;Country\u0026gt; GetCountry(string country) { string uniqueCacheKey = \u0026#34;Country_\u0026#34; + country; // Check if country is present in cache, if so return from cache  if (_memoryCache.TryGetValue(uniqueCacheKey, out Country outputCountry)) { return outputCountry; } string query = $\u0026#34;name/{country}\u0026#34;; HttpResponseMessage res = await _client.GetAsync(query); if (res.IsSuccessStatusCode) { string resString = await res.Content.ReadAsStringAsync(); List\u0026lt;Country\u0026gt; countryResponse = JsonSerializer.Deserialize\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt;(resString, _serializerOptions); if (countryResponse.Any()) { outputCountry = countryResponse.First(); // Add response country to cache  _memoryCache.Set(uniqueCacheKey, outputCountry, _cacheOptions); return outputCountry; } else { return null; } } else { _logger.LogError(\u0026#34;Retrieving country {country} failed with status code {statusCode}\u0026#34;, country, res.StatusCode); return null; } } } } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/konsumere-api/",
	"title": "konsumere API",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/technology/solutions/altinn-platform/receipt/",
	"title": "Kvittering",
	"tags": ["platform", "register"],
	"description": "Kvitteringskomponenten i Altinn Platform viser kvittering for apper.",
	"content": "Kvitteringskomponenten er laget for å vise en kvittering for alle apper. Noen apper vil fjernes fra Altinn Apps med tiden, men innsendte data vil likevel være tilgjengelig, og Kvitteringskomponenten er ansvarlig for å vise en generisk kvittering for innsendte data uavhengig av applikasjonen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/localtest/",
	"title": "localtest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/losningsforslag/",
	"title": "losningsforslag",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/message/",
	"title": "Melding",
	"tags": [],
	"description": "Hvordan sette opp en melding i Altinn Studio.",
	"content": "En melding i Altinn 3 er egentlig bare et data-steg, på samme måte som f.eks. skjemautfylling. Det settes opp med en datamodell for meldingen, og en layout for hva som skal vises på siden. Melding er dermed ikke en egen steg-type. Dette gjør at en melding i Altinn 3 er ekstremt fleksibel, og kan settes opp enten som eneste steg i en prosess, eller som en del av en større prosess.\nVi har lagd noen verktøy som skal gjøre det enkelt å komme i gang med å sette opp en melding i en app.\nDatamodell Vi har lagd en standard datamodell for meldinger, for å gjøre det enkelt å komme i gang. Denne datamodellen kan man finne her. Denne kan enten brukes som den er, brukes som et utgangspunkt, eller man kan bruke en helt annen datamodell.\nLayout Layout\u0026rsquo;en kan man definere helt selv, på samme måte som for skjema. Vi har allikevel opprettet en meldings-widget, for å gjøre det enklere å komme i gang. Denne widget\u0026rsquo;en inneholder alle komponentene som trengs for å lage visningen under. Den inneholder også tekster som legges til i ressurs-filene automatisk, som har variabler med referanser til feltene Title og Body i standard datamodell. Dersom man ønsker andre tekster eller å bruke en annen datamodell, er det bare å redigere enten komponentene eller tekstene etter ønske etter at de er lagt inn i siden.\nMerk at om en ønsker å bruke _vedleggslisten_, som er med i standard meldings-widget, må man i tillegg manuelt legge inn hvilke _datatyper_ vedleggene som skal vises har i layout-filen. Det er lagt inn en placeholder for dette i komponenten når den legges til med widget'en. Funksjonalitet for å sette dette i Altinn Studio vil komme senere. Tilgjengelige datatyper ligger i `applicationMetadata.json`-filen til appen. Om dette ikke gjøres vil ikke generering av PDF fungere.\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/migration/",
	"title": "Migrering til versjonerte charts",
	"tags": [],
	"description": "Migrering fra helm template filer til versjonert helm dependency.",
	"content": "For å forenkle oppraderings prosessen av deployment charts har vi flyttet template filene ut et sentralt repository på github. Fra her publiseres helm charts som igjen draes inn i apps repoene som avhengigheter.\nDette gir oss muligheten til å oppdatere standard måte for deploy til altinn3 i et sentralt repository og forenkler jobben for tjenesteiere ved oppgradering.\nHvordan avdekke om din app bruker gammel deployment stretegi Åpne opp appen din i gitea eller hent siste versjon ned til din datamaskin med git.\nHvis mappen som heter deployment ser ut som nedenfor:\ndeployment\r├── .helmignore\r├── Chart.yaml\r├── templates\r│ ├── NOTES.txt\r│ ├── _helpers.tpl\r│ ├── deployment.yaml\r│ ├── horizontalPodAutoscaler.yaml\r│ ├── ingressRoute.yaml\r│ ├── middleware.yaml\r│ └── service.yaml\r└── values.yaml\rog innholdet i filen deployment/Chart.yaml er lignende dette:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 Benytter din applikasjon gammel deployment strategi og du kan følte guiden for hvordan du skal oppgradere til ny her.\nHvis mappen deployment ser sut som nedenfor:\ndeployment\r├── .helmignore\r├── Chart.yaml\r└── values.yaml\rog innholdet i `deployment/Chart.yaml er lignende dette:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Benytter din applikasjon siste deployment strategi.\nHvordan du konfigurerer din deployment er dokumentert her\nNye versjoner er tilgjengelige. Hvis det er ny major versjon må du være obs på breaking changes.\r\rMigrere til ny deployment strategi Migreringen er rimelig enkel og involverer bare tre endringer i mappen deployment:\n Slett mappen templates. Definer avhengigheten til den sentralt vedlikeholde helm-charten i din Chart.yaml. dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Your Chart.yaml should now look like this:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0  Legg til en ny linje i toppen av values.yaml og skriv inn deployment: på denne linjen. Legg til to space først på hver linje etter dette (yaml behandler tab og mellomrom forskjellig så forsikre deg om at det er mellomrom). Gitt at din values.yaml ser ut som det her: replicaCount: 3 image: # Set \u0026#34;repository\u0026#34; name of your image for manual Helm install and upgrade. repository: tag: latest pullPolicy: Always pullSecrets: # Change this to the name of your pull secret - name: acr-secret service: name: deployment type: ClusterIP externalPort: 80 # If your application is running on another port, change only the internal port. internalPort: 5005 linkerd: enabled: true ingressRoute: name: Will be inserted during deploy entryPoints: - http - https routes: - match: Will be inserted during deploy kind: Rule services: - name: Will be inserted during deploy port: 80 middlewares: - name: hsts-header tls: options: name: tls-options secretName: ssl-cert volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken Etter at du har gjort dine migrerings endringer bør denne se ut som følger:\ndeployment: replicaCount: 3 image: # Set \u0026#34;repository\u0026#34; name of your image for manual Helm install and upgrade. repository: tag: latest pullPolicy: Always pullSecrets: # Change this to the name of your pull secret - name: acr-secret service: name: deployment type: ClusterIP externalPort: 80 # If your application is running on another port, change only the internal port. internalPort: 5005 linkerd: enabled: true ingressRoute: name: Will be inserted during deploy entryPoints: - http - https routes: - match: Will be inserted during deploy kind: Rule services: - name: Will be inserted during deploy port: 80 middlewares: - name: hsts-header tls: options: name: tls-options secretName: ssl-cert volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken   Commit og Push dine endringer til gitea og neste deploy av din applikasjon vil være med ny deployment strategi\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/",
	"title": "Modeller",
	"tags": [],
	"description": "Dette er en oversikt over de fleste modellene brukt av de forskjellige APIen. Den forklarer ikke hver eneste property i alle modeller, men vil forsøke å gi en solid introduksjon til de viktigste delene.",
	"content": "\rApp metadata\rThe application metadata document holds technical information about the app and the data type requirements.\n\r\rInstance\rAn instance is a metadata container that is used to track the status and progress of one interaction between an app user and owner.\n\r\rDataElement\rEt DataElement er en metadatabeholder som brukes til å spore statusen til faktiske data blobs.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/goals/",
	"title": "Mål",
	"tags": [],
	"description": "Oppsummering av målene for Altinn 3.",
	"content": "Brukervennlige og responsive applikasjoner  Brukergrensesnitt som er vennlig, effektivt og moderne. Støtte for responsivt design, både for tjenestene og tjenesteutviklingsverktøyet. Innebygd universell utforming med støtte for WCAG 2 God ytelse og lave responstider  Effektiv og selvbetjent tjenesteutvikling  Som utvikler kan du gjøre alt selv (inkludert å sette tjenesten i produksjon) når du vil, uten bestillinger, kursing eller lignende. Ingen flaskehalser. Effektiv og reell testing, der enhetstesting lokalt fungerer likt som i testmiljøer og produksjon Støtte for automatisert testing Regler og logikk defineres én gang for alle kanaler (portal og API), og er mer robust enn i gammel plattform Innebygd datamodelleringsverktøy (og støtte for import av modeller fra eksterne verktøy som SERES, OR, osv. ) Ikke behov for Citrix for å få tilgang til Altinn Studio  Enkelt for ikke-tekniske utviklere, fleksibelt for tekniske utviklere  Ikke-tekniske apputviklere har tilgang på relevant funksjonalitet i det nettleserbaserte grensesnittet til Altinn Studio Du kan gjenbruke gode, gjennomtestede komponenter Det er enkelt å gjøre kall mot eksterne API-er, både for gjenbruk av data og for å kjøre ekstern logikk Tekniske utviklere kan konfigurere alle aspekter ved appene, for eksempel overstyre styling og lage egne komponenter Gjenbruke tekster og andre ressurser på egnet nivå (plattform, organisasjon, applikasjon), og alle språk er støttet Git brukes som kildekodehåndtering (inkludert versjonshåndtering) for appene, både fra nettleser og ved bruk av kodeeditor.  Plattformuavhengig åpen kildekode  Altinn 3 bygger på åpen kildekode Altinn 3 skal være åpen kildekode Altinn 3 kan kjøres på din egen maskin, dine egne servere, på Windows, macOS eller Linux Alt er basert på åpne web-standarder og god utviklingskunnskap og -praksis.  "
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/spec/",
	"title": "OpenAPI (swagger) for Apps",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/spec/",
	"title": "OpenAPI (swagger) for Authentication",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/events/spec/",
	"title": "OpenAPI (swagger) for Events",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/spec/",
	"title": "OpenAPI (swagger) for Storage",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/openapi/",
	"title": "openapi",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/oed/",
	"title": "Oppgjør etter dødsfall",
	"tags": ["app"],
	"description": "Dokumentasjon av arkitektur, design, funksjonalitet og apper relatert til oppgjør etter dødsfall.",
	"content": "Innledning Figuren under viser de viktigste komponentene i løsningen. OED er realisert som en serie Tjenester 3.0 app\u0026rsquo;er med en overordnet app med skreddersydd GUI og øvrige Tjenester 3.0 apper for spesifikke formål.\nApp\u0026rsquo;ene kan ikke instansieres fra tjenestekatalogen. Hovedapp\u0026rsquo;en instansieres utelukkende fra Domstol grensesnittet, og «Altinn avgiver» (process instance owner) er avdøde. Arvinger og evt andre som skal benytte løsningen får tilgang til instansen via tildelte roller i Altinn autorisasjon. Brukeren (arvingen) finner app\u0026rsquo;en fra en melding «Altinn correspondence» i meldingsboksen i Altinn. Meldingen inneholder en direktelenke til riktig instans i Tjenester 3.0. Se for øvrig 3 Grensesnitt mot Domstolene.\nLøsningens hovedapp har følgende adresse i Altinn Studio: designer og kode.\nOppdeling i Tjenester 3.0 apper Hovedapp\u0026rsquo;en har et skreddersydd brukergrensesnitt fordi Tjenester 3.0 p.t. ikke støtter å lage vilkårlige applikasjoner. Løsningen er derfor splittet opp i flere app\u0026rsquo;er slik at mest mulig realiseres som standard tjeneste 3.0 apper. I første omgang gjelder dette skjemautfylling. På sikt kan det også være aktuelt å flytte «innsynsfunksjonalitet» ut i Tjenester 3.0 app\u0026rsquo;er, men p.t. er støtten for GUI design i Tjenester 3.0 såvidt begrenset at det er vanskelig å implementere ønsket brukeropplevelse.\nSkjema app\u0026rsquo;ene blir instansiert og preutfylt fra hovedapp\u0026rsquo;en når brukeren tar initiativ til å starte skjemautfylling. Skjemaet blir instansiert med avdøde som «Altinn avgiver» (process instance owner), og fødselsnummer til den arvingen som startet skjemautfylling blir lagt som en nøkkel på instansdataene med Tjenester 3.0 mekanismen «data value» med nøkkel «ssn».\nDet er lagt opp til at alle arvingene aksesserer de samme skjemainstansene bortsett fra skjemaet «oed-signature». I sistnevnte skjema blir det en unik instans per arving.\nAll innsending av data fra arvingene gjøres via skjema app\u0026rsquo;er. Signering ved innsending benytter derfor standard Tjenester 3.0 funksjonalitet. Hvis gjeldene funksjonalitet for signering ikke tilfredsstiller formelle krav til løsningen (f.eks. om man ønsker nivå 4 signering), må dette være utvidelser/forbedringer i Tjenester 3.0 plattformen \u0026ndash; ikke spesifikt i OED løsningen.\nFølgende app\u0026rsquo;er finnes p.t.:\n oed (hoved app) oed-register-agri-property oed-register-heirs oed-register-marriage-pact oed-register-testament oed-signature  Mer dokumentasjon knyttet mot applikasjoner vedrørende Tjenester 3.0 finnes her:\nOED: https://github.com/Altinn/oed/issues/442\nT3.0: https://github.com/Altinn/altinn-studio/issues/6880\nGrensesnitt mot Domstolene Grensesnittet for å motta data fra Domstolene er definert av Domstolene og ligger på GitHub - Altinn/oed-da. Dette er et hendelsesbasert grensesnitt med samme oppbygning som eksiterende Altinn grensesnitt mot Folkeregisteret. P.t. er det bare spesifisert overføringer av nye avdøde og arvinger, men det er forventet at grensesnittet kan utvides til endringer på avdøde og arvinger samt testamentinformasjon.\nProsjektet har besluttet å implementere grensesnittet som en Altinn II batch. Bakgrunnen for at grensesnittet ikke ble implementert i Tjenester 3.0 er:\n Tjenester 3.0 støttet ikke batch jobber da beslutningen ble tat Tjenester 3.0 har ikke et regime for driftsoppfølging av batcher Tjenester 3.0 tilbyr ikke databaser for app\u0026rsquo;er utover lagring av skjemadata og instansdata. Domstol grensesnittet krever at man lagrer en tilstand mellom hver kjøring. Altinn II har ikke eksponert eksterne tjenester for å laste inn roller/rettigheter. Altinn II batch jobber kan benytte interne tjenester.  Batchen kjøres automatisk ved regelmessige intervaller og gjør følgende:\n Henter nye arvinger fra Domstolene Tildeler roller mellom arving og avdøde i Altinn Autorisasjon Gjør oppslag mot KRR (Altinn kopi) angående reservasjon mot elektronisk behandling. Det er p.t. ikke avgjort om Altinn skal ha ansvar for dette og hva som eventuelt skal være konsekvensen hvis det foreligger en reservasjon. Hente utfyllende informasjon om arving og avdøde fra Folkeregisteret (Altinn kopi). Sjekke om det finnes en instans av boet. Opprette instans hvis den ikke finnes Legge arving inn blant instansdata Sende melding til arving (Altinn II Correspondence). Meldingen blir liggende i Altinn meldingsboks dyplenke inn til avdødes instans Sende varsling til arving på epost/SMS basert på informasjon fra KRR. (Gjøres som en integrert del av forrige punkt.)  Batchen ligger i Altinn II repo for batcher og heter Altinn.SBL.Batch.DA.\nGrensesnitt data fra eksterne aktører Autorisasjon Nedenfor beskrives hva som ligger til grunn for autorisasjonen.\nImplisitt fullmakt fra DA (1-2)\nAltinn mottar en implisitt fullmakt fra DA (dvs at en person er en arving) ved hjelp av DA grensesnittet (1). Fullmakten lagres i Altinn (2). Fullmakten lagres logisk to steder:\n  I boets instans i OED appen\nDet lagres hvem som er avdød og hvilke arvinger som har fullmakt. Se for øvrig åpne punkter nederst i dokumentet.\n  Som autorisasjonsregler i Altinn sin standard autorisasjonsløsning\nDet lages en eller flere autorisasjonsregler per arving.\n  Aksess til eksterne ressurser fra OED basert på fullmakt (3-7)\nBasert på fullmakt fra DA kan OED hente data fra eksterne kilder på vegne av arvinger med fullmakt. OED gjør system-til-system oppslag mot eksterne kilder. Oppslagene autoriseres ved hjelp av egnet autorisasjonsinfrastruktur \u0026ndash; primært Maskinporten (3-4). Maskinporten returnerer et token (4) som sendes med til eksternt system (5). Tokenet er bevis overfor eksterne parter at forespørselen kommer fra OED. Oppslagene har nesten alltid avdødes fødselsnummer som forespørselsnøkkel (5). Eksterne systemer må stole på at OED kun gjøre forespørsel når det foreligger en fullmakt samt at OED ikke viser dataene til arvinger uten fullmakt. Avdødes fødselsnummer er nøkkel til fullmakten i OED (2).\nBeskrivelsen i dette dokumentet gjelder uavhengig av om man teknisk gjør oppslag mot eksterne kilder basert på en arvings aktivitet i portalen eller om det gjøres asynkront \u0026ndash; uavhengig av brukerinteraksjon. I figuren over er det antydet at dataene lagres i OED (7), men hvis man velger å ikke lagre dataene, påvirker ikke dette den øvrige beskrivelsen.\nVise data fra eksterne aktører til arvinger (8-12)\nDet defineres i OED hvilket krav man har til autentisering (8) av arvingene. Det er naturlig at man definerer et nivå som ID-Porten eller høyere. Alle innlogginger logges i Altinn (samt i ID-Porten eller annen ekstern infrastruktur for autentisering) (8-10). OED vet derfor alltid hvem brukeren er. OED definerer også autorisasjonsregler som gjør at det ikke er mulig for noen andre enn de som har fått autorisasjonsregler fra fullmakten å aksessere et gitt dødsbo (11). Når brukeren får tilgang til eksterne data, er disse hentet ut basert på fullmakten som foreligger fra DA, og de vises til brukeren (12) basert på autorisasjonsreglene fra fullmakten.\nRevisjonsspor\nAt de ikke blir utlevert opplysninger fra ekstern kilde uten fullmakt kan dokumenteres ved følgende revisjonsspor:\n  Fullmakten ligger lagret i Altinn (2). Fullmakten inkluderes saks-id fra DA. Fullmakten peker tilbake til kilden hos DA (1).\n  Altinn gjør oppslag mot eksterne kilder ved hjelp av autorisasjonsinfrastruktur (primært Maskinporten) som beviser at oppslaget ble gjort fra OED (3-4). Oppslaget blir gjort med avdødes fødselsnummer som nøkkel (5-6), og samme fødselsnummer er nøkkel til fullmakten (2).\n  Arvingene må autentisere seg før aksess til OED (8). Alle autentiseringsforsøk blir logget i Altinn sin TTP (trusted third party) database (9-10).\n  All aksess til OED autoriseres. Alle autorisasjoner logges i altinn sin TTP (trusted third party) database (11). Autorisasjonsloggen inkluderer aktuell bruker, tidspunkt, hvilken ressurs som ble forsøkt aksessert (i dette tilfellet referanse til avdødes instans med tilhørende fullmakt i OED) og utfall av autorisasjonen.\n  Åpne punkter\nSkal alle arvinger med tilgang til OED ha fullmakt? I motsatt fall må det gjøres intern autorisasjon i OED som differensierer hva slags informasjon som skal vises avhengig av hvilken arving som har logget inn.\nEr fullmakt implisitt dekket av eksisterende DA grensesnitt (ny arving foreligger i boet) eller trenger man en ny hendelse \u0026ndash; fullmakt \u0026ndash; i DA grensesnittet? Er for øvrig relatert til forrige punkt. Hvorvidt fullmakt blir en ny hendelse eller ikke påvirker ikke beskrivelsen over annet enn at DA grensesnittet eventuelt må oppdateres.\nLagring av innhentede data Det er gjort konfigurerbart (via felles kode \u0026ndash; se 4.3 Intern implementasjon) hvorvidt man skal lagre data fra aktørene blant instansdataene etter at de er framvist for arvingen. P.t. prøver man først å hente friske data når arvingen åpner app\u0026rsquo;en. Dataene lagres samtidig. Hvis man ikke får tak i data og det ligger data på instansen fra før, vises disse.\nIntern implementasjon De fleste grensesnittene har Swagger spesifikasjoner. Der dette ikke finnes lager vi Swagger manuelt. Det benyttes standard mekanismer i Visual Studio for å importere Swagger definisjonene og generere klientkode \u0026ndash; «Connected Services».\nMotparten til den genererte koden ligger i klasser i katalogen ExternalApi. I disse klassene kalles Api, og og det blir gjort en mapping til intern domenemodell.\nHver grensesnitt er tilgjengelig fra GUI via ExternalAPIController. Kontrolleren har felles kode for alle grensesnittene for å:\n Kalle grensesnitt Hente instans Lagre respons i instans Benytte lagret respons hvis gjeldende oppslag ikke returnerer data Gjøre evt mapping av fødselsnummer \u0026ndash; se 4.3 Testdata Returnere data til GUI  De genererte klientene konfigureres i startup.cs. Her hentes vertsnavn fra miljøspesifikke konfigurasjonsfiler.\nListe over grensesnitt P.t. benyttes følgende grensesnitt\n   Aktør Eks*) Swagger     Skatt  Skatt avregning   Skatt  Skatt 2020   Skatt  Skatt tilgjengelige data   Kartverket x API docs   SVV x Kjøretøy søk   Norsk Pensjon x API docs   Bank KAR x DSOP KFR API   Bank konto x DSOP Konto API   Geo Norge x Kommune API   Geo Norge x Adresse API   Landbruk  API docs   Ektepakt x n/a SOAP grensesnitt    *) Betyr at swagger kommer fra aktør og ikke er konstruert av OED\nTestdata Det mest optimale hadde vært om man kunne definere felles testdata på tvers av alle aktører i OED. Dette er imidlertid ikke realistisk på kort sikt. Det er definert en modul for mappe avdødes fødselsnummer, som benyttes som nøkkel i nesten alle eksterne grensesnitt, til et passende fødselsnummer hos aktuell aktør.\nMappingen utføres bare når man kjører løsningen i et testmiljø. Mappingen ligger som kode i metoden MapSsn i ExternalAPIController.\nKode for å autorisere mot Maskinporten og eventuell utveksling av token fra Maskinporten til Altinn JWT ligger i Util/MaskinportenUtil.\nGrensesnitt for å hente ut data Eksterne aktører \u0026ndash; i første omgang primært Domstolene \u0026ndash; kan hente ut data via standardiserte Api fra Tjenester 3.0. Dette er beskrevet i Storage API \u0026ndash; Altinn.\nDet anbefales å benytte en hendelsesbasert innfallsvinkel til å hente ut data. Dette er beskrevet i Integration \u0026amp; Data Transport Capabilties \u0026ndash;Altinn.\nDet finnes tilgjengelige data fra hver app. Det antas at Domstolene i første omgang vil hente data fra skjema app\u0026rsquo;ene. Avdøde vil være «instance owner». Fødselsnummeret til den arvingen som fylte ut skjemaet, vil ligge som «data value» med nøkkel «ssn».\nCustom GUI for hoved app Tjenester 3.0 tilbyr p.t. ingen støtte for skreddersydde brukergrensesnitt, som man trenger i hovedapp. Det er derfor tatt utgangspunkt i en kopi av Tjenester 3.0 sin fulle klient for skjemautfylling. I denne klienten er det i noen grad fjernet komponenter som ikke er relevante for en skreddersydd klient, men det gjenstående er likevel stort og komplekst.\nKlienten - altinn-app-frontend.js - lenkes inn i fila App\\views\\Home\\Index.cshtml. I utviklingsmiljøet benyttes lokal node modul mens i prod- og testmiljøer refereres den ferdig kompilerte .js-fila fra bygg prosessen.\nOED spesifikk kode for klienten ligger hovedsakelig under mappen features/custom, der mapper og filer oppdeles logisk basert på visningstype og fagområde. Det har blitt tatt i bruk eksisterende biblioteker, basert på kopien av Tjenester 3.0 sin fulle klient og ikke lagt til nye utenom React testing library og Cypress. Disse bibliotekene blir brukt for enhetstesting, ende-til-ende testing og universell utforming tester.\nDet har blitt utviklet en del komponenter, både spesifikt tilknyttet OED design men også tilknyttet Altinn 3 Figma Designsystem ettersom Tjenester 3.0 per nå har ingen felles bibliotek som brukes av andre klienter. Det har vært mye samarbeid mellom OED og Tjenester 3.0 for å løse slik problematikk og OED har utviklet, tildelsvis med Tjenester 3.0 en rekke enkle komponenter med tilhørende design basert på Altinn 3 Designsystem. Disse ligger innunder mappen features/custom/common/inputs. Tanken har vært at disse enkle komponentene kan tas rett ut fra prosjektet og legges ut på npm for felles bruk av alle klienter. Dette har stoppet opp da det ikke har vært relevant for OED lenger å utvikle egne skjema komponenter, som nevnt innunder kapittel 2.\nRedux og React Context brukes av OED for intern state håndtering da Redux var allerede vesentlig brukt av Tjenester 3.0. I Redux ligger det mye data som kommer fra kopien av Tjenester 3.0 sin klient og Redux Store har blitt utvidet til å inneha data fra eksterne aktører, eksempelvis data fra banker, Statens Vegvesen, Norsk Pensjon og andre.\nDrift og overvåkning Før man kan gå i produksjon må det avklares hvordan løsningen kan driftes og overvåkes. Viktige momenter vil være:\n Monitorere at Tjenester 3.0 app\u0026rsquo;ene er oppe og fungerer Monitorere at batch for DA grensesnitt kjører og fungerer. Det må avklares om Altinn Forvaltning skal benyttes i denne sammenheng. Analyse av feillogger Sanering av data  "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/options/",
	"title": "options",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/org/",
	"title": "API test org",
	"tags": [],
	"description": "Når man kjører applikasjonene lokalt sammen med den lokale testplattformen kan man teste API som applikasjon eksponerer.",
	"content": "Appen har en rekke API som kan benyttes av applikasjonseier/tjenesteeier. Beskrivelsen du finner her er laget for Postman hvor det er benyttet testapplikasjonen MVA testapp.\nPostman-prosjektet kan lastes ned fra her (høyreklikk og velg \u0026ldquo;save as\u0026rdquo;).\nAutentisering av tjenesteier org I testmiljø og produksjon brukes maskinporten for å autentisere organisasjoner som eier apper.\nTestplattformen for lokal testing tilbyr et enkelt api for å autentisere organisjonen som er ansvarlig.\nMan trenger bare å oppgi tjenesteeier kode (som f.eks brg, skd osv)\nUrl: http://altinn3local.no/Home/GetTestOrgToken/ttd (ttd needs to be replaced with the org you want to authenticate)\nThe response is a JWT token that should be uses as a Authorization header.\nMultipart instansiering Applikasjonene støtter at man instansierer instanser til aktører. Personer eller organsiasjoner.\nUrl: http://altinn3local.no/ttd/mva/instances\nMetode: POST\nHeaders:\n Authorization: Bearer + jwttoken Content-Type: multipart/form-data; boundary=\u0026ldquo;abcdefg\u0026rdquo;  Eksempel Body:\n--abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34;  { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;organisationNumber\u0026#34; : \u0026#34;897069650\u0026#34; } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;RF0002\u0026#34;  \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;212\u0026#34; spesifikasjonsnummer=\u0026#34;10420\u0026#34; blankettnummer=\u0026#34;RF-0002\u0026#34; tittel=\u0026#34;Alminnelig omsetningsoppgave\u0026#34; gruppeid=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;GenerellInformasjon-grp-2581 gruppeid=\u0026#34;2581\u0026#34;\u0026gt; \u0026lt;Avgiftspliktig-grp-50 gruppeid=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;RapporteringsenhetNavn-datadef-21771 orid=\u0026#34;21771\u0026#34;\u0026gt;DDG Fitness\u0026lt;/RapporteringsenhetNavn-datadef-21771\u0026gt; \u0026lt;RapporteringsenhetAdresse-datadef-21773 orid=\u0026#34;21773\u0026#34;\u0026gt;Sofies Gate 1\u0026lt;/RapporteringsenhetAdresse-datadef-21773\u0026gt; \u0026lt;RapporteringsenhetPostnummer-datadef-21774 orid=\u0026#34;21774\u0026#34;\u0026gt;0170\u0026lt;/RapporteringsenhetPostnummer-datadef-21774\u0026gt; \u0026lt;RapporteringsenhetPoststed-datadef-21775 orid=\u0026#34;21775\u0026#34;\u0026gt;By\u0026lt;/RapporteringsenhetPoststed-datadef-21775\u0026gt; \u0026lt;RapporteringsenhetOrganisasjonsnummer-datadef-21772 orid=\u0026#34;21772\u0026#34;\u0026gt;897069650\u0026lt;/RapporteringsenhetOrganisasjonsnummer-datadef-21772\u0026gt; \u0026lt;/Avgiftspliktig-grp-50\u0026gt; \u0026lt;/GenerellInformasjon-grp-2581\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- Example Response The below response show how an instance was created for a given organization.\n1{ 2 \u0026#34;id\u0026#34;: \u0026#34;500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 3 \u0026#34;instanceOwner\u0026#34;: { 4 \u0026#34;partyId\u0026#34;: \u0026#34;500000\u0026#34;, 5 \u0026#34;personNumber\u0026#34;: null, 6 \u0026#34;organisationNumber\u0026#34;: \u0026#34;897069650\u0026#34; 7 }, 8 \u0026#34;appId\u0026#34;: \u0026#34;ttd/mva\u0026#34;, 9 \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, 10 \u0026#34;selfLinks\u0026#34;: { 11 \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/mva/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 12 \u0026#34;platform\u0026#34;: \u0026#34;https://localhost:5101/storage/api/v1/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34; 13 }, 14 \u0026#34;dueBefore\u0026#34;: null, 15 \u0026#34;visibleAfter\u0026#34;: null, 16 \u0026#34;title\u0026#34;: { 17 \u0026#34;nb\u0026#34;: \u0026#34;RF-0002\u0026#34; 18 }, 19 \u0026#34;process\u0026#34;: { 20 \u0026#34;started\u0026#34;: \u0026#34;2020-01-24T06:37:48.6026647Z\u0026#34;, 21 \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, 22 \u0026#34;currentTask\u0026#34;: { 23 \u0026#34;flow\u0026#34;: 2, 24 \u0026#34;started\u0026#34;: \u0026#34;2020-01-24T06:37:48.6027116Z\u0026#34;, 25 \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, 26 \u0026#34;name\u0026#34;: \u0026#34;Utfylling\u0026#34;, 27 \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, 28 \u0026#34;ended\u0026#34;: null, 29 \u0026#34;validated\u0026#34;: null 30 }, 31 \u0026#34;ended\u0026#34;: null, 32 \u0026#34;endEvent\u0026#34;: null 33 }, 34 \u0026#34;status\u0026#34;: null, 35 \u0026#34;appOwner\u0026#34;: { 36 \u0026#34;labels\u0026#34;: null, 37 \u0026#34;messages\u0026#34;: null, 38 \u0026#34;canBeDeletedAfter\u0026#34;: null 39 }, 40 \u0026#34;data\u0026#34;: [ 41 { 42 \u0026#34;id\u0026#34;: \u0026#34;54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 43 \u0026#34;instanceGuid\u0026#34;: \u0026#34;b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 44 \u0026#34;dataType\u0026#34;: \u0026#34;RF0002\u0026#34;, 45 \u0026#34;filename\u0026#34;: null, 46 \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, 47 \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/mva/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 48 \u0026#34;selfLinks\u0026#34;: { 49 \u0026#34;apps\u0026#34;: \u0026#34;https://altinn3local.no/ttd/mva/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 50 \u0026#34;platform\u0026#34;: \u0026#34;https://localhost:5101/storage/api/v1/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34; 51 }, 52 \u0026#34;size\u0026#34;: 1009, 53 \u0026#34;locked\u0026#34;: false, 54 \u0026#34;refs\u0026#34;: [], 55 \u0026#34;created\u0026#34;: \u0026#34;2020-01-24T06:37:48.641997Z\u0026#34;, 56 \u0026#34;createdBy\u0026#34;: null, 57 \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-01-24T06:37:48.641997Z\u0026#34;, 58 \u0026#34;lastChangedBy\u0026#34;: null 59 } 60 ], 61 \u0026#34;created\u0026#34;: \u0026#34;2020-01-24T06:37:48.6068671Z\u0026#34;, 62 \u0026#34;createdBy\u0026#34;: null, 63 \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-01-24T06:37:48.6068671Z\u0026#34;, 64 \u0026#34;lastChangedBy\u0026#34;: null 65} "
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/platform/",
	"title": "Platform",
	"tags": [],
	"description": "DevOps teamet Platform jobber hovedsaklig med Altinn 3 sine platform applikasjoner og drift av disse.",
	"content": "Arbeidsområde Platform teamet har ansvar for de fleste felles tjenestene for Altinn 3. Dette inkluderer videreutvikling, retting av feil og mangler, infrastruktur og tilgjengelighet.\nRepository\nEvents Applikasjonen Events og tilhørende funksjoner i Azure gir Altinn 3 en mekanisme for å publisere og abonnere på hendelser.\nRepository\nPdf Applikasjonen Pdf kan benyttes til å generere PDF dokumenter av Altinn 3 skjema.\nRepository\nProfile Applikasjonen Profile gir Altinn 3 tilgang til profilinformasjon på brukere i Altinn.\nRepository\nReceipt Applikasjonen Receipt er et system for å vise en kvittering på at et skjema er fylt ut og ferdistilt.\nRepository\nRegister Applikasjonen Register gir Altinn 3 tilgang til registerinformasjon på personer og virksomheter som opererer i Norge.\nRepository\nStorage Applikasjonen Storage gir en app i Altinn 3 et sted å lagre data som blir samlet inn, og metadata om tilstanden til skjema under utfylling.\nSBLBridge Applikasjonen SBLBridge er Altinn 3 sin proxy inn mot Altinn 2 systemet.\nAnnen infrastruktur Teamet har også ansvar for alle applikasjonseierspesifikke Kubernetes cluster, og Dev-Test-Lab miljøet ai-dev med alle utviklermaskiner.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/platform/",
	"title": "platform",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/policy/",
	"title": "policy",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/prefill/",
	"title": "prefill",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/presentations/",
	"title": "Presentasjoner og Altinn kaffe",
	"tags": [],
	"description": "The Altinn-kaffe meeting series is a low threshold meeting series, where app owners (and potential app owners) can learn more about what we&#39;re doing in Altinn 3. It&#39;s also designed to gather information on how Altinn can help app owners realise their Altinn 3 potential. Slides mainly in Norwegian.",
	"content": "Introduksjonspresentasjon og utbredelsesstrategimøte Det første møtet var en lengre introduksjon til plattformen og målene med den.\n Altinn 3 - hva og hvorfor?  Vi holdt et møte for at man skulle kunne gi input på Altinn 3 utbredelsesstrategi 28. januar 2021. Disse presentasjonene ble vist.\n Overordnet Strategi og tiltak Kort status fra Team Tjenestestøtte  Vi har også lagd en mer generell presntasjon om hva Altinn Studio / Altinn 3 er, og hvordan man kommer i gang\n Generell Presentasjon og Kom i Gang  Status og planer Annenhver uke presenterer vi hva vi har gjort og hva vi planlegger å gjøre den neste to-ukersperioden.\n Status og planer - 30. september 2020 Status og planer - 14. oktober 2020 Status og planer - 28. oktober 2020 Status og planer - 11. november 2020 Status og planer - 25. november 2020 Status og planer - 9. desember 2020 Status og planer - 6. januar 2021 Status og planer - 20. januar 2021 Status og planer - 3. februar 2021 Status og planer - 17. februar 2021 Status og planer - 3. mars 2021 Status og planer - 17. mars 2021 Status og planer - 14. april 2021 Status og planer - 28. april 2021 Status og planer - 12. mai 2021 Status og planer - 26. mai 2021 Status og planer - 9. juni 2021 Status og planer - 23. juni 2021 Status og planer - 26. august 2021 Status og planer - 9. september 2021 Status og planer - 23. september 2021 Status og planer - 7. oktober 2021 Status og planer - 21. oktober 2021 Status og planer - 3. november 2021 Status og planer - 18. november 2021 Status og planer - 2. desember 2021 Det kommer mer\u0026hellip;  Temamøter Ukene vi ikke presenterer status, har vi temamøter. Hvis det ikke ligger noen presentasjon, hadde vi sannsynligvis livedemo eller gjennomgang av dokumentasjon.\n Hvordan komme i gang med Altinn 3? (7. oktober 2020) Altinns presentasjon | SSBs presentasjon Integrasjon med mottakssystem (21. oktober 2020) Hvordan bidra til et bedre Altinn 3? (4. november 2020) Signering i Altinn 3 (18. november 2020) Kalkulering i Altinn 3 (16. desember 2020) Hvordan bruke første halvtimen i Altinn Studio (27. januar 2021) Datamodellering i Altinn Studio (24. februar 2021) Lanserte tjenester (10. mars 2021) Arbeidstilsynets presentasjon | Presentasjon for Kartverket Planer for utvikling i Q2 2021 (7. april 2021) Tilgang til logger og hemmeligheter (21. april 2021) Altinn Events - inkludert mulighet for push (5. mai 2021) Datamodellering: Håndtering av utfasing av Seres (19. mai 2021) Case: Karantenehotellunntak (2. juni 2021) Standardisering vs. fleksibilitet (30. juni 2021) Kopiering av app (2. september 2021) Framtida for meldingstjenester (29. november 2021) Det kommer mer\u0026hellip;  NDC 2020 Dette er et foredrag som ble holdt 11. juni 2020 på NDC Oslo, der tre av utviklerne våre presenterer Altinn 3 like etter produksjonssetting.\nForedraget er på engelsk, men er tekstet på både engelsk og norsk.\n   Slides brukt under presentasjonen (pptx) Behind the scenes  "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/process/",
	"title": "process",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorisation/rules/",
	"title": "Regelbibliotek",
	"tags": [],
	"description": "Bibliotek av autorisasjonsregler som kan brukes i en app. Husk å bytte ut tags ([ORG], [APP], [RULE_ID]) med din egen data.",
	"content": "[ORG] kan instansiere [ORG]/[APP] [ORG_1] og [ORG_2] kan her være like eller ulike. I tilfellet at de er ulike vil [ORG_1] tilsvare applikasjonseieren og [ORG_2] være en annen organisasjon som får lov til å instansiere.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG_2] can instantiate an instance of [ORG_1]/[APP]\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG_2]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG_1]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;instantiate\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rollen REGNA can lese instanser av [ORG]/[APP] som er i Task_1 Ved å endre på rolle og task i denne regelen vil du kunne gi rettigheter til å lese instansdata på en gitt task i prosessflyten.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA can read instances of [ORG]/[APP] when it is in Task_1\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;Task_1\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:task\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan skrive til en instans av [ORG]/[APP] uavhengig av prosessflyt Denne regelen kan brukes dersom applikasjonseier skal kunne oppdatere instanser uavhengig av hvor de er i prosessflyten sin.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG] can write to instances of [ORG]/[APP] in any task or event\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;write\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rollen REGNA eller DAGL kan bekrefte instanser av [ORG]/[APP] som er i Task_2 Denne reglen begrenser rettigheten til å bekrefte en instans i en bestemt task til kun to roller. Ved å enten modifisere task eller roller vil du her kunne sette regler for hvem som får bekrefte instansen i ulike faser av prosessen.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA or DAGL can confirm instances of [ORG]/[APP] when it is in Task_2\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;DAGL\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;Task_2\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:task\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;confirm\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rolle REGNA kan lese instanser av [ORG]/[APP] som er i EndEvent_1 Denne regler tillatter en bruker med den gitte rollen å lese instansdata etter at prosessen er avsluttet. Dette vil bl.a. inkludere å laste ned vedlegg og kvitteringer knyttet til instansen.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA can read instanes of [ORG]/[APP] when it is in EndEvent_1\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;EndEvent_1\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:end-event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Regel som definerer at [ORG] kan fullføre en instans av [ORG]/[APP] som har en fullført prosess. Denne regelen tillatter applikasjonseier å utføre en kvittering på at de er ferdig med en instans. Instansen må ha en fullført process.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;Rule that defines that [ORG] can complete an instance of [ORG]/[APP] which state is at the end event.\u0026lt;/xacml:Description\u0026gt;  \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;EndEvent_1\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:end-event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;complete\u0026lt;/xacml:AttributeValue\u0026gt;  \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan slette en instans av [ORG]/[APP] uavhengig av hvor den er i prosessen Denne regelen tillatter applikasjonseier å slette en instans. Dette kan gjøres uavhengig av hvor i prosessen instansen er.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG] can delete an instance of [ORG]/[APP] in any task or event.\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;delete\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan aksesserere med autentiseringsnivå 3 \u0026lt;xacml:ObligationExpressions\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel1\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation1-assignment1\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;4\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel2\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation2-assignment2\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel-org\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;3\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;/xacml:ObligationExpressions\u0026gt; "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/register/",
	"title": "register",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/repeterende-grupper/",
	"title": "repeterende grupper",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/scenarios/",
	"title": "Scenarier",
	"tags": [],
	"description": "Forskjellige API-bruksscenarier.",
	"content": "\rAutentisering\rHvordan autentisere ved å bruke APIene.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/user/",
	"title": "API bruk som sluttbruker",
	"tags": ["todo"],
	"description": "Når man kjører applikasjonen lokalt så kan man teste API beregnet for sluttbruker.",
	"content": "TODO\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/enduser/",
	"title": "Sluttbrukerfunksjonalitet i Altinn 3",
	"tags": [],
	"description": "Dette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.",
	"content": "Lansert funksjonalitet For informasjon om hvordan man bruker funksjonalitetene som er beskrevet her, se brukerdokumentasjonen for Altinn Studio.\n\r\rSkjemafunksjonalitet Støtte for innsendingstjenester. Et utvalg standardkomponenter å bygge med (eks. tekstfelt, radioknapp, sjekkliste, datovelger, vedlegg, repeterende gruppe av komponenter), inkludert sidestilling av elementer (støtte for grid). Støtte for at skjemaet består av flere sider, men sluttbruker kan kun navigere framover/bakover mellom sidene (styrt navigasjon). Alle skjema og elementer har standardisert look and feel.\nStøtte for å sette opp ulike regler, herunder kalkulering, validering og dynamikk på både element- og sidenivå (dvs. styre hva som vises ut fra hva bruker fyller inn i skjemaet.)\nElementene kobles med tekster og knyttes til datamodell. Mulighet til å koble på API-er som datakilder, samt å forhåndsutfylle med data fra Altinns kopier av Folkeregisteret og Enhetsregisteret.\nVi støtter også innsynstjenester (rene oppslagstjenester) (#1328) ✔️\nArbeidsflyt i applikasjonen Du kan kombinere flere ulike steg i den rekkefølgen som er relevant for tjenesten:\n Utfylling/melding (data) - eksponering av data fra tjenesteeier og/eller innhenting av data fra sluttbruker Bekreftelse (confirm) - bruker skal bekrefte at dette er dataene de ønsker å sende inn Vente på tilbakemelding (feedback) - prosessen er ikke fullført, men det er andre enn bruker (tjenesteeier eller tredjepart) som skal gjøre noe  I tillegg har alle en sluttstatus for at instanser er arkivert/fullført.\nAutentisering og autorisasjon Det er støtte for å definere hvilke(n) rolle(r) som har tilgang til ulike operasjoner per steg i arbeidsflyten. Rollene kan enten være Altinn-roller, roller fra Enhetsregisteret eller at tjenesteeier selv har tilgang.\nIntegrasjon med meldingsboksen i Altinn Instanser av tjenester ligger i brukers meldingsboks på samme måte som i Altinn 2. Det er mulig å finne instansene ved bruk av søk (men med enkelte begrensninger).\nDu kan bruke presentasjonsfelter for å skille instanser av samme app fra hverandre (Q2 2021) (#594) ✔️\nTjenesteeier har selv mulighet til å angi hvilken status som er relevant for den enkelte instans. Det er også mulig å definere opp at instanser av en app aldri skal legges i brukers arkiv.\nIntegrasjon med sluttbrukersystemer Tjenestene har standardiserte API-er som kan benyttes for innsending fra tredjepartssystemer. Hver app har sine egne endepunkter. Autentisering av bruker skjer med ID-porten.\nKommende funksjonalitet Altinn 3 er i stadig videreutvikling, og funksjonalitet lanseres løpende. Backlogg revideres åtte ganger i året, og mindre endringer kan også forekomme mellom revisjonene. Generelt kan man si at jo lenger frem i tid leveranse er planlagt jo mer usikkert er angitt leveransetidspunkt.\nEndringer beskrevet i kursiv er å regne som på idéstadiet, og er ikke besluttet at skal utvikles. Lenker i parentes er til beskrivelser i vår åpne backlog på Github.\nSkjemafunksjonalitet Det skal være mulig å definere opp brukergrensesnitt som passer godt til den enkelte tjenestens behov. Eksempler på kommende funksjonaliteter:\n Friere navigering mellom sider (Q4 2021) (#5893) Utfyllbare tabeller (Q4 2021) (#378) Mulighet for å endre språk inne i applikasjonen (Q1 2022) (#2055). Denne endringen gjør det også mulig å tilby tjenester på andre språk enn bokmål/nynorsk/engelsk. Ulike «tema» for brukergrensesnittet i portalen (#2115)  Arbeidsflyt i applikasjonen Vi vil utvide biblioteket med tilgjengelige arbeidsflytsteg for å dekke stadig flere bruksområder. Eksempler på kommende funksjonaliteter:\n Funksjonell signering (Q4 2021) (#5540) Teknisk signering (Q1 2022) Komplekse signeringsregler - f.eks. basert på hva som fylles ut i skjemaet og parallellsignering (x av y personer skal signere) (Q2 2022) (#1324) / (#1325) Betaling (Q3 2022) (#1320) Friere navigering mellom stegene i prosessen (Q4 2021) (#2743) Innhenting av samtykke  Autentisering og autorisasjon Vi skal tilby minst samme fleksibilitet for brukerne til å styre hvem som har tilgang til Altinn 3-tjenestene som finnes i Altinn II. Det innebærer f.eks. følgende endringer:\n Støtte for delegering på app-nivå (Q4 2021) (#2731) Støtte for delegering på instansnivå (Q4 2021) (#2732) Tilgang til app med virksomhetsbruker (#3743) Whitelisting av aktuelle brukere for en app (#5547)  Hendelsesstyrte tjenester For å bygge sammenhengende tjenestekjeder, uten at man må bygge kompleks orkestrering, er det nødvendig at en tjeneste skal kunne \u0026ldquo;reagere\u0026rdquo; på hendelser i en annen app, eller på eksterne hendelser. Å legge til rette for denne måten å lage tjenestekjeder ligger i planene for andre halvår 2022.\nVarslinger (e-post og sms) Å sende ut varsler på e-post og/eller sms er en viktig del av flere tjenester. Inntil videre vil Altinn 3 bruke varslingsfunksjonaliteten i Altinn II.\n Det skal være mulig å koble varslingene til ulike hendelser i appene (Q1 2022) (#4275) Sluttbruker selv skal kunne sende e-post av kvitteringen (Q3 2022) (#1902)  Integrasjon med meldingsboksen i Altinn Det skal være lett å finne riktig instans av en tjeneste i meldingsboksen. For å få til dette legger vi til:\n Støtte for å lage ny instans med utgangspunkt i en eksisterende - lag ny kopi (Q2 2021) (#1566) Sjekk av om man allerede har en instans av app i meldingsboks, slik at man får velge mellom ny instans eller fortsette på eksisterende (Q2 2021) (#1811) Mulighet for å søke i innholdet i instansene (#5450)  "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/solution/",
	"title": "solution",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/sporvalg/",
	"title": "sporvalg",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/",
	"title": "Storage API",
	"tags": [],
	"description": "Beskrivelse av API&#39;et til Storage komponenten i Altinn 3 platformen.",
	"content": "\rInstanser\rPlatform API for instanser.\n\r\rInstance events\rPlattform API for å jobbe med instans-hendelser.\n\r\rOpenAPI (swagger) for Storage\r\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/",
	"title": "Storage Interface endringslogg",
	"tags": [],
	"description": "Oversikt over endringer introdusert i Altinn.Platform.Storage.Interface NuGet package.",
	"content": "\rv3\rOversikt over endringer introdusert i v3 av Altinn.Platform.Storage.Interface.\n\r\rv2\rOversikt over endringer som ble introdusert i v2 av Altinn.Platform.Storage.Interface.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/api/studio/",
	"title": "Altinn Studio Repository API",
	"tags": [],
	"description": "OpenAPI (swagger) spesifikasjon for App kildekode API.",
	"content": "Se https://altinn.studio/repos/api/swagger\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/studio/",
	"title": "Studio",
	"tags": [],
	"description": "Team Studio",
	"content": "\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/swagger/",
	"title": "swagger",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/",
	"title": "Teams",
	"tags": [],
	"description": "Våre DevOps-teams",
	"content": "\r\rApps\rTeam Apps\n\r\rPlatform\rDevOps teamet Platform jobber hovedsaklig med Altinn 3 sine platform applikasjoner og drift av disse.\n\r\rStudio\rTeam Studio\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/test/",
	"title": "test",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/testusers/",
	"title": "Testbrukere lokalt",
	"tags": [],
	"description": "Vi har definert et lite sett med testbrukere som er tilgjengelig for lokal test.",
	"content": "Disse kan man velge når man logger inn i lokal test.\nSophie Salt Sophie er en svært driftig dame som bor i Oslo. Hun har startet en kjede med treningsententer som heter DDG Fitness og til nå er det startet 3 underenheter i Oslo, Bergen og Trondheim. Sophie har rollen DAGL og dens underroller for DDG Fitness AS og dens underhenheter.\nI tilegg er hun ekspert på helse og har startet eget konsulentfirma for helsetjenester. Sophie har rollen LEDE + knyttede roller for EAS Health Consulting.\nHun er også styremedlem i borettslaget der hun bor. \u0026ldquo;Oslos Vakreste Borettslag\u0026rdquo;. Sophie har rollen MEDL + knyttede roller for \u0026ldquo;Oslos Vakreste Borettslag\u0026rdquo;.\nAvgivere    Avgiver Roller     01039012345 Sophie Salt Privatperson   897069650 DDG Fitness AS Daglig leder + knytninger   897069651 DDG Fitness Bergen Daglig leder + knytninger   897069652 DDG Fitness Oslo Daglig leder + knytninger   897069653 DDG Fitness Trondheim Daglig leder + knytninger   897069631 EAS Health Consulting Styreleder + knytninger   950474084 Oslos Vakreste Borettslag Styremedlem + knytninger    Ola Nordmann. Ola Nordmann er en privatperson som kun kan representere seg selv. Er bosatt på Stokmarknes.\nAvgivere  01017512345 Ola Nordmann  "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/texts/",
	"title": "texts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/be-om-api-nokkel/",
	"title": "Bestill tilgang til REST API",
	"tags": ["app"],
	"description": "Dokumentasjon av appen for å bestille API-nøkler for bruk i Altinn.",
	"content": "TODO: Dokumentasjon, screenshots, etc\n Info Repo Kjørende tjeneste  "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/customize/",
	"title": "Tilpasse visninger av steg",
	"tags": [],
	"description": "Hvordan tilpasse visninger i forskjellige steg av en prosess.",
	"content": "En applikasjon vil ha en prosess som brukeren av applikasjonen vil følge. Avhengig av hvilken type steg brukeren er i, vil forskjellige ting vises. Denne siden vil forklare hvordan visningen til de forskjellige stegene kan tilpasses.\nData (tilsvarer utfyllingssteg i Altinn II) I denne prosess-task-typen vises skjema som kan fylles ut.\nSkjema kan redigeres ved bruk av UI editoren eller ved å endre FormLayout.json direkte.\nBekreftelse (Confirmation) I denne prosess-task-typen vises noen standard-tekster, og bruker kan velge å bekrefte for å gå videre.\nTekstene kan overstyres, ved at man legger inn tekstnøkkel som hører til hver tekst i språkfilene for appen. Info om hvordan dette gjøres finner du her. Se under for oversikt over de forskjellige tekstnøklene som kan overstyres.\nOverstyre tekster    Tekst nr. (se bilde over) Tekstnøkkel     1 confirm.title   2 confirm.sender   3 confirm.body   4 confirm.answers   5 confirm.attachments   6 confirm.button_text    Eksempel på overstyrte tekster i filen resources.nb.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;confirm.title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Vennligst bekreft at du ønsker å sende inn\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.body\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du må kun trykke send inn om du er helt sikker på at du vil sende inn. \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;I det du trykker send inn kan du ikke gjøre endringer.\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.attachments\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Dokumenter med opplysninger\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.button_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Lagre og fortsett\u0026#34; } Merk at i eksempelet over har vi brukt html-taggen \u0026lt;br/\u0026gt; for å lage linjeskift. For lenke og utheving, benytt markdown.\nDette resulterer i følgende visning:\nTilbakemelding (Feedback) Dette er et prosesssteg hvor applikasjonseier vil sjekke utfylte data for å generere en tilbakemelding før alle data kan arkiveres.\nTekstene på siden kan overstyres ved at man legger inn tekstnøkler som hører til hver tekst i språkfilene for appen. Info om hvordan dette gjøres finner du her. Se under for oversikt over de forskjellige tekstnøklene som kan overstyres.\nOverstyre tekster    Tekst nr. (se bilde over) Tekstnøkkel     1 feedback.title   2 feedback.body    Eksempel på overstyrte tekster i filen resources.nb.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;feedback.title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Vent på at tjenesteeier sjekker data\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;feedback.body\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Når tjenesteier har sjekket at alle data er godkjent vil du bli automatisk sendt videre til siste steg i prosessen.\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/todo/",
	"title": "todo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/training/",
	"title": "training",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/translate-to-english/",
	"title": "translate-to-english",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/translate-to-norwegian/",
	"title": "translate-to-norwegian",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/designer/ui-editor/",
	"title": "UI editor",
	"tags": [],
	"description": "Hvordan bygge et skjema med UI editor i Altinn Studio.",
	"content": "Bygge et skjema ved bruk av UI editor UI Editor er tilgjengelig i fanen Lage når man er inne i en app i Altinn Studio.\nBruke skjemakomponenter Skjemakomponentene kan trekkes inn i arbeidsområdet (i midten) fra menyen til venstre. Man kan deretter endre rekkefølgen på dem ved hjelp av drag and drop i arbeidsområdet.\nNår du holder muspekeren over en komponent, eller når du velger den ved å klikke på den, blir to ikoner synlig - et søppelbøtte-ikon for å slette komponenten, og et blyant-ikon for å endre på egenskapene til komponenten.\nSe oversikten over skjemakomponenter for mer detaljer om komponentene som er tilgjengelig.\nRedigere egenskapene til komponentene Hver komponent har et sett med egenskaper som kan redigeres, for eksempel kobling til tekster og kobling til datamodell osv. For å endre på egenskapene, klikk blyant-ikonet som vises når du holder musepekeren over komponenten du vil endre på.\nGjør deretter endringene du ønsker, og lagre dem ved å klikke på hake-ikonet til høyre for egenskapsredigeringen. Du kan forkaste endringene ved å klikke på kryss-ikonet.\nMERK: UI-editoren og kompoentene er under utvikling. Det vil derfor være perioder der ikke alle egenskaper kan settes i UI-editor.\r\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/",
	"title": "v1",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v1 av deployment.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i deployment i v1.1.0\n\r\rHva er nytt\rOversikt over endringer som ble introdusert i v1 av deployment.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v2/",
	"title": "v2",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v2 av deployment.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i deployment i v2.0.0\n\r\rHva er nytt\rOversikt over endringer som ble introdusert i v2 av deployment.\n\r\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/validation/",
	"title": "Validering",
	"tags": [],
	"description": "Hvordan legge til logikk for å validere skjemadata?",
	"content": "Introduksjon Valideringer sørger for at brukerens input er gyldig med tanke på datamodellen, i tillegg til alle egendefinerte regler som settes opp for applikasjonen. Valideringer kan kjøres enten på klient (dvs. browseren) eller serversiden.\nKlientside-validering Dette er validering som kjøres i browseren, FØR data er sendt til server for lagring. Dette gjør det mulig å gi raske tilbakemeldinger til sluttbruker underveis i utfylling.\nKlientside-validering baserer seg på datamodellen som hører til skjemaet, og bruker denne til å bestemme hva som er gyldig input i et felt. Helt konkret brukes JSON Schema utgaven av datamodellen for valideringen. Denne genereres automatisk når man laster opp XSD. Det går an å gjøre endringer i JSON schema direkte for å tilpasse valideringen ved behov.\nMerk at dersom man gjør tilpasninger i JSON schema manuelt, for å så oppdatere XSD og laste inn på nytt, vil nytt JSON schema også genereres, og alle manuelle tilpasninger må gjøres på nytt. Derfor er det anbefalt å gjøre endringer i XSD og/eller datamodelleringsverktøyet for at disse endringene skal reflekteres i JSON schema.\nEt eksempel på hvordan et felt kan defineres i JSON schema datamodellen er:\n\u0026#34;someField\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: \u0026#34;4\u0026#34; } Input i dette feltet vil valideres mot begrensningene som er satt opp, og en feilmelding vil vises dersom disse ikke møtes - i dette tilfellet, dersom input er en tekst med lengde mer enn 4 karakterer.\nStandard feilmeldinger Det er satt opp standard feilmeldinger for alle valideringene som gjøres på klientsiden. Se oversikten under.\n   Regel Feilmelding bokmål Feilmelding nynorsk Feilmelding engelsk     min \u0026lsquo;Minste gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Minste gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Minimum valid value is {0}\u0026rsquo;   max \u0026lsquo;Største gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Største gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Maximum valid value is {0}\u0026rsquo;   minLength \u0026lsquo;Bruk {0} eller flere tegn\u0026rsquo; \u0026lsquo;Bruk {0} eller flere tegn\u0026rsquo; \u0026lsquo;Use {0} or more characters\u0026rsquo;   maxLength \u0026lsquo;Bruk {0} eller færre tegn\u0026rsquo; \u0026lsquo;Bruk {0} eller færre tegn\u0026rsquo; \u0026lsquo;Use {0} or fewer characters\u0026rsquo;   length \u0026lsquo;Antall tillatte tegn er {0}\u0026rsquo; \u0026lsquo;Antall tillatte tegn er {0}\u0026rsquo; \u0026lsquo;Number of characters allowed is {0}\u0026rsquo;   pattern \u0026lsquo;Feil format eller verdi\u0026rsquo; \u0026lsquo;Feil format eller verdi\u0026rsquo; \u0026lsquo;Wrong format or value\u0026rsquo;   required \u0026lsquo;Feltet er påkrevd\u0026rsquo; \u0026lsquo;Feltet er påkrevd\u0026rsquo; \u0026lsquo;Field is required\u0026rsquo;   enum \u0026lsquo;Kun verdiene {0} er tillatt\u0026rsquo; \u0026lsquo;Kun verdiene {0} er tillatt\u0026rsquo; \u0026lsquo;Only the values {0} are permitted\u0026rsquo;    Egendefinerte feilmeldinger Det er mulig å definere egne feilmeldinger som skal vises når et felt får valideringsfeil. Dette gjøres ved å legge på en parameter errorMessage der hvor feltet er definert i JSON schema. JSON schema filen ligger i mappen App/models og følger navnestandard *.schema.json.\nF.eks., man kan utvide eksempelet over:\n\u0026#34;someField\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;myCustomError\u0026#34; } Man kan skrive ønsket tekst direkte inn her, eller bruke en tekstnøkkel for en tekst definert i ressursfilene for språkstøtte.\nLegg merke til at om man har en referanse til en definisjon så må feilmeldingen ligge på property-feltet, og ikke på referansen/definisjonen. Eksempel:\n{ \u0026#34;properties\u0026#34;: { \u0026#34;person\u0026#34;: { \u0026#34;$ref\u0026#34; : \u0026#34;#/definitions/personDefinition\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;myCustomError\u0026#34;,  } }, \u0026#34;definitions\u0026#34;: { \u0026#34;personDefinition\u0026#34; : { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, ... } } Merk at ved XSD-endringer, så vil ev. egendefinerte feilmeldinger forsvinne da JSON schema filen genereres på nytt fra XSD. På sikt er det tenkt at det å sette opp egendefinerte feilmeldinger skal være mulig å gjøre via datamodelleringsverktøyet i Altinn Studio. Per nå må dette gjøres manelt.\r\rServerside-validering Serverside-validering kan deles opp i to kategorier:\n Valideringer mot datamodell - Disse kjører automatisk når brukeren prøver å sende inn skjemadata. Egendefinerte valideringer - Disse skrives av applikasjonsutvikleren, og kjører når brukeren prøver å sende inn skjemadata eller flytte prosessen til et nytt steg.  Hvordan legge til egendefinert validering Egendefinerte validering kan igjen deles opp i to kategorier; task-validering og data-validering.\n Task-validering vil kjøres hver gang validering trigges enten manuelt fra applikasjonen eller når man prøver å flytte seg framover i prosessen. Data-validering vil kjøre dersom man står på et steg som har definerte dataelementer knyttet til seg.  Valideringer er skrevet i C#, i ValidationHandler.cs -filen i applikasjonsmalen. Filen kan aksesseres og endres i Altinn Studio via logikkmenyen, ved å velge Rediger valideringer, eller direkte i applikasjonsrepoet der ligger filen i logic/Validation-mappen.\nEndringer gjøres i ValidateData og ValidateTask-metodene (disse er tomme når appen lages). Førstnevnte får inn et dataobjekt og sistnevnte får inn instansen og taskId. For å legge til en valideringsfeil brukes AddModelError-metoden til validationResults object som sendes med i begge metodene.\nEt eksempel på en enkel data-validering som sjekker at feltet FirstName ikke inneholder verdien 1337, når rotelementet til modellen er Skjema er vist nedenfor:\npublic void ValidateData(object data, ModelStateDictionary validationResults) { if (data.GetType() == typeof(Skjema)) { // Cast instance data to model type  Skjema model = (Skjema)data; // Get value to test - FirstName  string firstName = Skjema?.Person?.FirstName; // Check if FirstName exists, and contains the value \u0026#34;1337\u0026#34;  if (firstName != null \u0026amp;\u0026amp; firstName.Contains(\u0026#34;1337\u0026#34;))  { // Add validation error, with error message and list  // of affected fields (in this case Person.FirstName)  validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;Error: First name cannot contain the value \u0026#39;1337\u0026#39;.\u0026#34; ); } } } Se kommentarer i koden over for en forklaring på hva de ulike delene gjør.\nI det andre parameteret til metoden AddModelError, der det står \u0026ldquo;Error: First name cannot contain the value \u0026lsquo;1337\u0026rsquo;\u0026rdquo;, kan man bruke en tekstnøkkel for en tekst definert i ressursfilene for språkstøtte.\nEt eksempel på en enkel task-validering som sjekker hvor lang tid brukeren har brukt på Task_1 og returnerer en feil dersom det har tatt lenger enn 3 dager.\npublic async Task ValidateTask(Instance instance, string taskId, ModelStateDictionary validationResults) { if (taskId.Equals(\u0026#34;Task_1\u0026#34;)) { DateTime deadline = ((DateTime)instance.Created).AddDays(3); if (DateTime.UtcNow \u0026lt; deadline)  { validationResults.AddModelError(\u0026#34;Task_1\u0026#34;, $\u0026#34;Ferdigstilling av Task_1 har tatt for lang tid. Vennligst start på nytt.\u0026#34;); } } } Enkeltfeltvalidering Dersom det er behov for umiddelbar validering av et felt som ikke kan dekkes i klientsidevalideringen, så kan man sette opp en trigger for validering på enkeltfelter i formLayout.json\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;3611fb2a-c06b-4fa7-a400-3f6c1ece64e1\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;25795.OppgavegiverNavnPreutfyltdatadef25795.Label\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;etatid\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;triggers\u0026#34;: [\u0026#34;validation\u0026#34;] , // \u0026lt;--- Add this field  }, { \u0026#34;id\u0026#34;: \u0026#34;9ec368da-d6a9-4fbd-94d0-b4dfa8891981\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Button\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Merk at dersom du definerer at et felt skal trigge validering på serverside, så er det kun resultatet av denne valideringen som vil vises. Det vil si at dersom det er annen klient-side validering som er definert, så vil en ev. server-validering av feltet overskrive disse. Pass derfor på å implementere alle nødvendige\rvalideringer på feltet også på server-siden, det går an å legge flere feilmeldinger på samme felt ved behov.\r\rKonfigurasjonen overfor vil resultere i at din egendefinerte validering i ValidationHandler.cs vil trigges hver gang feltet oppdaterer seg. Dersom du har behov for å vite hvilket felt som trigget valideringen er denne tilgjengelig i http-konteksten som en header på requesten ved navn ValidationTriggerField.\nEt eksempel på en egendefinert validering der headerverdien hentes ut er vist nedenfor.\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { _httpContextAccessor.HttpContext.Request.Headers.TryGetValue(\u0026#34;ValidationTriggerField\u0026#34;, out StringValues value); if (value.Count \u0026gt; 0 \u0026amp;\u0026amp; value[0].Equals(\u0026#34;kommune\u0026#34;)) { // Cast instance data to model type  flyttemelding model = (flyttemelding)data; // Get value to test - Kommune  string kommune = model.kommune; if (!kommune.Equals(\u0026#34;Oslo\u0026#34;)) { validationResults.AddModelError(value[0], \u0026#34;Dette er ikke en gyldig kommune.\u0026#34;); } } await Task.CompletedTask; } OBS Merk at validering av enkeltfelter bør implementeres slik at det kjører både på trigger og under generell validering. Eksempelet som omhandler flere komplekse valideringer viser hvordan dette kan implementeres.\nDet er gjort flere ting for å få denne kodesnutten til å kjøre\n I ValidationHandler.cs inkluderes using Microsoft.Extensions.Primitives; øverst i filen for å kunne ta i bruk StringValues. I App.cs inkluderes using Microsoft.AspNetCore.Http; øverst i filen for å kunne ta i bruk IHttpContextAccessor. I App.cs dependency injectes IHttpContextAccessor i konstruktøren og sendes med videre til ValidationHandler.  public App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IHttpContextAccessor httpContextAccessor // \u0026lt;--- Add this line  ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); // \u0026lt;--- Include the new property here  _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService); } Dersom man har flere komplekse valideringer som er tidkrevende er det anbefalt å implementere flere private metoder for validering av disse og bruke ValidationTriggerField til å avgjøre hvilken private metode som skal kjøres. Man kan bl.a. bruke en switch statement for å oppnå dette.\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { if (data is flyttemelding model)) { _httpContextAccessor.HttpContext.Request.Headers .TryGetValue(\u0026#34;ValidationTriggerField\u0026#34;, out StringValues value); string dataField = value.Any() ? value[0] : string.Empty; switch (dataField) { case \u0026#34;kommune\u0026#34;: ValidateKommune(model, validationResults); break; case \u0026#34;boaddresse\u0026#34;: ValidateBoAdresse(model, validationResults); break; default: ValidateKommune(model, validationResults); ValidateBoAdresse(model, validationResults); break; } } } private void ValidateKommune(flyttemelding model, ModelStateDictionary validationResults) { if (model.kommune != null \u0026amp;\u0026amp; !model.kommune.Equals(\u0026#34;Oslo\u0026#34;)) { validationResults.AddModelError( nameof(model.kommune), \u0026#34;Dette er ikke en gyldig kommune.\u0026#34;); } } private void ValidateBoAdresse(flyttemelding model, ModelStateDictionary validationResults) { if (model.boaddresse != null \u0026amp;\u0026amp; model.boaddresse.Length \u0026gt; 150) { validationResults.AddModelError( nameof(model.boaddresse), \u0026#34;Boadresse kan ikke være lengere enn 150 tegn.\u0026#34;); } } Spesifisere at valideringsfeil er fikset Når validering trigges av et enkelt felt, så vil alle tidligere valideringer på dette feltet fjernes i påvente av svar fra den siste valideringen. Dersom et felt trigger validering som oppdaterer/legger til feilmelding på flere felter på en gang, vil ikke disse fjernes selv om det ikke lenger er noen feil i disse feltene. Dette er fordi man ikke har noen måte å vite hvilke felter som ev. er validert ifm en enkeltfeltvalidering.\nF.eks., dersom man har 2 felter: fornavn og etternavn. Begge felter trigger enkeltfeltvalidering, og dersom begge feltene har verdi så validerer man at fullt navn ikke kan være lengre enn 50 tegn. Feilmelding settes da på begge feltene. Dersom man retter opp i dette ved å endre fornavn, vil feilmeldingen fra fornavn-feltet forsvinne, men feilmeldingen som vises på etternavn-feltet vises fortsatt selv om valideringen ikke setter noen feilmeldinger på feltene.\nprivate void ValidateFullName(Datamodell model, ModelStateDictionary validationResults) { if (!string.isNullOrEmpty(model.fornavn) \u0026amp;\u0026amp; !string.isNullOrEmpty(model.etternavn) \u0026amp;\u0026amp; model.fornavn.Length + model.etternavn.Length \u0026gt; 50) { validationResults.addModelError(nameof(model.fornavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } } For å kunne fjerne gamle feilmeldinger i et sånt tilfelle, er det lagt til støtte for å kunne spesifisere at en valideringsfeil er fikset. Da vil det aktuelle feltet kunne få beskjed om at en spesifikk feilmelding som den viser frem er fikset og skal skjules.\nDette gjøres ved å legge til en valideringsfeil i koden i det tilfellet der det ikke er noen feil i valideringen, og sette *FIXED* foran selve feilmeldingen. Dette tilsvarer oppsettet for myk validering. Denne prefixen gjør at feilmeldingen som settes fjernes fra det aktuelle feltet, eller ignoreres (dersom det ikke er noen feilmelding på feltet fra før).\nMan kan da utvide eksempelet over for å støtte dette:\nprivate void ValidateFullName(Datamodell model, ModelStateDictionary validationResults) { if (!string.isNullOrEmpty(model.fornavn) \u0026amp;\u0026amp; !string.isNullOrEmpty(model.etternavn) \u0026amp;\u0026amp; model.fornavn.Length + model.etternavn.Length \u0026gt; 50) { validationResults.addModelError(nameof(model.fornavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } else { validationResults.addModelError(nameof(model.fornavn), \u0026#34;*FIXED*Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;);  validationResults.addModelError(nameof(model.etternavn), \u0026#34;*FIXED*Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;);  } } Myk validering Myke valideringer (eller advarsler) er valideringsmeldinger som ikke stopper bruker fra å sende inn eller gå videre til neste steg i prosessen. Denne typen valideringer kan f.eks. brukes til å be brukeren om å verifisere input som virker feil eller rart, men som strengt tatt ikke er ugyldig.\nMeldinger basert på myke validering vil vises en gang, men bruker kan velge å klikke seg videre uten å utføre endringer.\nMyke valideringer legges til fra server-siden i validerings-logikken, på samme måte som vanlige validerings-feil. Forskjellen er at valideringsmeldingen må prefixes med *WARNING*. Dette vil da tolkes som en myk validering. Prefixen *WARNING* blir ikke synlig for sluttbruker.\nKodeeksempel\npublic async Task ValidateData(object data, ModelStateDictionary modelState) { if (data is TestModel testModel) { string firstName = testModel?.Person?.FirstName; if (firstName != null \u0026amp;\u0026amp; firstName.Contains(\u0026#34;1337\u0026#34;)) { validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;*WARNING*Are you sure your first name contains 1337?\u0026#34;); } } await Task.CompletedTask; } Gruppevalidering Det er mulig å gjøre valideringer på en repeterende gruppe i det brukeren ønsker å lagre en gitt indeks. Dette gjøres ved å legge til en trigger på gruppe-komponenten i layoutfilen (f.eks FormLayout.json). Eksempel:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;demo-gruppe\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;...\u0026#34; ], \u0026#34;maxCount\u0026#34;: 3, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;Endringsmelding-grp-9786.OversiktOverEndringene-grp-9788\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;validation\u0026#34;] // \u0026lt;--- Legg til denne  }, ... ] } } Dette vil da sørge for at det vil kjøres validering på komponentene som er en del av gruppen på den aktuelle indeksen man jobber på. Om det finnes valideringsfeil så vil man stoppes fra å lagre gruppen før dette er rettet opp i.\nOm man legger til validering på gruppe-komponenten så vil det også gå et kall mot valideringen backend med en header som spesifiserer hvilken komponent som trigget valideringen: ComponentId. Valideringer er skrevet i C#, i ValidationHandler.cs-filen i applikasjonsmalen. I valideringen kan man så hente ut denne id\u0026rsquo;en og skreddersy eventuelle valideringer som skal gjøres backend, eksempel:\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { if (data is flyttemelding model)) { _httpContextAccessor.HttpContext.Request.Headers .TryGetValue(\u0026#34;ComponentId\u0026#34;, out StringValues value); string component = value.Any() ? value[0] : string.Empty; switch (component) { case \u0026#34;demo-group\u0026#34;: // kjør valideringer spesifikke til gruppen  break; default: // kjør valideringene i sin helhet  break; } } } For tips til hvordan man løser komplekse valideringer se ekemplene under enkeltfeltvalidering.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/validering/",
	"title": "validering",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/open-source/",
	"title": "Altinn og åpen kildekode",
	"tags": [],
	"description": "Altinn 3 er åpen kildekode, med en åpen backlog, åpen dokumentasjon og åpen dialog og diskusjoner.",
	"content": "Det er flere som har fått med seg at Altinn har tatt en fundamentalt ny og åpen retning de siste årene.\nVi har fått litt spørsmål om hvorfor vi har gjort dette, og tenker det kan være interessant at vi deler våre tanker om åpen kildekode, som en sentral nasjonal felleskomponent.\nDeling og gjenbruk Det finnes mange gode grunner til å dele kode som åpen kildekode.\nNAV, en av de virkelig store inne åpen kildekode i Norge, er også inne på flere av de samme punktene, men særlig dette med viktigheten av gjennomsiktighet og tillit i forhold til løsninger finansiert av det offentlige.\nVi applauderer når NAV skriver dette:\n Offentlig finansierte løsninger bør være offentlig tilgjengelig.\nMotivasjonen er da ikke hovedsakelig gjenbruk, selv om det selvsagt er en heldig bieffekt. Motivasjonen er først og fremst åpenhet og gjennomsiktighet i de digitale løsningene.\n Gjenbruk er derimot noe vi i Altinn anser som en helt sentral motivasjon. Og vi er ikke alene om å tenke slik:\n gov.uk sin Open Source, Open Standards and Re­Use (PDF) beskriver gjenbruk som både en policy og et prinsipp. EU har lenge hatt en tydelig open source strategi (PDF) som sier at kildekode skal deles, og ikke bare det, men at man også bør bidra tilbake.  Vi legger til rette for gjenbruk og deling på alle nivåer i arkitekturen til Altinn 3, fra våre prinsipper til hele plattformen og infrastrukturen, ned til design og GUI-komponenter, kode og konfigurasjon.\nDette er også en av flere grunner til at Altinn nå er et digitalt fellesgode (DPG), der målsettingen er å kunne gjenbruke det vi utvikler ikke bare på nasjonalt nivå, men også globalt for å understøtte FNs bærekraftsmål.\nVi oppfordrer også alle de som lager tjenester med Altinn Studio til å dele sine apper, og alt er tilrettelagt for at det skjer automatisk. Faktisk så må tjenesteeierne gjøre et aktivt valg for å ikke dele, siden deling og gjenbruk på tvers i det offentlige er helt sentralt i Altinn 3.\nSamarbeid Den beste måten å få til et godt samarbeid på tvers av organisasjoner og prosjekter er åpenhet og gjennomsiktighet, at alle kan bidra, gi input, bli hørt, følge med på det som skjer.\nDet er dette som har vært helt sentralt i \u0026ldquo;revolusjonen\u0026rdquo; med åpen kildekode, som har blitt den nye normalen for store deler av programvareutvikling i verden. Det er nå 40 millioner utviklere og over 28 millioner åpne repos på GitHub.\nSiden alle våre verktøy og avhengigeheter ligger åpent på GitHub så kan også vi i Altinn følge med, samarbeide og bidra tilbake til programvare som vi benytter.\nEksempler på dette er .NET, Kubernetes, React, Linkerd og Gitea.\nOg vår issue #5992 er et godt eksempel på hvordan vi kan spore og enkelt lenke til saker på tvers av programvare.\nOg siden Altinn er åpen kildekode på GitHub, så er det like enkelt for alle andre å gjøre det samme mot oss. Både det å opprette nye issues, bidra i diskusjoner eller bidra med kode, noe labelen external-contribution-❤️ illustrerer godt.\nLeverandørbindinger Altinn som felleskomponent har tidligere fått store utfordringer ved å basere seg på lukket proprietær programvare. Programvare fra Adobe i Altinn 1 og fra Microsoft i Altinn 2.\nEnd-of-life for proprietær programvare er faktisk hovedårsaken til behovet for å lage Altinn 3.\nNår du bygger en løsning på toppen av proprietær programvare så har du i praksis mistet kontroll over egen fremtid, f.eks. om leverandøren velger å fase ut produktet. Om man baserer seg på åpen kildekode så kan man i en slik situasjon lage en fork, om ikke noen andre gjør det.\nAltinn 3 er derfor basert på programvare og biblioteker som er åpen kildekode.\nVi tenker at dette naturlig nok også er veldig viktig for de som vurderer om man skal ta i bruk Altinn.\nHvilke bindinger innfører vi til Altinn som teknisk løsning og Digdir som \u0026ldquo;leverandør\u0026rdquo;? Selv om Altinn er et samarbeid, så vil dette være viktige spørsmål.\nAltinn 3 er derfor helt åpen kildekode med liberal lisensiering, og alt som utvikles kjører som vanlige containere.\nDe beste verktøyene For å utvikle god programvare så er det viktig å ha tilgang til gode verktøy.\nEn ting som mange kanskje ikke tenker på er at når du deler det du utvikler som åpen kildekode, så blir mange av de aller beste verktøyene der ute tilgjengelig - helt gratis.\n\u0026ldquo;Del, og du blir delt med\u0026hellip;\u0026quot;\nHer er noen av de fantastiske SaaS-verktøyene som vi benytter:\n GitHub - Håndtering av kildekode, backlogs, boards, automatisering, CI/CD, etc. ZenHub - Epos, estimering, avhengigheter, rapporter. Cypress - Dashboards og automatisert testing av GUI. SonarCloud - Statisk analyse av kildekode. LGTM - Sikkerhetsanalyse av kildekode.  Og dette er bare et lite utvalg\u0026hellip;\nAlle verktøy og rammeverk som vi bygger Altinn på toppen av, er åpen programvare som er veldig godt likt.\nDe beste folkene Det er et gjennomgående tema at folk liker å jobbe med ny teknologi og de beste verktøyene. De beste utviklerne foretrekker også å jobbe med åpen kildekode, føle at man bidrar til noe større, at man setter spor.\nI tiden som har gått siden vi lanserte Altinn 3 så har vi ansatt en del veldig dyktige folk, og et gjennomganstema i intervjuer og diskusjoner er at de beste kandidatene er tydelige på at de synes det er viktig med åpen kildekode, og at dette er noe de ønsker å være med på.\nVi ønsker å bygge et stort community, der alle kan bidra, og da er det ekstremt viktig at vi har teams med dyktige og fornøyde utviklere som kan hjelpe til med å få det til å skje.\n"
}]